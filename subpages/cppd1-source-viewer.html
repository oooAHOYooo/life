<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<title>CPPd1 C++ Source Viewer — LifeOS</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #0d1117;
  --sidebar-bg: #161b22;
  --border: #30363d;
  --header-bg: #010409;
  --text: #e6edf3;
  --muted: #7d8590;
  --dim: #484f58;
  --accent: #58a6ff;
  --accent2: #79c0ff;
  --folder: #e3b341;
  --ext-cpp: #f78166;
  --ext-h: #79c0ff;
  --active-bg: #1f2937;
  --active-border: #58a6ff;
  --scrollbar: #30363d;
  --tag-bg: #21262d;
}

html, body {
  height: 100%;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  background: var(--bg);
  color: var(--text);
  overflow: hidden;
}

/* ── LAYOUT ──────────────────────────────────────────────────────────────── */
#app { display: flex; flex-direction: column; height: 100vh; }

/* HEADER */
#header {
  background: var(--header-bg);
  border-bottom: 1px solid var(--border);
  padding: 10px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  flex-shrink: 0;
  z-index: 20;
  flex-wrap: wrap;
  row-gap: 6px;
}

#hamburger {
  display: none;
  background: none;
  border: none;
  color: var(--muted);
  font-size: 18px;
  cursor: pointer;
  padding: 4px 6px;
  border-radius: 4px;
  line-height: 1;
  flex-shrink: 0;
}
#hamburger:hover { color: var(--text); background: rgba(255,255,255,0.06); }

#header-title { font-size: 14px; font-weight: 600; white-space: nowrap; }
#header-title span { color: var(--accent); }

.badge {
  background: var(--tag-bg);
  border: 1px solid var(--border);
  border-radius: 20px;
  padding: 2px 9px;
  font-size: 11px;
  color: var(--muted);
  white-space: nowrap;
}

#back-link {
  color: var(--muted);
  text-decoration: none;
  font-size: 12px;
  padding: 3px 8px;
  border: 1px solid var(--border);
  border-radius: 5px;
  transition: color .15s, border-color .15s;
}
#back-link:hover { color: var(--accent); border-color: var(--accent); }

#search-wrap {
  margin-left: auto;
  position: relative;
  display: flex;
  align-items: center;
}
#search {
  background: #0d1117;
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 5px 10px 5px 28px;
  color: var(--text);
  font-size: 13px;
  width: 200px;
  outline: none;
  transition: border-color .15s, width .2s;
}
#search:focus { border-color: var(--accent); width: 250px; }
#search::placeholder { color: var(--dim); }
#search-icon { position: absolute; left: 8px; color: var(--dim); font-size: 13px; pointer-events: none; }

/* BODY */
#body { display: flex; flex: 1; overflow: hidden; position: relative; }

/* SIDEBAR */
#sidebar {
  width: 270px;
  flex-shrink: 0;
  background: var(--sidebar-bg);
  border-right: 1px solid var(--border);
  overflow-y: auto;
  overflow-x: hidden;
  padding: 8px 0 20px;
  transition: transform .2s ease;
}
#sidebar::-webkit-scrollbar { width: 4px; }
#sidebar::-webkit-scrollbar-thumb { background: var(--scrollbar); border-radius: 2px; }

/* MAIN */
#main { flex: 1; display: flex; flex-direction: column; overflow: hidden; min-width: 0; }

#file-header {
  background: var(--sidebar-bg);
  border-bottom: 1px solid var(--border);
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
  min-height: 40px;
  overflow: hidden;
}
#breadcrumb { font-size: 12px; color: var(--muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; }
#breadcrumb span { color: var(--text); font-weight: 500; }
#breadcrumb .sep { margin: 0 3px; color: var(--dim); }
#line-count { font-size: 11px; color: var(--dim); white-space: nowrap; flex-shrink: 0; }

#code-wrap { flex: 1; overflow: auto; }
#code-wrap::-webkit-scrollbar { width: 8px; height: 8px; }
#code-wrap::-webkit-scrollbar-track { background: var(--bg); }
#code-wrap::-webkit-scrollbar-thumb { background: var(--scrollbar); border-radius: 4px; }

/* ── TREE ──────────────────────────────────────────────────────────────────── */
.tree-folder-label {
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 4px 10px;
  font-size: 11px;
  font-weight: 600;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  cursor: pointer;
  user-select: none;
}
.tree-folder-label:hover { background: rgba(255,255,255,0.04); color: var(--folder); }
.tree-folder-label .icon { font-size: 9px; transition: transform .15s; }
.tree-folder-label.open .icon { transform: rotate(90deg); }

.tree-children { display: none; }
.tree-children.open { display: block; }

.tree-file {
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 3px 10px;
  font-size: 12px;
  color: var(--muted);
  cursor: pointer;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  border-left: 2px solid transparent;
  transition: background .1s, color .1s;
}
.tree-file:hover { background: rgba(255,255,255,0.04); color: var(--text); }
.tree-file.active { background: var(--active-bg); color: var(--accent); border-left-color: var(--active-border); }
.ext-cpp { color: var(--ext-cpp); font-size: 10px; font-weight: 700; flex-shrink: 0; }
.ext-h   { color: var(--ext-h);   font-size: 10px; font-weight: 700; flex-shrink: 0; }

/* ── WELCOME ──────────────────────────────────────────────────────────────── */
#welcome { padding: 40px 32px; max-width: 680px; }
#welcome h2 { font-size: 20px; font-weight: 700; margin-bottom: 10px; }
#welcome p { font-size: 13px; color: var(--muted); line-height: 1.7; margin-bottom: 18px; }
.section-row {
  display: flex; align-items: center; gap: 10px;
  padding: 9px 14px;
  background: var(--sidebar-bg);
  border: 1px solid var(--border);
  border-radius: 7px;
  font-size: 13px;
  cursor: pointer;
  margin-bottom: 6px;
  transition: border-color .15s, color .15s;
}
.section-row:hover { border-color: var(--accent); color: var(--accent); }
.section-row .count { margin-left: auto; color: var(--dim); font-size: 12px; }

/* ── CODE ──────────────────────────────────────────────────────────────────── */
pre {
  margin: 0;
  padding: 16px 20px;
  font-size: 13px;
  line-height: 1.6;
  font-family: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', 'SF Mono', Menlo, Monaco, Consolas, monospace;
}
pre code.hljs { background: transparent !important; padding: 0 !important; font-size: inherit; font-family: inherit; }
.hljs { background: var(--bg) !important; }

/* ── SEARCH RESULTS ──────────────────────────────────────────────────────── */
#search-results { display: none; flex-direction: column; overflow-y: auto; padding: 10px 16px; gap: 3px; }
#search-results.visible { display: flex; }
.sr-item {
  display: flex; gap: 8px; align-items: center;
  padding: 5px 8px; border-radius: 5px; cursor: pointer; font-size: 12px;
}
.sr-item:hover { background: rgba(255,255,255,0.05); }
.sr-file { color: var(--accent); font-weight: 600; white-space: nowrap; flex-shrink: 0; }
.sr-line { color: var(--dim); font-size: 11px; white-space: nowrap; flex-shrink: 0; }
.sr-text { color: var(--muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-family: monospace; font-size: 11px; }
.sr-match { color: var(--accent2); font-weight: bold; }

/* ── OVERLAY (mobile sidebar backdrop) ──────────────────────────────────── */
#overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  z-index: 15;
}

/* ── MOBILE ──────────────────────────────────────────────────────────────── */
@media (max-width: 700px) {
  #hamburger { display: block; }

  #sidebar {
    position: absolute;
    top: 0; left: 0; bottom: 0;
    z-index: 16;
    transform: translateX(-100%);
    border-right: 1px solid var(--border);
    box-shadow: 4px 0 20px rgba(0,0,0,0.5);
  }
  #sidebar.open { transform: translateX(0); }
  #overlay.open { display: block; }

  #search { width: 150px; }
  #search:focus { width: 180px; }

  pre { font-size: 11.5px; padding: 12px 14px; }

  .badge:nth-child(3) { display: none; }
}
</style>
</head>
<body>
<div id="app">
  <header id="header">
    <button id="hamburger" aria-label="Toggle file tree">☰</button>
    <div id="header-title"><span>CPPd1</span> C++ Source</div>
    <span class="badge">134 files</span>
    <span class="badge">10,693 lines</span>
    <a href="cppd1.html" id="back-link">← CPPd1 Hub</a>
    <div id="search-wrap">
      <span id="search-icon">⌕</span>
      <input id="search" type="text" placeholder="Search… (⌘K)" autocomplete="off" spellcheck="false">
    </div>
  </header>

  <div id="body">
    <div id="overlay"></div>
    <nav id="sidebar" aria-label="File tree">
      <div id="tree-root"></div>
    </nav>
    <main id="main">
      <div id="file-header">
        <div id="breadcrumb">← select a file</div>
        <div id="line-count"></div>
      </div>
      <div id="code-wrap">
        <div id="welcome">
          <h2>CPPd1 — Unreal Engine 5 C++</h2>
          <p>Browse all 134 source files from the sidebar (or tap ☰ on mobile). This project is an Unreal Engine 5 C++ game framework with three gameplay variants: Combat (ninja/marauder), Platforming, and SideScrolling.</p>
          <div id="quick-nav"></div>
        </div>
        <pre id="code-pre" style="display:none"><code id="code-display" class="language-cpp"></code></pre>
        <div id="search-results"></div>
      </div>
    </main>
  </div>
</div>

<script>
const FILES = {"CPPd1.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CPPd1.h\"\n#include \"Modules/ModuleManager.h\"\n\nIMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, CPPd1, \"CPPd1\" );\n\nDEFINE_LOG_CATEGORY(LogCPPd1)","CPPd1.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n\n// Module API macro - for classes that need to be exported\n#ifndef CPPd1_API\n\t#define CPPd1_API\n#endif\n\n/** Main log category used across the project */\nDECLARE_LOG_CATEGORY_EXTERN(LogCPPd1, Log, All);","CPPd1Character.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CPPd1Character.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"GameFramework/Controller.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"InputActionValue.h\"\n#include \"CPPd1.h\"\n\nACPPd1Character::ACPPd1Character()\n{\n\t// Set size for collision capsule\n\tGetCapsuleComponent()->InitCapsuleSize(42.f, 96.0f);\n\t\t\n\t// Don't rotate when the controller rotates. Let that just affect the camera.\n\tbUseControllerRotationPitch = false;\n\tbUseControllerRotationYaw = false;\n\tbUseControllerRotationRoll = false;\n\n\t// Configure character movement\n\tGetCharacterMovement()->bOrientRotationToMovement = true;\n\tGetCharacterMovement()->RotationRate = FRotator(0.0f, 500.0f, 0.0f);\n\n\t// Note: For faster iteration times these variables, and many more, can be tweaked in the Character Blueprint\n\t// instead of recompiling to adjust them\n\tGetCharacterMovement()->JumpZVelocity = 500.f;\n\tGetCharacterMovement()->AirControl = 0.35f;\n\tGetCharacterMovement()->MaxWalkSpeed = 500.f;\n\tGetCharacterMovement()->MinAnalogWalkSpeed = 20.f;\n\tGetCharacterMovement()->BrakingDecelerationWalking = 2000.f;\n\tGetCharacterMovement()->BrakingDecelerationFalling = 1500.0f;\n\n\t// Create a camera boom (pulls in towards the player if there is a collision)\n\tCameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraBoom\"));\n\tCameraBoom->SetupAttachment(RootComponent);\n\tCameraBoom->TargetArmLength = 400.0f;\n\tCameraBoom->bUsePawnControlRotation = true;\n\n\t// Create a follow camera\n\tFollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FollowCamera\"));\n\tFollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName);\n\tFollowCamera->bUsePawnControlRotation = false;\n\n\t// Note: The skeletal mesh and anim blueprint references on the Mesh component (inherited from Character) \n\t// are set in the derived blueprint asset named ThirdPersonCharacter (to avoid direct content references in C++)\n}\n\nvoid ACPPd1Character::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\t// Set up action bindings\n\tif (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent)) {\n\t\t\n\t\t// Jumping\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Started, this, &ACharacter::Jump);\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Completed, this, &ACharacter::StopJumping);\n\n\t\t// Moving\n\t\tEnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &ACPPd1Character::Move);\n\t\tEnhancedInputComponent->BindAction(MouseLookAction, ETriggerEvent::Triggered, this, &ACPPd1Character::Look);\n\n\t\t// Looking\n\t\tEnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &ACPPd1Character::Look);\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogCPPd1, Error, TEXT(\"'%s' Failed to find an Enhanced Input component! This template is built to use the Enhanced Input system. If you intend to use the legacy system, then you will need to update this C++ file.\"), *GetNameSafe(this));\n\t}\n}\n\nvoid ACPPd1Character::Move(const FInputActionValue& Value)\n{\n\t// input is a Vector2D\n\tFVector2D MovementVector = Value.Get<FVector2D>();\n\n\t// route the input\n\tDoMove(MovementVector.X, MovementVector.Y);\n}\n\nvoid ACPPd1Character::Look(const FInputActionValue& Value)\n{\n\t// input is a Vector2D\n\tFVector2D LookAxisVector = Value.Get<FVector2D>();\n\n\t// route the input\n\tDoLook(LookAxisVector.X, LookAxisVector.Y);\n}\n\nvoid ACPPd1Character::DoMove(float Right, float Forward)\n{\n\tif (GetController() != nullptr)\n\t{\n\t\t// find out which way is forward\n\t\tconst FRotator Rotation = GetController()->GetControlRotation();\n\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\n\n\t\t// get forward vector\n\t\tconst FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n\n\t\t// get right vector \n\t\tconst FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n\n\t\t// add movement \n\t\tAddMovementInput(ForwardDirection, Forward);\n\t\tAddMovementInput(RightDirection, Right);\n\t}\n}\n\nvoid ACPPd1Character::DoLook(float Yaw, float Pitch)\n{\n\tif (GetController() != nullptr)\n\t{\n\t\t// add yaw and pitch input to controller\n\t\tAddControllerYawInput(Yaw);\n\t\tAddControllerPitchInput(Pitch);\n\t}\n}\n\nvoid ACPPd1Character::DoJumpStart()\n{\n\t// signal the character to jump\n\tJump();\n}\n\nvoid ACPPd1Character::DoJumpEnd()\n{\n\t// signal the character to stop jumping\n\tStopJumping();\n}\n","CPPd1Character.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"Logging/LogMacros.h\"\n#include \"CPPd1Character.generated.h\"\n\nclass USpringArmComponent;\nclass UCameraComponent;\nclass UInputAction;\nstruct FInputActionValue;\n\nDECLARE_LOG_CATEGORY_EXTERN(LogTemplateCharacter, Log, All);\n\n/**\n *  A simple player-controllable third person character\n *  Implements a controllable orbiting camera\n */\nUCLASS(BlueprintType, Blueprintable)\nclass ACPPd1Character : public ACharacter\n{\n\tGENERATED_BODY()\n\n\t/** Camera boom positioning the camera behind the character */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUSpringArmComponent* CameraBoom;\n\n\t/** Follow camera */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUCameraComponent* FollowCamera;\n\t\nprotected:\n\n\t/** Jump Input Action */\n\tUPROPERTY(EditAnywhere, Category=\"Input\")\n\tUInputAction* JumpAction;\n\n\t/** Move Input Action */\n\tUPROPERTY(EditAnywhere, Category=\"Input\")\n\tUInputAction* MoveAction;\n\n\t/** Look Input Action */\n\tUPROPERTY(EditAnywhere, Category=\"Input\")\n\tUInputAction* LookAction;\n\n\t/** Mouse Look Input Action */\n\tUPROPERTY(EditAnywhere, Category=\"Input\")\n\tUInputAction* MouseLookAction;\n\npublic:\n\n\t/** Constructor */\n\tACPPd1Character();\t\n\nprotected:\n\n\t/** Initialize input action bindings */\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprotected:\n\n\t/** Called for movement input */\n\tvoid Move(const FInputActionValue& Value);\n\n\t/** Called for looking input */\n\tvoid Look(const FInputActionValue& Value);\n\npublic:\n\n\t/** Handles move inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoMove(float Right, float Forward);\n\n\t/** Handles look inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoLook(float Yaw, float Pitch);\n\n\t/** Handles jump pressed inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoJumpStart();\n\n\t/** Handles jump pressed inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoJumpEnd();\n\npublic:\n\n\t/** Returns CameraBoom subobject **/\n\tFORCEINLINE class USpringArmComponent* GetCameraBoom() const { return CameraBoom; }\n\n\t/** Returns FollowCamera subobject **/\n\tFORCEINLINE class UCameraComponent* GetFollowCamera() const { return FollowCamera; }\n};\n\n","CPPd1GameMode.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CPPd1GameMode.h\"\n#include \"CPPd1Character.h\"\n#include \"CPPd1PlayerController.h\"\n\nACPPd1GameMode::ACPPd1GameMode()\n{\n\t// Set default pawn class to CPPd1Character\n\tDefaultPawnClass = ACPPd1Character::StaticClass();\n\t\n\t// Set default player controller\n\tPlayerControllerClass = ACPPd1PlayerController::StaticClass();\n}\n","CPPd1GameMode.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"CPPd1GameModeBase.h\"\n#include \"CPPd1GameMode.generated.h\"\n\n/**\n *  Simple GameMode for a third person game (inherits 2P, rounds, RequestRespawn from CPPd1GameModeBase).\n */\nUCLASS(BlueprintType, Blueprintable)\nclass ACPPd1GameMode : public ACPPd1GameModeBase\n{\n\tGENERATED_BODY()\n\npublic:\n\t\n\t/** Constructor */\n\tACPPd1GameMode();\n};\n\n\n\n","CPPd1GameModeBase.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CPPd1GameModeBase.h\"\n#include \"CPPd1GameStateBase.h\"\n#include \"CPPd1PlayerState.h\"\n#include \"Variant_Combat/CombatCharacter.h\"\n#include \"TimerManager.h\"\n#include \"Engine/World.h\"\n#include \"Math/UnrealMathUtility.h\"\n\nACPPd1GameModeBase::ACPPd1GameModeBase()\n{\n\tGameStateClass = ACPPd1GameStateBase::StaticClass();\n\tPlayerStateClass = ACPPd1PlayerState::StaticClass();\n}\n\nvoid ACPPd1GameModeBase::RequestRespawn(AController* Controller, APawn* DyingPawn)\n{\n\tif (!Controller || !DyingPawn || !GetWorld()) return;\n\tFTimerHandle Handle;\n\tFTimerDelegate Del;\n\tDel.BindUFunction(this, FName(\"OnRespawnTimerFired\"), DyingPawn);\n\tGetWorld()->GetTimerManager().SetTimer(Handle, Del, RespawnDelay, false);\n\t// Keep a reference so the timer isn't cleared when we return (timer is stored in World)\n\tRespawnTimer = Handle;\n}\n\nvoid ACPPd1GameModeBase::OnRespawnTimerFired(APawn* DyingPawn)\n{\n\tif (DyingPawn)\n\t{\n\t\tDyingPawn->Destroy();\n\t}\n}\n\nvoid ACPPd1GameModeBase::PostLogin(APlayerController* NewPlayer)\n{\n\tSuper::PostLogin(NewPlayer);\n\tif (ACPPd1PlayerState* PS = NewPlayer->GetPlayerState<ACPPd1PlayerState>())\n\t{\n\t\tif (ACPPd1GameStateBase* GS = GetGameState<ACPPd1GameStateBase>())\n\t\t{\n\t\t\tconst int32 Index = GS->PlayerArray.Num() - 1;\n\t\t\tPS->SetPlayerIndex(FMath::Clamp(Index, 0, 1));\n\t\t}\n\t}\n}\n\nvoid ACPPd1GameModeBase::RestartPlayer(AController* NewPlayer)\n{\n\tSuper::RestartPlayer(NewPlayer);\n\n\t// Solo play: spawn a ghost character that mirrors the player (2P co-op by default)\n\tif (GetNumPlayers() != 1 || !NewPlayer || !DefaultPawnClass) return;\n\n\tAPawn* MainPawn = NewPlayer->GetPawn();\n\tACombatCharacter* MainChar = Cast<ACombatCharacter>(MainPawn);\n\tif (!MainChar) return;\n\n\tUWorld* World = GetWorld();\n\tif (!World) return;\n\n\tFActorSpawnParameters SpawnParams;\n\tSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;\n\tACombatCharacter* Ghost = World->SpawnActor<ACombatCharacter>(DefaultPawnClass, MainPawn->GetActorLocation(), MainPawn->GetActorRotation(), SpawnParams);\n\tif (!Ghost) return;\n\n\tGhost->bIsGhost = true;\n\tGhost->StoredControlRotation = MainPawn->GetActorRotation();\n\tMainChar->SetGhostCharacter(Ghost);\n}\n\nvoid ACPPd1GameModeBase::EnsureGhostForSoloPlayer(AController* Controller)\n{\n\tif (GetNumPlayers() != 1 || !Controller || !DefaultPawnClass) return;\n\tAPawn* MainPawn = Controller->GetPawn();\n\tACombatCharacter* MainChar = Cast<ACombatCharacter>(MainPawn);\n\tif (!MainChar || MainChar->GetGhostCharacter()) return;\n\n\tUWorld* World = GetWorld();\n\tif (!World) return;\n\n\tFActorSpawnParameters SpawnParams;\n\tSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;\n\tACombatCharacter* Ghost = World->SpawnActor<ACombatCharacter>(DefaultPawnClass, MainPawn->GetActorLocation(), MainPawn->GetActorRotation(), SpawnParams);\n\tif (!Ghost) return;\n\n\tGhost->bIsGhost = true;\n\tGhost->StoredControlRotation = MainPawn->GetActorRotation();\n\tMainChar->SetGhostCharacter(Ghost);\n}\n","CPPd1GameModeBase.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"CPPd1GameModeBase.generated.h\"\n\n/**\n * Game mode base for CPPd1 (ninja-style): 2 players, spawn at starts, round/restart, RequestRespawn on death.\n */\nUCLASS(abstract)\nclass ACPPd1GameModeBase : public AGameModeBase\n{\n\tGENERATED_BODY()\n\npublic:\n\n\tACPPd1GameModeBase();\n\n\t/** Delay before destroying the dead pawn (controller's OnPawnDestroyed will then respawn). */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"CPPd1|Respawn\", meta = (ClampMin = 0, Units = \"s\"))\n\tfloat RespawnDelay = 3.0f;\n\n\t/** Request a respawn for the given controller after RespawnDelay. The dying pawn is destroyed so the controller can respawn it. */\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1\")\n\tvoid RequestRespawn(AController* Controller, APawn* DyingPawn);\n\n\tvirtual void PostLogin(APlayerController* NewPlayer) override;\n\n\t/** Spawns a ghost character for the single player when playing solo (2P co-op by default). */\n\tvirtual void RestartPlayer(AController* NewPlayer) override;\n\n\t/** Call after respawning a pawn (e.g. from controller) to spawn ghost when playing solo. */\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1\")\n\tvoid EnsureGhostForSoloPlayer(AController* Controller);\n\nprotected:\n\n\tFTimerHandle RespawnTimer;\n\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1\")\n\tvoid OnRespawnTimerFired(APawn* DyingPawn);\n};\n","CPPd1GameStateBase.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CPPd1GameStateBase.h\"\n#include \"CPPd1PlayerState.h\"\n\nvoid ACPPd1GameStateBase::SetGamePhase(ECPPd1GamePhase Phase)\n{\n\tGamePhase = Phase;\n}\n\nvoid ACPPd1GameStateBase::StartNextRound()\n{\n\tCurrentRound++;\n\tGamePhase = ECPPd1GamePhase::Fighting;\n}\n\nACPPd1PlayerState* ACPPd1GameStateBase::GetPlayerStateByIndex(int32 PlayerIndex) const\n{\n\tfor (APlayerState* PS : PlayerArray)\n\t{\n\t\tif (ACPPd1PlayerState* CPPd1PS = Cast<ACPPd1PlayerState>(PS))\n\t\t{\n\t\t\tif (CPPd1PS->GetPlayerIndex() == PlayerIndex)\n\t\t\t{\n\t\t\t\treturn CPPd1PS;\n\t\t\t}\n\t\t}\n\t}\n\treturn nullptr;\n}\n","CPPd1GameStateBase.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameStateBase.h\"\n#include \"CPPd1GameStateBase.generated.h\"\n\n/** Phase of the round (ninja / dojo style) */\nUENUM(BlueprintType)\nenum class ECPPd1GamePhase : uint8\n{\n\t/** Waiting to start or between rounds */\n\tWaiting,\n\t/** Round in progress */\n\tFighting,\n\t/** Round ended, someone reached the goal */\n\tRoundEnded\n};\n\n/**\n * Game state for CPPd1: game phase, current round, and player state lookup by index.\n */\nUCLASS(abstract)\nclass ACPPd1GameStateBase : public AGameStateBase\n{\n\tGENERATED_BODY()\n\npublic:\n\n\t/** Current phase of the game */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"CPPd1\")\n\tECPPd1GamePhase GamePhase = ECPPd1GamePhase::Waiting;\n\n\t/** Current round number (1-based) */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"CPPd1\", meta = (ClampMin = 0))\n\tint32 CurrentRound = 0;\n\n\t/** Get player state by player index (0 or 1). Returns nullptr if invalid. */\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1\")\n\tclass ACPPd1PlayerState* GetPlayerStateByIndex(int32 PlayerIndex) const;\n\n\t/** Set game phase (Blueprint / C++). */\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1\")\n\tvoid SetGamePhase(ECPPd1GamePhase Phase);\n\n\t/** Advance to next round and set phase to Fighting. */\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1\")\n\tvoid StartNextRound();\n};\n","CPPd1GoalZone.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CPPd1GoalZone.h\"\n#include \"CPPd1PlayerState.h\"\n#include \"CPPd1GameStateBase.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/Character.h\"\n\nACPPd1GoalZone::ACPPd1GoalZone()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tTriggerBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerBox\"));\n\tSetRootComponent(TriggerBox);\n\tTriggerBox->SetCollisionProfileName(FName(\"OverlapAllDynamic\"));\n\tTriggerBox->OnComponentBeginOverlap.AddDynamic(this, &ACPPd1GoalZone::OnOverlap);\n}\n\nvoid ACPPd1GoalZone::ResetForNewRound()\n{\n\tbRoundAlreadyWon = false;\n}\n\nvoid ACPPd1GoalZone::OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (bOneWinPerRound && bRoundAlreadyWon) return;\n\n\tACharacter* Char = Cast<ACharacter>(OtherActor);\n\tif (!Char) return;\n\n\tAController* Controller = Char->GetController();\n\tif (!Controller) return;\n\n\tACPPd1PlayerState* PS = Controller->GetPlayerState<ACPPd1PlayerState>();\n\tif (!PS) return;\n\n\tbRoundAlreadyWon = true;\n\tconst int32 WinnerIndex = PS->GetPlayerIndex();\n\tOnRoundWon.Broadcast(WinnerIndex);\n\n\tif (UWorld* World = GetWorld())\n\t{\n\t\tif (ACPPd1GameStateBase* GS = World->GetGameState<ACPPd1GameStateBase>())\n\t\t{\n\t\t\tGS->SetGamePhase(ECPPd1GamePhase::RoundEnded);\n\t\t}\n\t}\n}\n","CPPd1GoalZone.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CPPd1GoalZone.generated.h\"\n\nclass UBoxComponent;\n\n/** First player to touch this zone wins the round (e.g. reach the scroll / exit). */\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCPPd1RoundWon, int32, WinningPlayerIndex);\n\n/**\n * Trigger volume: first player (with CPPd1PlayerState) to overlap wins the round.\n * Notifies game state and can be used to advance rounds or end the match.\n */\nUCLASS(abstract)\nclass ACPPd1GoalZone : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\n\tACPPd1GoalZone();\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tTObjectPtr<UBoxComponent> TriggerBox;\n\n\t/** Fired when a player touches the goal (passes their player index). */\n\tUPROPERTY(BlueprintAssignable, Category = \"CPPd1\")\n\tFOnCPPd1RoundWon OnRoundWon;\n\n\t/** If true, only the first overlap wins; further touches are ignored until round is reset. */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"CPPd1\")\n\tbool bOneWinPerRound = true;\n\n\t/** Whether this round already had a winner (reset when starting next round). */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"CPPd1\")\n\tbool bRoundAlreadyWon = false;\n\n\t/** Reset state so the zone can trigger again next round. Call from game mode when starting a new round. */\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1\")\n\tvoid ResetForNewRound();\n\nprotected:\n\n\tUFUNCTION()\n\tvoid OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n","CPPd1InputManager.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CPPd1InputManager.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"TimerManager.h\"\n\nACPPd1InputManager::ACPPd1InputManager()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nECPPd1InputDevice ACPPd1InputManager::GetInputDeviceType(APlayerController* PlayerController)\n{\n\tif (!PlayerController) return ECPPd1InputDevice::KeyboardMouse;\n\n\t// Check if any gamepad input is active\n\tif (PlayerController->IsInputKeyDown(EKeys::Gamepad_LeftX) ||\n\t\tPlayerController->IsInputKeyDown(EKeys::Gamepad_LeftY) ||\n\t\tPlayerController->IsInputKeyDown(EKeys::Gamepad_RightX) ||\n\t\tPlayerController->IsInputKeyDown(EKeys::Gamepad_RightY) ||\n\t\tPlayerController->IsInputKeyDown(EKeys::Gamepad_LeftTrigger) ||\n\t\tPlayerController->IsInputKeyDown(EKeys::Gamepad_RightTrigger) ||\n\t\tPlayerController->IsInputKeyDown(EKeys::Gamepad_Special_Left) ||\n\t\tPlayerController->IsInputKeyDown(EKeys::Gamepad_FaceButton_Bottom))\n\t{\n\t\treturn ECPPd1InputDevice::Gamepad;\n\t}\n\n\treturn ECPPd1InputDevice::KeyboardMouse;\n}\n\nbool ACPPd1InputManager::IsUsingGamepad(APlayerController* PlayerController)\n{\n\treturn GetInputDeviceType(PlayerController) == ECPPd1InputDevice::Gamepad;\n}\n\nbool ACPPd1InputManager::IsUsingKeyboardMouse(APlayerController* PlayerController)\n{\n\treturn GetInputDeviceType(PlayerController) == ECPPd1InputDevice::KeyboardMouse;\n}\n\nvoid ACPPd1InputManager::UpdateInputContextForDevice(APlayerController* PlayerController)\n{\n\tif (!PlayerController) return;\n\n\t// This would switch input mapping contexts based on device\n\t// Implementation depends on your input mapping setup\n\t// You can add/remove different IMCs for gamepad vs keyboard\n}\n\nvoid ACPPd1InputManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Poll input devices every 0.5 seconds\n\tGetWorld()->GetTimerManager().SetTimer(InputPollTimer, this, &ACPPd1InputManager::PollInputDevices, 0.5f, true);\n}\n\nvoid ACPPd1InputManager::PollInputDevices()\n{\n\t// Update input contexts for all players\n\tif (UWorld* World = GetWorld())\n\t{\n\t\tfor (FConstPlayerControllerIterator It = World->GetPlayerControllerIterator(); It; ++It)\n\t\t{\n\t\t\tif (APlayerController* PC = It->Get())\n\t\t\t{\n\t\t\t\tUpdateInputContextForDevice(PC);\n\t\t\t}\n\t\t}\n\t}\n}\n","CPPd1InputManager.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CPPd1InputManager.generated.h\"\n\n/** Input device type */\nUENUM(BlueprintType)\nenum class ECPPd1InputDevice : uint8\n{\n\tKeyboardMouse,\n\tGamepad\n};\n\n/**\n * Manages input device detection and switching between gamepad and keyboard/mouse\n * Supports 2-player with separate input devices\n */\nUCLASS(BlueprintType, Blueprintable)\nclass ACPPd1InputManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\n\tACPPd1InputManager();\n\n\t/** Get the input device type for a player controller */\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1|Input\")\n\tstatic ECPPd1InputDevice GetInputDeviceType(class APlayerController* PlayerController);\n\n\t/** Check if player is using gamepad */\n\tUFUNCTION(BlueprintPure, Category = \"CPPd1|Input\")\n\tstatic bool IsUsingGamepad(class APlayerController* PlayerController);\n\n\t/** Check if player is using keyboard/mouse */\n\tUFUNCTION(BlueprintPure, Category = \"CPPd1|Input\")\n\tstatic bool IsUsingKeyboardMouse(class APlayerController* PlayerController);\n\n\t/** Switch input context based on device type */\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1|Input\")\n\tstatic void UpdateInputContextForDevice(class APlayerController* PlayerController);\n\nprotected:\n\n\tvirtual void BeginPlay() override;\n\n\t/** Poll input devices periodically */\n\tFTimerHandle InputPollTimer;\n\n\tUFUNCTION()\n\tvoid PollInputDevices();\n};\n","CPPd1LockOnTargetComponent.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CPPd1LockOnTargetComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"EngineUtils.h\"\n\nUCPPd1LockOnTargetComponent::UCPPd1LockOnTargetComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nFVector UCPPd1LockOnTargetComponent::GetLockOnWorldLocation() const\n{\n\tAActor* Owner = GetOwner();\n\tif (!Owner) return FVector::ZeroVector;\n\n\tFVector BaseLocation = Owner->GetActorLocation();\n\n\tif (TargetBoneOrSocketName.IsNone() == false)\n\t{\n\t\tif (USkeletalMeshComponent* Mesh = Owner->FindComponentByClass<USkeletalMeshComponent>())\n\t\t{\n\t\t\tif (Mesh->DoesSocketExist(TargetBoneOrSocketName))\n\t\t\t{\n\t\t\t\tBaseLocation = Mesh->GetSocketLocation(TargetBoneOrSocketName);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst int32 BoneIndex = Mesh->GetBoneIndex(TargetBoneOrSocketName);\n\t\t\t\tif (BoneIndex != INDEX_NONE)\n\t\t\t\t{\n\t\t\t\t\tBaseLocation = Mesh->GetBoneLocation(TargetBoneOrSocketName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn BaseLocation + Owner->GetActorTransform().TransformVector(TargetOffset);\n}\n\nvoid UCPPd1LockOnTargetComponent::FindLockOnTargetsInRadius(UObject* WorldContextObject, FVector Origin, float Radius, TArray<AActor*>& OutTargets)\n{\n\tOutTargets.Reset();\n\tUWorld* World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::ReturnNull);\n\tif (!World) return;\n\n\tTArray<AActor*> Candidates;\n\tfor (TActorIterator<AActor> It(World); It; ++It)\n\t{\n\t\tAActor* A = *It;\n\t\tif (A && A->FindComponentByClass<UCPPd1LockOnTargetComponent>())\n\t\t{\n\t\t\tconst float DistSq = FVector::DistSquared(A->GetActorLocation(), Origin);\n\t\t\tif (DistSq <= Radius * Radius)\n\t\t\t{\n\t\t\t\tCandidates.Add(A);\n\t\t\t}\n\t\t}\n\t}\n\tCandidates.Sort([&Origin](const AActor& A, const AActor& B) {\n\t\treturn FVector::DistSquared(A.GetActorLocation(), Origin) < FVector::DistSquared(B.GetActorLocation(), Origin);\n\t});\n\tOutTargets = MoveTemp(Candidates);\n}\n","CPPd1LockOnTargetComponent.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CPPd1LockOnTargetComponent.generated.h\"\n\n/**\n * Add this component to any actor to make it a valid lock-on target (e.g. enemies, dummies).\n * Ninja-style focus target for the player.\n */\nUCLASS(ClassGroup = (CPPd1), meta = (BlueprintSpawnableComponent))\nclass UCPPd1LockOnTargetComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\n\tUCPPd1LockOnTargetComponent();\n\n\t/** Optional socket or bone name on the owner's mesh to aim at. If empty, use actor location. */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"CPPd1|Lock-On\")\n\tFName TargetBoneOrSocketName;\n\n\t/** World offset from actor location (or bone) for the lock-on point. */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"CPPd1|Lock-On\")\n\tFVector TargetOffset = FVector::ZeroVector;\n\n\t/** Get world location that lock-on should aim at (e.g. for camera or character rotation). */\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1|Lock-On\")\n\tFVector GetLockOnWorldLocation() const;\n\n\t/** Find all actors with a lock-on target component within radius of Origin. Sorted by distance (nearest first). */\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1|Lock-On\", meta = (WorldContext = \"WorldContextObject\"))\n\tstatic void FindLockOnTargetsInRadius(UObject* WorldContextObject, FVector Origin, float Radius, TArray<AActor*>& OutTargets);\n};\n","CPPd1PlayerController.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CPPd1PlayerController.h\"\n#include \"CPPd1PlayerState.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"InputMappingContext.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"CPPd1.h\"\n#include \"Widgets/Input/SVirtualJoystick.h\"\n\nvoid ACPPd1PlayerController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// only spawn touch controls on local player controllers\n\tif (SVirtualJoystick::ShouldDisplayTouchInterface() && IsLocalPlayerController())\n\t{\n\t\t// spawn the mobile controls widget\n\t\tMobileControlsWidget = CreateWidget<UUserWidget>(this, MobileControlsWidgetClass);\n\n\t\tif (MobileControlsWidget)\n\t\t{\n\t\t\t// add the controls to the player screen\n\t\t\tMobileControlsWidget->AddToPlayerScreen(0);\n\n\t\t} else {\n\n\t\t\tUE_LOG(LogCPPd1, Error, TEXT(\"Could not spawn mobile controls widget.\"));\n\n\t\t}\n\n\t}\n}\n\nvoid ACPPd1PlayerController::SetupInputComponent()\n{\n\tSuper::SetupInputComponent();\n\n\t// only add IMCs for local player controllers\n\tif (IsLocalPlayerController())\n\t{\n\t\t// Add Input Mapping Contexts\n\t\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer()))\n\t\t{\n\t\t\tfor (UInputMappingContext* CurrentContext : DefaultMappingContexts)\n\t\t\t{\n\t\t\t\tSubsystem->AddMappingContext(CurrentContext, 0);\n\t\t\t}\n\n\t\t\t// only add these IMCs if we're not using mobile touch input\n\t\t\tif (!SVirtualJoystick::ShouldDisplayTouchInterface())\n\t\t\t{\n\t\t\t\tfor (UInputMappingContext* CurrentContext : MobileExcludedMappingContexts)\n\t\t\t\t{\n\t\t\t\t\tSubsystem->AddMappingContext(CurrentContext, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint32 ACPPd1PlayerController::GetPlayerIndex() const\n{\n\tif (ACPPd1PlayerState* PS = GetPlayerState<ACPPd1PlayerState>())\n\t{\n\t\treturn PS->GetPlayerIndex();\n\t}\n\treturn 0;\n}\n","CPPd1PlayerController.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"CPPd1PlayerController.generated.h\"\n\nclass UInputMappingContext;\nclass UUserWidget;\n\n/**\n *  Basic PlayerController class for a third person game\n *  Manages input mappings\n */\nUCLASS(abstract)\nclass ACPPd1PlayerController : public APlayerController\n{\n\tGENERATED_BODY()\n\t\nprotected:\n\n\t/** Input Mapping Contexts */\n\tUPROPERTY(EditAnywhere, Category =\"Input|Input Mappings\")\n\tTArray<UInputMappingContext*> DefaultMappingContexts;\n\n\t/** Input Mapping Contexts */\n\tUPROPERTY(EditAnywhere, Category=\"Input|Input Mappings\")\n\tTArray<UInputMappingContext*> MobileExcludedMappingContexts;\n\n\t/** Mobile controls widget to spawn */\n\tUPROPERTY(EditAnywhere, Category=\"Input|Touch Controls\")\n\tTSubclassOf<UUserWidget> MobileControlsWidgetClass;\n\n\t/** Pointer to the mobile controls widget */\n\tTObjectPtr<UUserWidget> MobileControlsWidget;\n\n\t/** Gameplay initialization */\n\tvirtual void BeginPlay() override;\n\n\t/** Input mapping context setup */\n\tvirtual void SetupInputComponent() override;\n\npublic:\n\n\t/** Get this player's index (0 or 1) from player state. Returns 0 if no CPPd1 player state. */\n\tUFUNCTION(BlueprintPure, Category = \"CPPd1\")\n\tint32 GetPlayerIndex() const;\n};\n","CPPd1PlayerState.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CPPd1PlayerState.h\"\n#include \"Net/UnrealNetwork.h\"\n\nACPPd1PlayerState::ACPPd1PlayerState()\n{\n\tSetReplicates(true);\n\tbReplicateUsingRegisteredSubObjectList = false;\n}\n\nvoid ACPPd1PlayerState::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\tDOREPLIFETIME(ACPPd1PlayerState, PlayerIndex);\n\tDOREPLIFETIME(ACPPd1PlayerState, Honor);\n}\n\nvoid ACPPd1PlayerState::SetPlayerIndex(int32 Index)\n{\n\tPlayerIndex = FMath::Clamp(Index, 0, 1);\n}\n\nvoid ACPPd1PlayerState::AddHonor(int32 Delta)\n{\n\tHonor = FMath::Max(0, Honor + Delta);\n}\n\nvoid ACPPd1PlayerState::SetHonor(int32 NewHonor)\n{\n\tHonor = FMath::Max(0, NewHonor);\n}\n","CPPd1PlayerState.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/PlayerState.h\"\n#include \"CPPd1PlayerState.generated.h\"\n\n/**\n * Player state for CPPd1: player index (0 or 1) and score (honor).\n */\nUCLASS(abstract)\nclass ACPPd1PlayerState : public APlayerState\n{\n\tGENERATED_BODY()\n\npublic:\n\n\t/** Player index (0 or 1) for 2P. Set by game mode or controller. */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Replicated, Category = \"CPPd1\", meta = (ClampMin = 0, ClampMax = 1))\n\tint32 PlayerIndex = 0;\n\n\t/** Honor (score) for this player. */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Replicated, Category = \"CPPd1\", meta = (ClampMin = 0))\n\tint32 Honor = 0;\n\n\tACPPd1PlayerState();\n\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n\n\t/** Set player index (e.g. from game mode). */\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1\")\n\tvoid SetPlayerIndex(int32 Index);\n\n\t/** Get player index. */\n\tUFUNCTION(BlueprintPure, Category = \"CPPd1\")\n\tint32 GetPlayerIndex() const { return PlayerIndex; }\n\n\t/** Add to honor. */\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1\")\n\tvoid AddHonor(int32 Delta);\n\n\t/** Set honor. */\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1\")\n\tvoid SetHonor(int32 NewHonor);\n\n\t/** Get honor. */\n\tUFUNCTION(BlueprintPure, Category = \"CPPd1\")\n\tint32 GetHonor() const { return Honor; }\n};\n","CPPd1SplitScreenManager.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CPPd1SplitScreenManager.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"Engine/GameInstance.h\"\n#include \"Engine/Engine.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUCPPd1SplitScreenManager::UCPPd1SplitScreenManager()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UCPPd1SplitScreenManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Enable split-screen on begin play\n\tif (bForceSplitScreenForSolo)\n\t{\n\t\tEnableSplitScreen();\n\t}\n}\n\nvoid UCPPd1SplitScreenManager::EnableSplitScreen()\n{\n\tif (bSplitScreenEnabled)\n\t{\n\t\treturn;\n\t}\n\n\tUWorld* World = GetWorld();\n\tif (!World || !World->GetGameInstance())\n\t{\n\t\treturn;\n\t}\n\n\t// Split screen is handled by GameMode's NumPlayers setting\n\t// This component just tracks the state\n\t// The actual split screen setup happens in GameMode\n\t\n\tbSplitScreenEnabled = true;\n}\n\nvoid UCPPd1SplitScreenManager::DisableSplitScreen()\n{\n\tbSplitScreenEnabled = false;\n}\n\nvoid UCPPd1SplitScreenManager::SetupSplitScreenForPlayers()\n{\n\tEnableSplitScreen();\n}\n","CPPd1SplitScreenManager.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"CPPd1.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CPPd1SplitScreenManager.generated.h\"\n\nclass APlayerController;\n\n/**\n * Manages vertical split-screen for 2 players (always on, even for solo play)\n */\nUCLASS(ClassGroup = (CPPd1), meta = (BlueprintSpawnableComponent))\nclass CPPd1_API UCPPd1SplitScreenManager : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUCPPd1SplitScreenManager();\n\n\tvirtual void BeginPlay() override;\n\n\t/** Enable split-screen mode (vertical split) */\n\tUFUNCTION(BlueprintCallable, Category = \"Split Screen\")\n\tvoid EnableSplitScreen();\n\n\t/** Disable split-screen mode (single viewport) */\n\tUFUNCTION(BlueprintCallable, Category = \"Split Screen\")\n\tvoid DisableSplitScreen();\n\n\t/** Setup split-screen for players */\n\tUFUNCTION(BlueprintCallable, Category = \"Split Screen\")\n\tvoid SetupSplitScreenForPlayers();\n\n\t/** Check if split-screen is enabled */\n\tUFUNCTION(BlueprintPure, Category = \"Split Screen\")\n\tbool IsSplitScreenEnabled() const { return bSplitScreenEnabled; }\n\nprotected:\n\t/** Whether split-screen is currently enabled */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Split Screen\")\n\tbool bSplitScreenEnabled = false;\n\n\t/** Force split-screen even with 1 player (for solo play) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Split Screen\")\n\tbool bForceSplitScreenForSolo = true;\n\n\t/** Split-screen layout type (Vertical = Left/Right, Horizontal = Top/Bottom) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Split Screen\")\n\tbool bUseVerticalSplit = true; // true = vertical (left/right), false = horizontal (top/bottom)\n};\n","Procedural/CPPd1ProceduralCube.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CPPd1ProceduralCube.h\"\n#include \"ProceduralMeshComponent.h\"\n#include \"Engine/Engine.h\"\n\nACPPd1ProceduralCube::ACPPd1ProceduralCube()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tProceduralMesh = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"ProceduralMesh\"));\n\tSetRootComponent(ProceduralMesh);\n}\n\nvoid ACPPd1ProceduralCube::OnConstruction(const FTransform& Transform)\n{\n\tSuper::OnConstruction(Transform);\n\tBuildCubeMesh();\n}\n\nvoid ACPPd1ProceduralCube::RebuildMesh()\n{\n\tBuildCubeMesh();\n}\n\nvoid ACPPd1ProceduralCube::BuildCubeMesh()\n{\n\tif (!ProceduralMesh) return;\n\n\tTArray<FVector> Vertices;\n\tTArray<int32> Triangles;\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UV0;\n\n\tconst float H = Size * 0.5f;\n\t// 8 corners of a cube (centered at origin)\n\tFVector V[8] = {\n\t\tFVector(-H, -H, -H), FVector( H, -H, -H), FVector( H,  H, -H), FVector(-H,  H, -H), // bottom\n\t\tFVector(-H, -H,  H), FVector( H, -H,  H), FVector( H,  H,  H), FVector(-H,  H,  H)  // top\n\t};\n\n\t// 6 faces: front, back, left, right, top, bottom (outward normals)\n\tauto AddQuad = [&](int32 A, int32 B, int32 C, int32 D, const FVector& N) {\n\t\tint32 Base = Vertices.Num();\n\t\tVertices.Add(V[A]); Vertices.Add(V[B]); Vertices.Add(V[C]); Vertices.Add(V[D]);\n\t\tNormals.Add(N); Normals.Add(N); Normals.Add(N); Normals.Add(N);\n\t\tUV0.Add(FVector2D(0,0)); UV0.Add(FVector2D(1,0)); UV0.Add(FVector2D(1,1)); UV0.Add(FVector2D(0,1));\n\t\tTriangles.Add(Base+0); Triangles.Add(Base+1); Triangles.Add(Base+2);\n\t\tTriangles.Add(Base+0); Triangles.Add(Base+2); Triangles.Add(Base+3);\n\t};\n\n\tAddQuad(4, 5, 6, 7, FVector( 0,  0,  1)); // front (Z+)\n\tAddQuad(1, 0, 3, 2, FVector( 0,  0, -1)); // back (Z-)\n\tAddQuad(0, 4, 7, 3, FVector(-1,  0,  0)); // left (X-)\n\tAddQuad(5, 1, 2, 6, FVector( 1,  0,  0)); // right (X+)\n\tAddQuad(7, 6, 2, 3, FVector( 0,  1,  0)); // top (Y+)\n\tAddQuad(0, 1, 5, 4, FVector( 0, -1,  0)); // bottom (Y-)\n\n\tProceduralMesh->ClearAllMeshSections();\n\tProceduralMesh->CreateMeshSection(0, Vertices, Triangles, Normals, UV0, TArray<FColor>(), TArray<FProcMeshTangent>(), true);\n\tProceduralMesh->SetMaterial(0, nullptr); // use default material or set in editor\n}\n","Procedural/CPPd1ProceduralCube.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CPPd1ProceduralCube.generated.h\"\n\nclass UProceduralMeshComponent;\n\n/**\n * Actor that builds a 3D cube from code at runtime (or in editor).\n * Place in level to see a procedural mesh; edit Size to rescale.\n */\nUCLASS(BlueprintType, Blueprintable)\nclass CPPd1_API ACPPd1ProceduralCube : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACPPd1ProceduralCube();\n\n\t/** Cube edge length (default 100). */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Procedural\", meta = (ClampMin = \"1.0\"))\n\tfloat Size = 100.f;\n\n\t/** Rebuild the procedural mesh (e.g. after changing Size). */\n\tUFUNCTION(BlueprintCallable, CallInEditor, Category = \"Procedural\")\n\tvoid RebuildMesh();\n\nprotected:\n\tvirtual void OnConstruction(const FTransform& Transform) override;\n\n\tUPROPERTY(VisibleAnywhere, Category = \"Procedural\")\n\tTObjectPtr<UProceduralMeshComponent> ProceduralMesh;\n\n\tvoid BuildCubeMesh();\n};\n","Procedural/CubeNinjaBodyComponent.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CubeNinjaBodyComponent.h\"\n#include \"ProceduralMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"GameFramework/Character.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n\nnamespace\n{\n\tenum EPart\n\t{\n\t\tPelvis, Spine, Chest, Head,\n\t\tL_Shoulder, L_UpperArm, L_Elbow, L_LowerArm, L_Hand,\n\t\tR_Shoulder, R_UpperArm, R_Elbow, R_LowerArm, R_Hand,\n\t\tL_UpperLeg, L_Knee, L_LowerLeg, L_Foot,\n\t\tR_UpperLeg, R_Knee, R_LowerLeg, R_Foot,\n\t\tNumParts\n\t};\n\t// Indices that get swing animation\n\tconst int32 L_UA = 5, R_UA = 10, L_UL = 14, R_UL = 18;\n}\n\nUCubeNinjaBodyComponent::UCubeNinjaBodyComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tPartIsSphere.SetNum(NumParts);\n\tPartHalfExtents.SetNum(NumParts);\n\tPartRadii.SetNum(NumParts);\n\tPartLocations.SetNum(NumParts);\n\tPartDefaultRotations.SetNum(NumParts);\n\tfor (int32 i = 0; i < NumParts; ++i)\n\t{\n\t\tPartIsSphere[i] = false;\n\t\tPartRadii[i] = 0.f;\n\t\tPartDefaultRotations[i] = FRotator::ZeroRotator;\n\t}\n\n\t// ---- Spheres: head, pelvis, shoulders, elbows, hands, knees, feet ----\n\tPartIsSphere[Pelvis] = PartIsSphere[Head] = true;\n\tPartIsSphere[L_Shoulder] = PartIsSphere[R_Shoulder] = true;\n\tPartIsSphere[L_Elbow] = PartIsSphere[R_Elbow] = true;\n\tPartIsSphere[L_Hand] = PartIsSphere[R_Hand] = true;\n\tPartIsSphere[L_Knee] = PartIsSphere[R_Knee] = true;\n\tPartIsSphere[L_Foot] = PartIsSphere[R_Foot] = true;\n\n\tPartRadii[Pelvis] = 14.f;\n\tPartRadii[Head] = 11.f;\n\tPartRadii[L_Shoulder] = PartRadii[R_Shoulder] = 6.f;\n\tPartRadii[L_Elbow] = PartRadii[R_Elbow] = 4.f;\n\tPartRadii[L_Hand] = PartRadii[R_Hand] = 3.5f;\n\tPartRadii[L_Knee] = PartRadii[R_Knee] = 5.f;\n\tPartRadii[L_Foot] = PartRadii[R_Foot] = 4.f;\n\n\t// ---- Tiny cubes: spine, chest, upper/lower arms, upper/lower legs ----\n\tPartHalfExtents[Spine]  = FVector(6.f, 5.f, 8.f);\n\tPartHalfExtents[Chest]  = FVector(8.f, 6.f, 7.f);\n\tPartHalfExtents[L_UpperArm] = PartHalfExtents[R_UpperArm] = FVector(2.5f, 2.5f, 10.f);\n\tPartHalfExtents[L_LowerArm] = PartHalfExtents[R_LowerArm] = FVector(2.f, 2.f, 9.f);\n\tPartHalfExtents[L_UpperLeg] = PartHalfExtents[R_UpperLeg] = FVector(3.f, 3.f, 11.f);\n\tPartHalfExtents[L_LowerLeg] = PartHalfExtents[R_LowerLeg] = FVector(2.5f, 2.5f, 10.f);\n\t// Unused for sphere parts but keep valid\n\tPartHalfExtents[Pelvis] = PartHalfExtents[Head] = FVector(1.f, 1.f, 1.f);\n\tPartHalfExtents[L_Shoulder] = PartHalfExtents[R_Shoulder] = FVector(1.f, 1.f, 1.f);\n\tPartHalfExtents[L_Elbow] = PartHalfExtents[R_Elbow] = PartHalfExtents[L_Hand] = PartHalfExtents[R_Hand] = FVector(1.f, 1.f, 1.f);\n\tPartHalfExtents[L_Knee] = PartHalfExtents[R_Knee] = PartHalfExtents[L_Foot] = PartHalfExtents[R_Foot] = FVector(1.f, 1.f, 1.f);\n\n\t// Locations relative to parent (pelvis bottom at origin for root child)\n\tfloat Pr = PartRadii[Pelvis];\n\tPartLocations[Pelvis] = FVector(0.f, 0.f, Pr);\n\n\tfloat Sz = PartHalfExtents[Spine].Z, Cz = PartHalfExtents[Chest].Z, Hr = PartRadii[Head];\n\tPartLocations[Spine] = FVector(0.f, 0.f, Pr + Sz);\n\tPartLocations[Chest] = FVector(0.f, 0.f, PartHalfExtents[Spine].Z + Cz);\n\tPartLocations[Head] = FVector(0.f, 0.f, Cz + Hr);\n\n\tfloat Cx = PartHalfExtents[Chest].X, Sr = PartRadii[L_Shoulder];\n\tPartLocations[L_Shoulder] = FVector(-(Cx + Sr), 1.f, 0.f);\n\tPartLocations[R_Shoulder] = FVector(Cx + Sr, 1.f, 0.f);\n\n\tfloat Uz = PartHalfExtents[L_UpperArm].Z, Er = PartRadii[L_Elbow], Lz = PartHalfExtents[L_LowerArm].Z, Hr2 = PartRadii[L_Hand];\n\tPartLocations[L_UpperArm] = FVector(0.f, 0.f, -Uz - Er);\n\tPartLocations[L_Elbow] = FVector(0.f, 0.f, -Er - Lz);\n\tPartLocations[L_LowerArm] = FVector(0.f, 0.f, -Lz - Hr2);\n\tPartLocations[L_Hand] = FVector(0.f, 0.f, 0.f);\n\tPartLocations[R_UpperArm] = FVector(0.f, 0.f, -Uz - Er);\n\tPartLocations[R_Elbow] = FVector(0.f, 0.f, -Er - Lz);\n\tPartLocations[R_LowerArm] = FVector(0.f, 0.f, -Lz - Hr2);\n\tPartLocations[R_Hand] = FVector(0.f, 0.f, 0.f);\n\n\tPartDefaultRotations[L_UpperArm] = FRotator(0.f, 0.f, 12.f);\n\tPartDefaultRotations[R_UpperArm] = FRotator(0.f, 0.f, -12.f);\n\n\tfloat HipX = PartRadii[Pelvis] * 0.7f, LUz = PartHalfExtents[L_UpperLeg].Z, Kr = PartRadii[L_Knee], LLz = PartHalfExtents[L_LowerLeg].Z, Fr = PartRadii[L_Foot];\n\tPartLocations[L_UpperLeg] = FVector(-HipX, 0.f, -PartRadii[Pelvis] - LUz);\n\tPartLocations[L_Knee] = FVector(0.f, 0.f, -LUz - Kr);\n\tPartLocations[L_LowerLeg] = FVector(0.f, 0.f, -Kr - LLz);\n\tPartLocations[L_Foot] = FVector(0.f, 0.f, -LLz - Fr);\n\tPartLocations[R_UpperLeg] = FVector(HipX, 0.f, -PartRadii[Pelvis] - LUz);\n\tPartLocations[R_Knee] = FVector(0.f, 0.f, -LUz - Kr);\n\tPartLocations[R_LowerLeg] = FVector(0.f, 0.f, -Kr - LLz);\n\tPartLocations[R_Foot] = FVector(0.f, 0.f, -LLz - Fr);\n\n\tSwingPartIndices = { L_UA, R_UA, L_UL, R_UL };\n\n\tconst TCHAR* PivotNames[NumParts] = {\n\t\tTEXT(\"CN_Pelvis\"), TEXT(\"CN_Spine\"), TEXT(\"CN_Chest\"), TEXT(\"CN_Head\"),\n\t\tTEXT(\"CN_LSh\"), TEXT(\"CN_LUA\"), TEXT(\"CN_LElbow\"), TEXT(\"CN_LLA\"), TEXT(\"CN_LHand\"),\n\t\tTEXT(\"CN_RSh\"), TEXT(\"CN_RUA\"), TEXT(\"CN_RElbow\"), TEXT(\"CN_RLA\"), TEXT(\"CN_RHand\"),\n\t\tTEXT(\"CN_LUL\"), TEXT(\"CN_LKnee\"), TEXT(\"CN_LLL\"), TEXT(\"CN_LFoot\"),\n\t\tTEXT(\"CN_RUL\"), TEXT(\"CN_RKnee\"), TEXT(\"CN_RLL\"), TEXT(\"CN_RFoot\")\n\t};\n\tconst TCHAR* MeshNames[NumParts] = {\n\t\tTEXT(\"CN_PelvisM\"), TEXT(\"CN_SpineM\"), TEXT(\"CN_ChestM\"), TEXT(\"CN_HeadM\"),\n\t\tTEXT(\"CN_LShM\"), TEXT(\"CN_LUAM\"), TEXT(\"CN_LElbowM\"), TEXT(\"CN_LLAM\"), TEXT(\"CN_LHandM\"),\n\t\tTEXT(\"CN_RShM\"), TEXT(\"CN_RUAM\"), TEXT(\"CN_RElbowM\"), TEXT(\"CN_RLAM\"), TEXT(\"CN_RHandM\"),\n\t\tTEXT(\"CN_LULM\"), TEXT(\"CN_LKneeM\"), TEXT(\"CN_LLLM\"), TEXT(\"CN_LFootM\"),\n\t\tTEXT(\"CN_RULM\"), TEXT(\"CN_RKneeM\"), TEXT(\"CN_RLLM\"), TEXT(\"CN_RFootM\")\n\t};\n\n\tPartPivots.Reserve(NumParts);\n\tPartMeshes.Reserve(NumParts);\n\tfor (int32 i = 0; i < NumParts; ++i)\n\t{\n\t\tUSceneComponent* Pivot = CreateDefaultSubobject<USceneComponent>(PivotNames[i]);\n\t\tUProceduralMeshComponent* Mesh = CreateDefaultSubobject<UProceduralMeshComponent>(MeshNames[i]);\n\t\tMesh->SetupAttachment(Pivot);\n\t\tMesh->SetRelativeLocation(FVector::ZeroVector);\n\t\tMesh->SetRelativeRotation(FRotator::ZeroRotator);\n\t\tPartPivots.Add(Pivot);\n\t\tPartMeshes.Add(Mesh);\n\t}\n\n\tauto Attach = [](USceneComponent* Child, USceneComponent* Parent, const FVector& Loc, const FRotator& Rot) {\n\t\tChild->SetupAttachment(Parent);\n\t\tChild->SetRelativeLocation(Loc);\n\t\tChild->SetRelativeRotation(Rot);\n\t};\n\n\tAttach(PartPivots[Pelvis], this, PartLocations[Pelvis], PartDefaultRotations[Pelvis]);\n\tAttach(PartPivots[Spine], PartPivots[Pelvis], PartLocations[Spine], PartDefaultRotations[Spine]);\n\tAttach(PartPivots[Chest], PartPivots[Spine], PartLocations[Chest], PartDefaultRotations[Chest]);\n\tAttach(PartPivots[Head], PartPivots[Chest], PartLocations[Head], PartDefaultRotations[Head]);\n\tAttach(PartPivots[L_Shoulder], PartPivots[Chest], PartLocations[L_Shoulder], PartDefaultRotations[L_Shoulder]);\n\tAttach(PartPivots[L_UpperArm], PartPivots[L_Shoulder], PartLocations[L_UpperArm], PartDefaultRotations[L_UpperArm]);\n\tAttach(PartPivots[L_Elbow], PartPivots[L_UpperArm], PartLocations[L_Elbow], PartDefaultRotations[L_Elbow]);\n\tAttach(PartPivots[L_LowerArm], PartPivots[L_Elbow], PartLocations[L_LowerArm], PartDefaultRotations[L_LowerArm]);\n\tAttach(PartPivots[L_Hand], PartPivots[L_LowerArm], PartLocations[L_Hand], PartDefaultRotations[L_Hand]);\n\tAttach(PartPivots[R_Shoulder], PartPivots[Chest], PartLocations[R_Shoulder], PartDefaultRotations[R_Shoulder]);\n\tAttach(PartPivots[R_UpperArm], PartPivots[R_Shoulder], PartLocations[R_UpperArm], PartDefaultRotations[R_UpperArm]);\n\tAttach(PartPivots[R_Elbow], PartPivots[R_UpperArm], PartLocations[R_Elbow], PartDefaultRotations[R_Elbow]);\n\tAttach(PartPivots[R_LowerArm], PartPivots[R_Elbow], PartLocations[R_LowerArm], PartDefaultRotations[R_LowerArm]);\n\tAttach(PartPivots[R_Hand], PartPivots[R_LowerArm], PartLocations[R_Hand], PartDefaultRotations[R_Hand]);\n\tAttach(PartPivots[L_UpperLeg], PartPivots[Pelvis], PartLocations[L_UpperLeg], PartDefaultRotations[L_UpperLeg]);\n\tAttach(PartPivots[L_Knee], PartPivots[L_UpperLeg], PartLocations[L_Knee], PartDefaultRotations[L_Knee]);\n\tAttach(PartPivots[L_LowerLeg], PartPivots[L_Knee], PartLocations[L_LowerLeg], PartDefaultRotations[L_LowerLeg]);\n\tAttach(PartPivots[L_Foot], PartPivots[L_LowerLeg], PartLocations[L_Foot], PartDefaultRotations[L_Foot]);\n\tAttach(PartPivots[R_UpperLeg], PartPivots[Pelvis], PartLocations[R_UpperLeg], PartDefaultRotations[R_UpperLeg]);\n\tAttach(PartPivots[R_Knee], PartPivots[R_UpperLeg], PartLocations[R_Knee], PartDefaultRotations[R_Knee]);\n\tAttach(PartPivots[R_LowerLeg], PartPivots[R_Knee], PartLocations[R_LowerLeg], PartDefaultRotations[R_LowerLeg]);\n\tAttach(PartPivots[R_Foot], PartPivots[R_LowerLeg], PartLocations[R_Foot], PartDefaultRotations[R_Foot]);\n}\n\nvoid UCubeNinjaBodyComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tRebuildBody();\n}\n\nvoid UCubeNinjaBodyComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tUpdateLimbSwing(DeltaTime);\n}\n\nvoid UCubeNinjaBodyComponent::RebuildBody()\n{\n\tconst float S = BodyScale;\n\tfor (int32 i = 0; i < PartMeshes.Num(); ++i)\n\t{\n\t\tif (!PartMeshes[i]) continue;\n\t\tif (PartIsSphere[i])\n\t\t\tBuildSphereInMesh(PartMeshes[i], PartRadii[i] * S);\n\t\telse\n\t\t\tBuildCubeInMesh(PartMeshes[i], PartHalfExtents[i] * S);\n\t}\n\tfor (int32 i = 0; i < PartPivots.Num(); ++i)\n\t\tif (PartPivots[i])\n\t\t\tPartPivots[i]->SetRelativeLocation(PartLocations[i] * S);\n}\n\nvoid UCubeNinjaBodyComponent::BuildCubeInMesh(UProceduralMeshComponent* Mesh, const FVector& HalfExtents)\n{\n\tif (!Mesh) return;\n\tconst float Hx = HalfExtents.X, Hy = HalfExtents.Y, Hz = HalfExtents.Z;\n\tFVector V[8] = {\n\t\tFVector(-Hx, -Hy, -Hz), FVector(Hx, -Hy, -Hz), FVector(Hx, Hy, -Hz), FVector(-Hx, Hy, -Hz),\n\t\tFVector(-Hx, -Hy, Hz),  FVector(Hx, -Hy, Hz),  FVector(Hx, Hy, Hz),  FVector(-Hx, Hy, Hz)\n\t};\n\tTArray<FVector> Vertices, Normals;\n\tTArray<int32> Triangles;\n\tTArray<FVector2D> UV0;\n\tauto AddQuad = [&](int32 A, int32 B, int32 C, int32 D, const FVector& N) {\n\t\tint32 Base = Vertices.Num();\n\t\tVertices.Add(V[A]); Vertices.Add(V[B]); Vertices.Add(V[C]); Vertices.Add(V[D]);\n\t\tNormals.Add(N); Normals.Add(N); Normals.Add(N); Normals.Add(N);\n\t\tUV0.Add(FVector2D(0,0)); UV0.Add(FVector2D(1,0)); UV0.Add(FVector2D(1,1)); UV0.Add(FVector2D(0,1));\n\t\tTriangles.Add(Base+0); Triangles.Add(Base+1); Triangles.Add(Base+2);\n\t\tTriangles.Add(Base+0); Triangles.Add(Base+2); Triangles.Add(Base+3);\n\t};\n\tAddQuad(4, 5, 6, 7, FVector(0, 0, 1));\n\tAddQuad(1, 0, 3, 2, FVector(0, 0, -1));\n\tAddQuad(0, 4, 7, 3, FVector(-1, 0, 0));\n\tAddQuad(5, 1, 2, 6, FVector(1, 0, 0));\n\tAddQuad(7, 6, 2, 3, FVector(0, 1, 0));\n\tAddQuad(0, 1, 5, 4, FVector(0, -1, 0));\n\tMesh->ClearAllMeshSections();\n\tMesh->CreateMeshSection(0, Vertices, Triangles, Normals, UV0, TArray<FColor>(), TArray<FProcMeshTangent>(), true);\n\tMesh->SetMaterial(0, CubeMaterial);\n}\n\nvoid UCubeNinjaBodyComponent::BuildSphereInMesh(UProceduralMeshComponent* Mesh, float Radius, int32 Segments)\n{\n\tif (!Mesh || Radius <= 0.f) return;\n\tTArray<FVector> Vertices, Normals;\n\tTArray<int32> Triangles;\n\tTArray<FVector2D> UV0;\n\tconst int32 RingCount = FMath::Max(2, Segments);\n\tconst int32 SectCount = FMath::Max(3, Segments * 2);\n\tfor (int32 Ring = 0; Ring <= RingCount; ++Ring)\n\t{\n\t\tconst float Phi = PI * (float)Ring / (float)RingCount;\n\t\tconst float Y = -FMath::Cos(Phi);\n\t\tconst float RingR = FMath::Sin(Phi);\n\t\tfor (int32 Sect = 0; Sect <= SectCount; ++Sect)\n\t\t{\n\t\t\tconst float Theta = 2.f * PI * (float)Sect / (float)SectCount;\n\t\t\tconst float X = RingR * FMath::Cos(Theta);\n\t\t\tconst float Z = RingR * FMath::Sin(Theta);\n\t\t\tFVector N(X, Z, Y);\n\t\t\tN.Normalize();\n\t\t\tVertices.Add(N * Radius);\n\t\t\tNormals.Add(N);\n\t\t\tUV0.Add(FVector2D((float)Sect / (float)SectCount, (float)Ring / (float)RingCount));\n\t\t}\n\t}\n\tfor (int32 Ring = 0; Ring < RingCount; ++Ring)\n\t\tfor (int32 Sect = 0; Sect < SectCount; ++Sect)\n\t\t{\n\t\t\tconst int32 A = Ring * (SectCount + 1) + Sect;\n\t\t\tconst int32 B = A + 1;\n\t\t\tconst int32 C = A + (SectCount + 1);\n\t\t\tconst int32 D = C + 1;\n\t\t\tTriangles.Add(A); Triangles.Add(C); Triangles.Add(B);\n\t\t\tTriangles.Add(B); Triangles.Add(C); Triangles.Add(D);\n\t\t}\n\tMesh->ClearAllMeshSections();\n\tMesh->CreateMeshSection(0, Vertices, Triangles, Normals, UV0, TArray<FColor>(), TArray<FProcMeshTangent>(), true);\n\tMesh->SetMaterial(0, CubeMaterial);\n}\n\nvoid UCubeNinjaBodyComponent::UpdateLimbSwing(float DeltaTime)\n{\n\tACharacter* Char = Cast<ACharacter>(GetOwner());\n\tconst float Speed = Char && Char->GetCharacterMovement() ? Char->GetVelocity().Size2D() : 0.f;\n\tconst bool bMoving = Speed > 10.f;\n\tif (bMoving)\n\t\tWalkCycleTime += DeltaTime * LimbSwingSpeed * 2.f * PI;\n\telse\n\t\tWalkCycleTime = FMath::FInterpTo(WalkCycleTime, 0.f, DeltaTime, 5.f);\n\tconst float Swing = FMath::Sin(WalkCycleTime) * LimbSwingAmount;\n\tconst float SwingLeg = FMath::Sin(WalkCycleTime + PI) * LimbSwingAmount;\n\n\tfor (int32 Idx : SwingPartIndices)\n\t{\n\t\tif (PartPivots.IsValidIndex(Idx) && PartPivots[Idx])\n\t\t{\n\t\t\tFRotator R = PartDefaultRotations[Idx];\n\t\t\tif (Idx == L_UA || Idx == R_UA)\n\t\t\t\tR += FRotator(Idx == L_UA ? Swing : -Swing, 0.f, 0.f);\n\t\t\telse\n\t\t\t\tR += FRotator(Idx == L_UL ? SwingLeg : -SwingLeg, 0.f, 0.f);\n\t\t\tPartPivots[Idx]->SetRelativeRotation(R);\n\t\t}\n\t}\n}\n","Procedural/CubeNinjaBodyComponent.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/SceneComponent.h\"\n#include \"CubeNinjaBodyComponent.generated.h\"\n\nclass UProceduralMeshComponent;\nclass UMaterialInterface;\n\n/**\n * A ninja \"model\" made of interlocking procedural shapes: spheres for head, pelvis, and joints\n * (shoulders, elbows, hands, knees, feet); tiny cubes for spine, chest, and limb segments.\n * Add to a Character; limb segments are driven by simple procedural motion (walk swing).\n */\nUCLASS(ClassGroup = (Procedural), meta = (BlueprintSpawnableComponent))\nclass CPPd1_API UCubeNinjaBodyComponent : public USceneComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUCubeNinjaBodyComponent();\n\n\t/** Overall scale of the cube body (1 = ~180 cm tall blocky ninja). */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Cube Ninja\", meta = (ClampMin = 0.1f, ClampMax = 3.0f))\n\tfloat BodyScale = 1.0f;\n\n\t/** Intensity of arm/leg swing when moving (0 = no swing). */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Cube Ninja|Motion\", meta = (ClampMin = 0.0f, ClampMax = 60.0f, Units = \"deg\"))\n\tfloat LimbSwingAmount = 25.0f;\n\n\t/** Speed of walk-cycle swing. */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Cube Ninja|Motion\", meta = (ClampMin = 0.1f, Units = \"Hz\"))\n\tfloat LimbSwingSpeed = 2.0f;\n\n\t/** Optional material applied to all cube segments (if null, uses default which may appear black). */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Cube Ninja\")\n\tTObjectPtr<UMaterialInterface> CubeMaterial;\n\n\tvirtual void BeginPlay() override;\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\t/** Rebuild all cube meshes (e.g. after changing BodyScale). */\n\tUFUNCTION(BlueprintCallable, Category = \"Cube Ninja\")\n\tvoid RebuildBody();\n\nprotected:\n\tUPROPERTY()\n\tTArray<TObjectPtr<USceneComponent>> PartPivots;\n\tUPROPERTY()\n\tTArray<TObjectPtr<UProceduralMeshComponent>> PartMeshes;\n\n\t/** true = sphere (use PartRadii), false = cube (use PartHalfExtents). */\n\tTArray<bool> PartIsSphere;\n\tTArray<FVector> PartHalfExtents;\n\tTArray<float> PartRadii;\n\tTArray<FVector> PartLocations;\n\tTArray<FRotator> PartDefaultRotations;\n\t/** Indices of parts that get limb swing (L_UpperArm, R_UpperArm, L_UpperLeg, R_UpperLeg). */\n\tTArray<int32> SwingPartIndices;\n\n\tfloat WalkCycleTime = 0.0f;\n\n\tvoid BuildCubeInMesh(UProceduralMeshComponent* Mesh, const FVector& HalfExtents);\n\tvoid BuildSphereInMesh(UProceduralMeshComponent* Mesh, float Radius, int32 Segments = 12);\n\tvoid UpdateLimbSwing(float DeltaTime);\n};\n","Variant_Combat/AI/BruteMarauder.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"BruteMarauder.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n\nABruteMarauder::ABruteMarauder()\n{\n\tMaxHP = 6.0f;\n\tCurrentHP = MaxHP;\n\tMeleeDamage = 1.4f;\n\tMeleeKnockbackImpulse = 280.0f;\n\tMeleeLaunchImpulse = 200.0f;\n\t// Slow, wants to wrestle\n\tif (UCharacterMovementComponent* Move = GetCharacterMovement())\n\t\tMove->MaxWalkSpeed = 280.0f;\n}\n","Variant_Combat/AI/BruteMarauder.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Variant_Combat/AI/CombatEnemy.h\"\n#include \"BruteMarauder.generated.h\"\n\n/**\n * Marauder type: brutes. Big, tough, no weapons—they want to wrestle and ask you to put the weapons down.\n * You can still use the sword, but fighting them unarmed is more enjoyable. Tuned: high HP, slower, heavy hits.\n */\nUCLASS(BlueprintType, Blueprintable)\nclass CPPd1_API ABruteMarauder : public ACombatEnemy\n{\n\tGENERATED_BODY()\n\npublic:\n\tABruteMarauder();\n\n\t/** When true, brute is in \"wrestle\" mode (for UI/audio: \"put weapons down\"). Still damageable by sword. */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Brute\")\n\tbool bPrefersUnarmed = true;\n};\n","Variant_Combat/AI/CombatAIController.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatAIController.h\"\n#include \"Components/StateTreeAIComponent.h\"\n\nACombatAIController::ACombatAIController()\n{\n\t// create the StateTree AI Component\n\tStateTreeAI = CreateDefaultSubobject<UStateTreeAIComponent>(TEXT(\"StateTreeAI\"));\n\tcheck(StateTreeAI);\n\n\t// ensure we start the StateTree when we possess the pawn\n\tbStartAILogicOnPossess = true;\n\n\t// ensure we're attached to the possessed character.\n\t// this is necessary for EnvQueries to work correctly\n\tbAttachToPawn = true;\n}\n","Variant_Combat/AI/CombatAIController.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"CombatAIController.generated.h\"\n\nclass UStateTreeAIComponent;\n\n/**\n *\tA basic AI Controller capable of running StateTree\n */\nUCLASS(abstract)\nclass ACombatAIController : public AAIController\n{\n\tGENERATED_BODY()\n\n\t/** StateTree Component */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUStateTreeAIComponent* StateTreeAI;\n\npublic:\n\n\t/** Constructor */\n\tACombatAIController();\n};\n","Variant_Combat/AI/CombatEnemy.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatEnemy.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"CombatAIController.h\"\n#include \"Components/WidgetComponent.h\"\n#include \"Engine/DamageEvents.h\"\n#include \"CombatLifeBar.h\"\n#include \"TimerManager.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"CPPd1LockOnTargetComponent.h\"\n\nACombatEnemy::ACombatEnemy()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// bind the attack montage ended delegate\n\tOnAttackMontageEnded.BindUObject(this, &ACombatEnemy::AttackMontageEnded);\n\n\t// set the AI Controller class by default\n\tAIControllerClass = ACombatAIController::StaticClass();\n\n\t// use an AI Controller regardless of whether we're placed or spawned\n\tAutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned;\n\n\t// ignore the controller's yaw rotation\n\tbUseControllerRotationYaw = false;\n\n\t// create the life bar\n\tLifeBar = CreateDefaultSubobject<UWidgetComponent>(TEXT(\"LifeBar\"));\n\tLifeBar->SetupAttachment(RootComponent);\n\n\t// create the lock-on target component\n\tLockOnTargetComponent = CreateDefaultSubobject<UCPPd1LockOnTargetComponent>(TEXT(\"LockOnTargetComponent\"));\n\n\t// set the collision capsule size\n\tGetCapsuleComponent()->SetCapsuleSize(35.0f, 90.0f);\n\n\t// set the character movement properties\n\tGetCharacterMovement()->bUseControllerDesiredRotation = true;\n\n\t// reset HP to maximum\n\tCurrentHP = MaxHP;\n}\n\nvoid ACombatEnemy::DoAIComboAttack()\n{\n\t// ignore if we're already playing an attack animation\n\tif (bIsAttacking)\n\t{\n\t\treturn;\n\t}\n\n\t// raise the attacking flag\n\tbIsAttacking = true;\n\n\t// choose how many times we're going to attack\n\tTargetComboCount = FMath::RandRange(1, ComboSectionNames.Num() - 1);\n\n\t// reset the attack counter\n\tCurrentComboAttack = 0;\n\n\t// play the attack montage\n\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t{\n\t\tconst float MontageLength = AnimInstance->Montage_Play(ComboAttackMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);\n\n\t\t// subscribe to montage completed and interrupted events\n\t\tif (MontageLength > 0.0f)\n\t\t{\n\t\t\t// set the end delegate for the montage\n\t\t\tAnimInstance->Montage_SetEndDelegate(OnAttackMontageEnded, ComboAttackMontage);\n\t\t}\n\t}\n}\n\nvoid ACombatEnemy::DoAIChargedAttack()\n{\n\t// ignore if we're already playing an attack animation\n\tif (bIsAttacking)\n\t{\n\t\treturn;\n\t}\n\n\t// raise the attacking flag\n\tbIsAttacking = true;\n\n\t// choose how many loops are we going to charge for\n\tTargetChargeLoops = FMath::RandRange(MinChargeLoops, MaxChargeLoops);\n\n\t// reset the charge loop counter\n\tCurrentChargeLoop = 0;\n\n\t// play the attack montage\n\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t{\n\t\tconst float MontageLength = AnimInstance->Montage_Play(ChargedAttackMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);\n\n\t\t// subscribe to montage completed and interrupted events\n\t\tif (MontageLength > 0.0f)\n\t\t{\n\t\t\t// set the end delegate for the montage\n\t\t\tAnimInstance->Montage_SetEndDelegate(OnAttackMontageEnded, ChargedAttackMontage);\n\t\t}\n\t}\n}\n\nvoid ACombatEnemy::AttackMontageEnded(UAnimMontage* Montage, bool bInterrupted)\n{\n\t// reset the attacking flag\n\tbIsAttacking = false;\n\n\t// call the attack completed delegate so the StateTree can continue execution\n\tOnAttackCompleted.ExecuteIfBound();\n}\n\nvoid ACombatEnemy::DoAttackTrace(FName DamageSourceBone)\n{\n\t// sweep for objects in front of the character to be hit by the attack\n\tTArray<FHitResult> OutHits;\n\n\t// start at the provided socket location, sweep forward\n\tconst FVector TraceStart = GetMesh()->GetSocketLocation(DamageSourceBone);\n\tconst FVector TraceEnd = TraceStart + (GetActorForwardVector() * MeleeTraceDistance);\n\n\t// enemies only affect Pawn collision objects; they don't knock back boxes\n\tFCollisionObjectQueryParams ObjectParams;\n\tObjectParams.AddObjectTypesToQuery(ECC_Pawn);\n\n\t// use a sphere shape for the sweep\n\tFCollisionShape CollisionShape;\n\tCollisionShape.SetSphere(MeleeTraceRadius);\n\n\t// ignore self\n\tFCollisionQueryParams QueryParams;\n\tQueryParams.AddIgnoredActor(this);\n\n\tif (GetWorld()->SweepMultiByObjectType(OutHits, TraceStart, TraceEnd, FQuat::Identity, ObjectParams, CollisionShape, QueryParams))\n\t{\n\t\t// iterate over each object hit\n\t\tfor (const FHitResult& CurrentHit : OutHits)\n\t\t{\n\t\t\t/** does the actor have the player tag? */\n\t\t\tif (CurrentHit.GetActor()->ActorHasTag(FName(\"Player\")))\n\t\t\t{\n\t\t\t\t// check if the actor is damageable\n\t\t\t\tICombatDamageable* Damageable = Cast<ICombatDamageable>(CurrentHit.GetActor());\n\n\t\t\t\tif (Damageable)\n\t\t\t\t{\n\t\t\t\t\t// knock upwards and away from the impact normal\n\t\t\t\t\tconst FVector Impulse = (CurrentHit.ImpactNormal * -MeleeKnockbackImpulse) + (FVector::UpVector * MeleeLaunchImpulse);\n\t\t\t\t\tconst float ScaledDamage = MeleeDamage * FMath::Max(0.1f, WaveIntensityScale);\n\t\t\t\t\tDamageable->ApplyDamage(ScaledDamage, this, CurrentHit.ImpactPoint, Impulse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ACombatEnemy::CheckCombo()\n{\n\t// increase the combo counter\n\t++CurrentComboAttack;\n\n\t// do we still have attacks to play in this string?\n\tif (CurrentComboAttack < TargetComboCount)\n\t{\n\t\t// jump to the next attack section\n\t\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t\t{\n\t\t\tAnimInstance->Montage_JumpToSection(ComboSectionNames[CurrentComboAttack], ComboAttackMontage);\n\t\t}\n\t}\n}\n\nvoid ACombatEnemy::CheckChargedAttack()\n{\n\t// increase the charge loop counter\n\t++CurrentChargeLoop;\n\n\t// jump to either the loop or attack section of the montage depending on whether we hit the loop target\n\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t{\n\t\tAnimInstance->Montage_JumpToSection(CurrentChargeLoop >= TargetChargeLoops ? ChargeAttackSection : ChargeLoopSection, ChargedAttackMontage);\n\t}\n}\n\nvoid ACombatEnemy::ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse)\n{\n\t\n\t// pass the damage event to the actor\n\tFDamageEvent DamageEvent;\n\tconst float ActualDamage = TakeDamage(Damage, DamageEvent, nullptr, DamageCauser);\n\n\t// only process knockback and effects if we received nonzero damage\n\tif (ActualDamage > 0.0f)\n\t{\n\t\t// apply the knockback impulse\n\t\tGetCharacterMovement()->AddImpulse(DamageImpulse, true);\n\n\t\t// is the character ragdolling?\n\t\tif (GetMesh()->IsSimulatingPhysics())\n\t\t{\n\t\t\t// apply an impulse to the ragdoll\n\t\t\tGetMesh()->AddImpulseAtLocation(DamageImpulse * GetMesh()->GetMass(), DamageLocation);\n\t\t}\n\n\t\t// stop the attack montages to interrupt the attack\n\t\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t\t{\n\t\t\tAnimInstance->Montage_Stop(0.1f, ComboAttackMontage);\n\t\t\tAnimInstance->Montage_Stop(0.1f, ChargedAttackMontage);\n\t\t}\n\n\t\t// pass control to BP to play effects, etc.\n\t\tReceivedDamage(ActualDamage, DamageLocation, DamageImpulse.GetSafeNormal());\n\t}\n}\n\nvoid ACombatEnemy::HandleDeath()\n{\n\t// hide the life bar\n\tLifeBar->SetHiddenInGame(true);\n\n\t// disable the collision capsule to avoid being hit again while dead\n\tGetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\n\t// disable character movement\n\tGetCharacterMovement()->DisableMovement();\n\n\t// enable full ragdoll physics\n\tGetMesh()->SetSimulatePhysics(true);\n\n\tOnEnemyDied.Broadcast(this);\n\tOnEnemyKilledWithCauser.Broadcast(this, LastDamageCauser);\n\n\t// set up the death timer\n\tGetWorld()->GetTimerManager().SetTimer(DeathTimer, this, &ACombatEnemy::RemoveFromLevel, DeathRemovalTime);\n}\n\nvoid ACombatEnemy::ApplyHealing(float Healing, AActor* Healer)\n{\n\t// stub\n}\n\nvoid ACombatEnemy::RemoveFromLevel()\n{\n\t// destroy this actor\n\tDestroy();\n}\n\nfloat ACombatEnemy::TakeDamage(float Damage, struct FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser)\n{\n\tif (CurrentHP <= 0.0f) return 0.0f;\n\tLastDamageCauser = DamageCauser;\n\tconst float Scale = FMath::Max(0.1f, WaveIntensityScale);\n\tDamage = Damage / Scale;\n\tCurrentHP -= Damage;\n\n\t// have we run out of HP?\n\tif (CurrentHP <= 0.0f)\n\t{\n\t\t// die\n\t\tHandleDeath();\n\t}\n\telse\n\t{\n\t\t// update the life bar\n\t\tLifeBarWidget->SetLifePercentage(CurrentHP / MaxHP);\n\n\t\t// enable partial ragdoll physics, but keep the pelvis vertical\n\t\tGetMesh()->SetPhysicsBlendWeight(0.5f);\n\t\tGetMesh()->SetBodySimulatePhysics(PelvisBoneName, false);\n\t}\n\n\t// return the received damage amount\n\treturn Damage;\n}\n\nvoid ACombatEnemy::Landed(const FHitResult& Hit)\n{\n\tSuper::Landed(Hit);\n\n\t// is the character still alive?\n\tif (CurrentHP >= 0.0f)\n\t{\n\t\t// disable ragdoll physics\n\t\tGetMesh()->SetPhysicsBlendWeight(0.0f);\n\t}\n\n\t// call the landed Delegate for StateTree\n\tOnEnemyLanded.ExecuteIfBound();\n}\n\nvoid ACombatEnemy::BeginPlay()\n{\n\tCurrentHP = MaxHP;\n\tSuper::BeginPlay();\n\tLifeBarWidget = Cast<UCombatLifeBar>(LifeBar->GetUserWidgetObject());\n\tcheck(LifeBarWidget);\n\tLifeBarWidget->SetLifePercentage(1.0f);\n\t// Scale movement speed with intensity (harder waves = slightly faster enemies)\n\tif (WaveIntensityScale > 1.0f)\n\t{\n\t\tconst float SpeedScale = FMath::Sqrt(WaveIntensityScale);\n\t\tGetCharacterMovement()->MaxWalkSpeed *= FMath::Clamp(SpeedScale, 1.0f, 1.5f);\n\t}\n}\n\nvoid ACombatEnemy::EndPlay(EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\t// clear the death timer\n\tGetWorld()->GetTimerManager().ClearTimer(DeathTimer);\n}\n","Variant_Combat/AI/CombatEnemy.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"CombatAttacker.h\"\n#include \"CombatDamageable.h\"\n#include \"Animation/AnimMontage.h\"\n#include \"Engine/TimerHandle.h\"\n#include \"CombatEnemy.generated.h\"\n\nclass UWidgetComponent;\nclass UCombatLifeBar;\nclass UAnimMontage;\n\n/** Completed attack animation delegate for StateTree */\nDECLARE_DELEGATE(FOnEnemyAttackCompleted);\n\n/** Landed delegate for StateTree */\nDECLARE_DELEGATE(FOnEnemyLanded);\n\n/** Enemy died delegate */\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnEnemyDied, ACombatEnemy*, DeadEnemy);\n\n/**\n *  An AI-controlled character with combat capabilities.\n *  Its bundled AI Controller runs logic through StateTree\n */\nUCLASS(abstract)\nclass ACombatEnemy : public ACharacter, public ICombatAttacker, public ICombatDamageable\n{\n\tGENERATED_BODY()\n\n\t/** Life bar widget component */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUWidgetComponent* LifeBar;\n\n\t/** Lock-on target component - makes this enemy a valid lock-on target */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tclass UCPPd1LockOnTargetComponent* LockOnTargetComponent;\n\npublic:\n\t\n\t/** Constructor */\n\tACombatEnemy();\n\n\t/** Wave intensity (set by spawner). >1 = deal more damage, take less (harder). <1 = easier. */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Wave\", meta = (ClampMin = 0.1f, ClampMax = 5.0f))\n\tfloat WaveIntensityScale = 1.0f;\n\nprotected:\n\n\t/** Max amount of HP the character will have on respawn */\n\tUPROPERTY(EditAnywhere, Category=\"Damage\")\n\tfloat MaxHP = 3.0f;\n\npublic:\n\n\t/** Current amount of HP the character has */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Damage\", meta = (ClampMin = 0, ClampMax = 100))\n\tfloat CurrentHP = 0.0f;\n\nprotected:\n\n\t/** Name of the pelvis bone, for damage ragdoll physics */\n\tUPROPERTY(EditAnywhere, Category=\"Damage\")\n\tFName PelvisBoneName;\n\n\t/** Pointer to the life bar widget */\n\tUPROPERTY(EditAnywhere, Category=\"Damage\")\n\tUCombatLifeBar* LifeBarWidget;\n\n\t/** If true, the character is currently playing an attack animation */\n\tbool bIsAttacking = false;\n\n\t/** Distance ahead of the character that melee attack sphere collision traces will extend */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Trace\", meta = (ClampMin = 0, ClampMax = 500, Units = \"cm\"))\n\tfloat MeleeTraceDistance = 75.0f;\n\n\t/** Radius of the sphere trace for melee attacks */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Trace\", meta = (ClampMin = 0, ClampMax = 500, Units = \"cm\"))\n\tfloat MeleeTraceRadius = 50.0f;\n\n\t/** Amount of damage a melee attack will deal */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Damage\", meta = (ClampMin = 0, ClampMax = 100))\n\tfloat MeleeDamage = 1.0f;\n\n\t/** Amount of knockback impulse a melee attack will apply */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Damage\", meta = (ClampMin = 0, ClampMax = 1000, Units = \"cm/s\"))\n\tfloat MeleeKnockbackImpulse = 150.0f;\n\n\t/** Amount of upwards impulse a melee attack will apply */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Damage\", meta = (ClampMin = 0, ClampMax = 1000, Units = \"cm/s\"))\n\tfloat MeleeLaunchImpulse = 350.0f;\n\n\t/** AnimMontage that will play for combo attacks */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Combo\")\n\tUAnimMontage* ComboAttackMontage;\n\n\t/** Names of the AnimMontage sections that correspond to each stage of the combo attack */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Combo\")\n\tTArray<FName> ComboSectionNames;\n\n\t/** Target number of attacks in the combo attack string we're playing */\n\tint32 TargetComboCount = 0;\n\n\t/** Index of the current stage of the melee attack combo */\n\tint32 CurrentComboAttack = 0;\n\n\t/** AnimMontage that will play for charged attacks */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Charged\")\n\tUAnimMontage* ChargedAttackMontage;\n\n\t/** Name of the AnimMontage section that corresponds to the charge loop */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Charged\")\n\tFName ChargeLoopSection;\n\n\t/** Name of the AnimMontage section that corresponds to the attack */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Charged\")\n\tFName ChargeAttackSection;\n\n\t/** Minimum number of charge animation loops that will be played by the AI */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Charged\", meta = (ClampMin = 1, ClampMax = 20))\n\tint32 MinChargeLoops = 2;\n\n\t/** Maximum number of charge animation loops that will be played by the AI */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Charged\", meta = (ClampMin = 1, ClampMax = 20))\n\tint32 MaxChargeLoops = 5;\n\n\t/** Target number of charge animation loops to play in this charged attack */\n\tint32 TargetChargeLoops = 0;\n\n\t/** Number of charge animation loop currently playing */\n\tint32 CurrentChargeLoop = 0;\n\n\t/** Time to wait before removing this character from the level after it dies */\n\tUPROPERTY(EditAnywhere, Category=\"Death\")\n\tfloat DeathRemovalTime = 5.0f;\n\n\t/** Last actor that dealt damage (for style scoring on death). */\n\tUPROPERTY()\n\tTObjectPtr<AActor> LastDamageCauser;\n\n\t/** Enemy death timer */\n\tFTimerHandle DeathTimer;\n\n\t/** Attack montage ended delegate */\n\tFOnMontageEnded OnAttackMontageEnded;\n\npublic:\n\t/** Attack completed internal delegate to notify StateTree tasks */\n\tFOnEnemyAttackCompleted OnAttackCompleted;\n\n\t/** Landed internal delegate to notify StateTree tasks. We use this instead of the built-in Landed delegate so we can bind to a Lambda in StateTree tasks */\n\tFOnEnemyLanded OnEnemyLanded;\n\n\t/** Enemy died delegate. Allows external subscribers to respond to enemy death */\n\tUPROPERTY(BlueprintAssignable, Category=\"Events\")\n\tFOnEnemyDied OnEnemyDied;\n\n\t/** Called when this enemy dies; includes the actor that caused the death (for style/acrobatic scoring). */\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnEnemyKilledWithCauser, ACombatEnemy*, DeadEnemy, AActor*, DamageCauser);\n\tUPROPERTY(BlueprintAssignable, Category=\"Events\")\n\tFOnEnemyKilledWithCauser OnEnemyKilledWithCauser;\n\npublic:\n\n\t/** Performs an AI-initiated combo attack. Number of hits will be decided by this character */\n\tvoid DoAIComboAttack();\n\n\t/** Performs an AI-initiated charged attack. Charge time will be decided by this character */\n\tvoid DoAIChargedAttack();\n\n\t/** Called from a delegate when the attack montage ends */\n\tvoid AttackMontageEnded(UAnimMontage* Montage, bool bInterrupted);\n\npublic:\n\n\t// ~begin ICombatAttacker interface\n\n\t/** Performs an attack's collision check */\n\tvirtual void DoAttackTrace(FName DamageSourceBone) override;\n\n\t/** Performs a combo attack's check to continue the string */\n\tUFUNCTION(BlueprintCallable, Category=\"Attacker\")\n\tvirtual void CheckCombo() override;\n\n\t/** Performs a charged attack's check to loop the charge animation */\n\tUFUNCTION(BlueprintCallable, Category=\"Attacker\")\n\tvirtual void CheckChargedAttack() override;\n\n\t// ~end ICombatAttacker interface\n\n\t// ~begin ICombatDamageable interface\n\n\t/** Handles damage and knockback events */\n\tvirtual void ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse) override;\n\n\t/** Handles death events */\n\tvirtual void HandleDeath() override;\n\n\t/** Handles healing events */\n\tvirtual void ApplyHealing(float Healing, AActor* Healer) override;\n\n\t// ~end ICombatDamageable interface\n\nprotected:\n\n\t/** Removes this character from the level after it dies */\n\tvoid RemoveFromLevel();\n\npublic:\n\n\t/** Overrides the default TakeDamage functionality */\n\tvirtual float TakeDamage(float Damage, struct FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser) override;\n\n\t/** Overrides landing to reset damage ragdoll physics */\n\tvirtual void Landed(const FHitResult& Hit) override;\n\nprotected:\n\n\t/** Blueprint handler to play damage received effects */\n\tUFUNCTION(BlueprintImplementableEvent, Category=\"Combat\")\n\tvoid ReceivedDamage(float Damage, const FVector& ImpactPoint, const FVector& DamageDirection);\n\nprotected:\n\n\t/** Gameplay initialization */\n\tvirtual void BeginPlay() override;\n\n\t/** EndPlay cleanup */\n\tvirtual void EndPlay(EEndPlayReason::Type EndPlayReason) override;\n};\n","Variant_Combat/AI/CombatEnemySpawner.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatEnemySpawner.h\"\n#include \"Components/SceneComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"Components/ArrowComponent.h\"\n#include \"TimerManager.h\"\n#include \"CombatEnemy.h\"\n\nACombatEnemySpawner::ACombatEnemySpawner()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// create the root\n\tRootComponent = CreateDefaultSubobject<USceneComponent>(TEXT(\"Root\"));\n\n\t// create the reference spawn capsule\n\tSpawnCapsule = CreateDefaultSubobject<UCapsuleComponent>(TEXT(\"Spawn Capsule\"));\n\tSpawnCapsule->SetupAttachment(RootComponent);\n\n\tSpawnCapsule->SetRelativeLocation(FVector(0.0f, 0.0f, 90.0f));\n\tSpawnCapsule->SetCapsuleSize(35.0f, 90.0f);\n\tSpawnCapsule->SetCollisionProfileName(FName(\"NoCollision\"));\n\n\tSpawnDirection = CreateDefaultSubobject<UArrowComponent>(TEXT(\"Spawn Direction\"));\n\tSpawnDirection->SetupAttachment(RootComponent);\n}\n\nvoid ACombatEnemySpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// should we spawn an enemy right away?\n\tif (bShouldSpawnEnemiesImmediately)\n\t{\n\t\t// schedule the first enemy spawn\n\t\tGetWorld()->GetTimerManager().SetTimer(SpawnTimer, this, &ACombatEnemySpawner::SpawnEnemy, InitialSpawnDelay);\n\t}\n\n}\n\nvoid ACombatEnemySpawner::EndPlay(EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\t// clear the spawn timer\n\tGetWorld()->GetTimerManager().ClearTimer(SpawnTimer);\n}\n\nvoid ACombatEnemySpawner::SpawnEnemy()\n{\n\t// ensure the enemy class is valid\n\tif (IsValid(EnemyClass))\n\t{\n\t\t// spawn the enemy at the reference capsule's transform\n\t\tFActorSpawnParameters SpawnParams;\n\t\tSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;\n\n\t\tACombatEnemy* SpawnedEnemy = GetWorld()->SpawnActor<ACombatEnemy>(EnemyClass, SpawnCapsule->GetComponentTransform(), SpawnParams);\n\n\t\t// was the enemy successfully created?\n\t\tif (SpawnedEnemy)\n\t\t{\n\t\t\t// subscribe to the death delegate\n\t\t\tSpawnedEnemy->OnEnemyDied.AddDynamic(this, &ACombatEnemySpawner::OnEnemyDied);\n\t\t}\n\t}\n}\n\nvoid ACombatEnemySpawner::OnEnemyDied(ACombatEnemy* DeadEnemy)\n{\n\t// decrease the spawn counter\n\t--SpawnCount;\n\n\t// is this the last enemy we should spawn?\n\tif (SpawnCount <= 0)\n\t{\n\t\t// schedule the activation on depleted message\n\t\tGetWorld()->GetTimerManager().SetTimer(SpawnTimer, this, &ACombatEnemySpawner::SpawnerDepleted, ActivationDelay);\n\t\treturn;\n\t}\n\n\t// schedule the next enemy spawn\n\tGetWorld()->GetTimerManager().SetTimer(SpawnTimer, this, &ACombatEnemySpawner::SpawnEnemy, RespawnDelay);\n}\n\nvoid ACombatEnemySpawner::SpawnerDepleted()\n{\n\t// process the actors to activate list\n\tfor (AActor* CurrentActor : ActorsToActivateWhenDepleted)\n\t{\n\t\t// check if the actor is activatable\n\t\tif (ICombatActivatable* CombatActivatable = Cast<ICombatActivatable>(CurrentActor))\n\t\t{\n\t\t\t// activate the actor\n\t\t\tCombatActivatable->ActivateInteraction(this);\n\t\t}\n\t}\n}\n\nvoid ACombatEnemySpawner::ToggleInteraction(AActor* ActivationInstigator)\n{\n\t// stub\n}\n\nvoid ACombatEnemySpawner::ActivateInteraction(AActor* ActivationInstigator)\n{\n\t// ensure we're only activated once, and only if we've deferred enemy spawning\n\tif (bHasBeenActivated || bShouldSpawnEnemiesImmediately)\n\t{\n\t\treturn;\n\t}\n\n\t// raise the activation flag\n\tbHasBeenActivated = true;\n\n\t// spawn the first enemy\n\tSpawnEnemy();\n}\n\nvoid ACombatEnemySpawner::DeactivateInteraction(AActor* ActivationInstigator)\n{\n\t// stub\n}\n","Variant_Combat/AI/CombatEnemySpawner.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CombatActivatable.h\"\n#include \"CombatEnemySpawner.generated.h\"\n\nclass UCapsuleComponent;\nclass UArrowComponent;\nclass ACombatEnemy;\n\n/**\n *  A basic Actor in charge of spawning Enemy Characters and monitoring their deaths.\n *  Enemies will be spawned one by one, and the spawner will wait until the enemy dies before spawning a new one.\n *  The spawner can be remotely activated through the ICombatActivatable interface\n *  When the last spawned enemy dies, the spawner can also activate other ICombatActivatables\n */\nUCLASS(abstract)\nclass ACombatEnemySpawner : public AActor, public ICombatActivatable\n{\n\tGENERATED_BODY()\n\t\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUCapsuleComponent* SpawnCapsule;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUArrowComponent* SpawnDirection;\n\nprotected:\n\n\t/** Type of enemy to spawn */\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Enemy Spawner\")\n\tTSubclassOf<ACombatEnemy> EnemyClass;\n\n\t/** If true, the first enemy will be spawned as soon as the game starts */\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Enemy Spawner\")\n\tbool bShouldSpawnEnemiesImmediately = true;\n\n\t/** Time to wait before spawning the first enemy on game start */\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Enemy Spawner\", meta = (ClampMin = 0, ClampMax = 10))\n\tfloat InitialSpawnDelay = 5.0f;\n\n\t/** Number of enemies to spawn */\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Enemy Spawner\", meta = (ClampMin = 0, ClampMax = 100))\n\tint32 SpawnCount = 1;\n\n\t/** Time to wait before spawning the next enemy after the current one dies */\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Enemy Spawner\", meta = (ClampMin = 0, ClampMax = 10))\n\tfloat RespawnDelay = 5.0f;\n\n\t/** Time to wait after this spawner is depleted before activating the actor list */\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Activation\", meta = (ClampMin = 0, ClampMax = 10))\n\tfloat ActivationDelay = 1.0f;\n\n\t/** List of actors to activate after the last enemy dies */\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Activation\")\n\tTArray<AActor*> ActorsToActivateWhenDepleted;\n\n\t/** Flag to ensure this is only activated once */\n\tbool bHasBeenActivated = false;\n\n\t/** Timer to spawn enemies after a delay */\n\tFTimerHandle SpawnTimer;\n\npublic:\t\n\t\n\t/** Constructor */\n\tACombatEnemySpawner();\n\npublic:\n\n\t/** Initialization */\n\tvirtual void BeginPlay() override;\n\n\t/** Cleanup */\n\tvirtual void EndPlay(EEndPlayReason::Type EndPlayReason) override;\n\nprotected:\n\n\t/** Spawn an enemy and subscribe to its death event */\n\tvoid SpawnEnemy();\n\n\t/** Called when the spawned enemy has died */\n\tUFUNCTION()\n\tvoid OnEnemyDied(ACombatEnemy* DeadEnemy);\n\n\t/** Called after the last spawned enemy has died */\n\tvoid SpawnerDepleted();\n\npublic:\n\n\t// ~begin ICombatActivatable interface\n\n\t/** Toggles the Spawner */\n\tUFUNCTION(BlueprintCallable, Category=\"Activatable\")\n\tvirtual void ToggleInteraction(AActor* ActivationInstigator) override;\n\n\t/** Activates the Spawner */\n\tUFUNCTION(BlueprintCallable, Category=\"Activatable\")\n\tvirtual void ActivateInteraction(AActor* ActivationInstigator) override;\n\n\t/** Deactivates the Spawner */\n\tUFUNCTION(BlueprintCallable, Category=\"Activatable\")\n\tvirtual void DeactivateInteraction(AActor* ActivationInstigator) override;\n\n\t// ~end IActivatable interface\n};\n","Variant_Combat/AI/CombatEngagementManager.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Variant_Combat/AI/CombatEngagementManager.h\"\n#include \"Variant_Combat/AI/CombatEnemy.h\"\n#include \"Variant_Combat/CombatCharacter.h\"\n#include \"Variant_Combat/AI/CombatAIController.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"AIController.h\"\n#include \"BehaviorTree/BehaviorTreeComponent.h\"\n#include \"TimerManager.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUCombatEngagementManager::UCombatEngagementManager()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UCombatEngagementManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Find all player characters\n\tTArray<AActor*> FoundActors;\n\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), ACombatCharacter::StaticClass(), FoundActors);\n\n\tfor (AActor* Actor : FoundActors)\n\t{\n\t\tif (ACombatCharacter* PlayerChar = Cast<ACombatCharacter>(Actor))\n\t\t{\n\t\t\tif (!PlayerChar->bIsGhost) // Don't include ghost characters\n\t\t\t{\n\t\t\t\tPlayerCharacters.Add(PlayerChar);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Subscribe to enemy death events for all registered enemies\n\t// This will be called when enemies are registered\n}\n\nvoid UCombatEngagementManager::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Auto-start next engagement if current is done and queue has enemies\n\tif (!IsEngagementActive() && EnemyQueue.Num() > 0)\n\t{\n\t\tStartNextEngagement();\n\t}\n}\n\nvoid UCombatEngagementManager::RegisterEnemy(ACombatEnemy* Enemy)\n{\n\tif (!Enemy || EnemyQueue.Contains(Enemy))\n\t{\n\t\treturn;\n\t}\n\n\tEnemyQueue.Add(Enemy);\n\t\n\t// Subscribe to enemy death event - use a lambda that captures the enemy\n\t// Note: We'll handle this in EndCurrentEngagement when enemy dies\n\t\n\t// Disable AI initially (will be enabled when engaged)\n\tSetEnemyAIEnabled(Enemy, false);\n}\n\nvoid UCombatEngagementManager::RegisterEnemies(const TArray<ACombatEnemy*>& Enemies)\n{\n\tfor (ACombatEnemy* Enemy : Enemies)\n\t{\n\t\tRegisterEnemy(Enemy);\n\t}\n}\n\nvoid UCombatEngagementManager::StartNextEngagement()\n{\n\t// End current engagement if any\n\tif (CurrentEnemy)\n\t{\n\t\tEndCurrentEngagement();\n\t}\n\n\t// Find next valid enemy in queue\n\tACombatEnemy* NextEnemy = nullptr;\n\tint32 NextIndex = INDEX_NONE;\n\n\tfor (int32 i = 0; i < EnemyQueue.Num(); i++)\n\t{\n\t\tif (IsValid(EnemyQueue[i]))\n\t\t{\n\t\t\tNextEnemy = EnemyQueue[i];\n\t\t\tNextIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!NextEnemy)\n\t{\n\t\t// No valid enemies in queue\n\t\tEnemyQueue.Empty();\n\t\treturn;\n\t}\n\n\t// Remove from queue\n\tEnemyQueue.RemoveAt(NextIndex);\n\tCurrentEnemy = NextEnemy;\n\n\t// Enable AI for this enemy\n\tSetEnemyAIEnabled(CurrentEnemy, true);\n\n\t// Disable AI for all other enemies\n\tfor (ACombatEnemy* Enemy : EnemyQueue)\n\t{\n\t\tif (IsValid(Enemy))\n\t\t{\n\t\t\tSetEnemyAIEnabled(Enemy, false);\n\t\t}\n\t}\n\n\tHandleEngagementStarted(CurrentEnemy);\n}\n\nvoid UCombatEngagementManager::EndCurrentEngagement()\n{\n\tif (!CurrentEnemy)\n\t{\n\t\treturn;\n\t}\n\n\tHandleEngagementEnded(CurrentEnemy);\n\n\t// Disable AI for current enemy\n\tSetEnemyAIEnabled(CurrentEnemy, false);\n\n\tACombatEnemy* EndedEnemy = CurrentEnemy;\n\tCurrentEnemy = nullptr;\n\n\t// Remove from queue if still there\n\tEnemyQueue.Remove(EndedEnemy);\n\n\t// Start next engagement after delay\n\tif (EnemyQueue.Num() > 0)\n\t{\n\t\tGetWorld()->GetTimerManager().SetTimer(\n\t\t\tEngagementTimer,\n\t\t\tthis,\n\t\t\t&UCombatEngagementManager::StartNextEngagement,\n\t\t\tEngagementTransitionDelay,\n\t\t\tfalse\n\t\t);\n\t}\n}\n\nTArray<ACombatEnemy*> UCombatEngagementManager::GetWaitingEnemies() const\n{\n\tTArray<ACombatEnemy*> Result;\n\tfor (ACombatEnemy* Enemy : EnemyQueue)\n\t{\n\t\tif (IsValid(Enemy))\n\t\t{\n\t\t\tResult.Add(Enemy);\n\t\t}\n\t}\n\treturn Result;\n}\n\nvoid UCombatEngagementManager::ClearQueue()\n{\n\t// Disable AI for all enemies\n\tfor (ACombatEnemy* Enemy : EnemyQueue)\n\t{\n\t\tif (IsValid(Enemy))\n\t\t{\n\t\t\tSetEnemyAIEnabled(Enemy, false);\n\t\t}\n\t}\n\n\tif (CurrentEnemy)\n\t{\n\t\tSetEnemyAIEnabled(CurrentEnemy, false);\n\t}\n\n\tEnemyQueue.Empty();\n\tCurrentEnemy = nullptr;\n}\n\nvoid UCombatEngagementManager::SetEnemyAIEnabled(ACombatEnemy* Enemy, bool bEnabled)\n{\n\tif (!Enemy)\n\t{\n\t\treturn;\n\t}\n\n\t// Enable/disable AI by stopping movement and disabling brain component\n\tif (AAIController* AIController = Cast<AAIController>(Enemy->GetController()))\n\t{\n\t\tif (bEnabled)\n\t\t{\n\t\t\t// Resume AI - allow movement and behavior\n\t\t\tAIController->GetPawn()->SetActorEnableCollision(true);\n\t\t\tif (UBehaviorTreeComponent* BTComp = AIController->FindComponentByClass<UBehaviorTreeComponent>())\n\t\t\t{\n\t\t\t\t// AI will resume automatically when enabled\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Pause AI - stop movement\n\t\t\tAIController->StopMovement();\n\t\t}\n\t}\n}\n\nvoid UCombatEngagementManager::HandleEngagementStarted(ACombatEnemy* Enemy)\n{\n\tOnEngagementStarted.Broadcast(Enemy);\n}\n\nvoid UCombatEngagementManager::HandleEngagementEnded(ACombatEnemy* Enemy)\n{\n\tOnEngagementEnded.Broadcast(Enemy);\n}\n","Variant_Combat/AI/CombatEngagementManager.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"CPPd1.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CombatEngagementManager.generated.h\"\n\nclass ACombatEnemy;\nclass ACombatCharacter;\n\n/**\n * Manages sequential enemy engagement - only one enemy fights at a time (UFC-style)\n */\nUCLASS(ClassGroup = (Combat), meta = (BlueprintSpawnableComponent))\nclass CPPd1_API UCombatEngagementManager : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUCombatEngagementManager();\n\n\tvirtual void BeginPlay() override;\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\t/** Register an enemy to the engagement queue */\n\tUFUNCTION(BlueprintCallable, Category = \"Engagement\")\n\tvoid RegisterEnemy(ACombatEnemy* Enemy);\n\n\t/** Register multiple enemies at once */\n\tUFUNCTION(BlueprintCallable, Category = \"Engagement\")\n\tvoid RegisterEnemies(const TArray<ACombatEnemy*>& Enemies);\n\n\t/** Start engagement with the next enemy in queue */\n\tUFUNCTION(BlueprintCallable, Category = \"Engagement\")\n\tvoid StartNextEngagement();\n\n\t/** End current engagement and move to next */\n\tUFUNCTION(BlueprintCallable, Category = \"Engagement\")\n\tvoid EndCurrentEngagement();\n\n\t/** Get the currently engaged enemy */\n\tUFUNCTION(BlueprintPure, Category = \"Engagement\")\n\tACombatEnemy* GetCurrentEnemy() const { return CurrentEnemy; }\n\n\t/** Get all enemies waiting to engage */\n\tUFUNCTION(BlueprintPure, Category = \"Engagement\")\n\tTArray<ACombatEnemy*> GetWaitingEnemies() const;\n\n\t/** Check if an engagement is active */\n\tUFUNCTION(BlueprintPure, Category = \"Engagement\")\n\tbool IsEngagementActive() const { return CurrentEnemy != nullptr; }\n\n\t/** Clear all enemies from queue */\n\tUFUNCTION(BlueprintCallable, Category = \"Engagement\")\n\tvoid ClearQueue();\n\nprotected:\n\t/** Queue of enemies waiting to engage */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Engagement\")\n\tTArray<TObjectPtr<ACombatEnemy>> EnemyQueue;\n\n\t/** Currently engaged enemy */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Engagement\")\n\tTObjectPtr<ACombatEnemy> CurrentEnemy;\n\n\t/** Player characters (for targeting) */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Engagement\")\n\tTArray<TObjectPtr<ACombatCharacter>> PlayerCharacters;\n\n\t/** Distance threshold for engagement (enemy must be within this to engage) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Engagement\", meta = (ClampMin = 0.0f, Units = \"cm\"))\n\tfloat EngagementDistance = 500.0f;\n\n\t/** Time delay before starting next engagement after current ends */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Engagement\", meta = (ClampMin = 0.0f, Units = \"s\"))\n\tfloat EngagementTransitionDelay = 2.0f;\n\n\t/** Enable/disable AI for enemies not currently engaged */\n\tUFUNCTION(BlueprintCallable, Category = \"Engagement\")\n\tvoid SetEnemyAIEnabled(ACombatEnemy* Enemy, bool bEnabled);\n\n\t/** Called when engagement starts (internal handler) */\n\tvoid HandleEngagementStarted(ACombatEnemy* Enemy);\n\n\t/** Called when engagement ends (internal handler) */\n\tvoid HandleEngagementEnded(ACombatEnemy* Enemy);\n\n\tFTimerHandle EngagementTimer;\n\npublic:\n\t/** Delegate for when engagement starts */\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnEngagementStarted, ACombatEnemy*, Enemy);\n\n\t/** Delegate for when engagement ends */\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnEngagementEnded, ACombatEnemy*, Enemy);\n\n\t/** Event fired when engagement starts */\n\tUPROPERTY(BlueprintAssignable, Category = \"Events\")\n\tFOnEngagementStarted OnEngagementStarted;\n\n\t/** Event fired when engagement ends */\n\tUPROPERTY(BlueprintAssignable, Category = \"Events\")\n\tFOnEngagementEnded OnEngagementEnded;\n};\n","Variant_Combat/AI/CombatStateTreeUtility.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatStateTreeUtility.h\"\n#include \"StateTreeExecutionContext.h\"\n#include \"StateTreeExecutionTypes.h\"\n#include \"GameFramework/Character.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"AIController.h\"\n#include \"CombatEnemy.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"StateTreeAsyncExecutionContext.h\"\n\nbool FStateTreeCharacterGroundedCondition::TestCondition(FStateTreeExecutionContext& Context) const\n{\n\tconst FInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t// is the character currently grounded?\n\tbool bCondition = InstanceData.Character->GetMovementComponent()->IsMovingOnGround();\n\n\treturn InstanceData.bMustBeOnAir ? !bCondition : bCondition;\n}\n\n#if WITH_EDITOR\nFText FStateTreeCharacterGroundedCondition::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const\n{\n\treturn FText::FromString(\"<b>Is Character Grounded</b>\");\n}\n#endif // WITH_EDITOR\n\n////////////////////////////////////////////////////////////////////\n\nEStateTreeRunStatus FStateTreeComboAttackTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\t// have we transitioned from another state?\n\tif (Transition.ChangeType == EStateTreeStateChangeType::Changed)\n\t{\n\t\t// get the instance data\n\t\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t\t// bind to the on attack completed delegate\n\t\tInstanceData.Character->OnAttackCompleted.BindLambda(\n\t\t\t[WeakContext = Context.MakeWeakExecutionContext()]()\n\t\t\t{\n\t\t\t\tWeakContext.FinishTask(EStateTreeFinishTaskType::Succeeded);\n\t\t\t}\n\t\t);\n\n\n\t\t// tell the character to do a combo attack\n\t\tInstanceData.Character->DoAIComboAttack();\n\t}\n\n\treturn EStateTreeRunStatus::Running;\n}\n\nvoid FStateTreeComboAttackTask::ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\t// have we transitioned from another state?\n\tif (Transition.ChangeType == EStateTreeStateChangeType::Changed)\n\t{\n\t\t// get the instance data\n\t\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t\t// unbind the on attack completed delegate\n\t\tInstanceData.Character->OnAttackCompleted.Unbind();\n\t}\n}\n\n#if WITH_EDITOR\nFText FStateTreeComboAttackTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const\n{\n\treturn FText::FromString(\"<b>Do Combo Attack</b>\");\n}\n#endif // WITH_EDITOR\n\n////////////////////////////////////////////////////////////////////\n\nEStateTreeRunStatus FStateTreeChargedAttackTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\t// have we transitioned from another state?\n\tif (Transition.ChangeType == EStateTreeStateChangeType::Changed)\n\t{\n\t\t// get the instance data\n\t\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t\t// bind to the on attack completed delegate\n\t\tInstanceData.Character->OnAttackCompleted.BindLambda(\n\t\t\t[WeakContext = Context.MakeWeakExecutionContext()]()\n\t\t\t{\n\t\t\t\tWeakContext.FinishTask(EStateTreeFinishTaskType::Succeeded);\n\t\t\t}\n\t\t);\n\n\t\t// tell the character to do a combo attack\n\t\tInstanceData.Character->DoAIChargedAttack();\n\t}\n\n\treturn EStateTreeRunStatus::Running;\n}\n\nvoid FStateTreeChargedAttackTask::ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\t// have we transitioned from another state?\n\tif (Transition.ChangeType == EStateTreeStateChangeType::Changed)\n\t{\n\t\t// get the instance data\n\t\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t\t// unbind the on attack completed delegate\n\t\tInstanceData.Character->OnAttackCompleted.Unbind();\n\t}\n}\n\n#if WITH_EDITOR\nFText FStateTreeChargedAttackTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const\n{\n\treturn FText::FromString(\"<b>Do Charged Attack</b>\");\n}\n#endif // WITH_EDITOR\n\n////////////////////////////////////////////////////////////////////\n\nEStateTreeRunStatus FStateTreeWaitForLandingTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\t// have we transitioned from another state?\n\tif (Transition.ChangeType == EStateTreeStateChangeType::Changed)\n\t{\n\t\t// get the instance data\n\t\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t\t// bind to the on enemy landed delegate\n\t\tInstanceData.Character->OnEnemyLanded.BindLambda(\n\t\t\t[WeakContext = Context.MakeWeakExecutionContext()]()\n\t\t\t{\n\t\t\t\tWeakContext.FinishTask(EStateTreeFinishTaskType::Succeeded);\n\t\t\t}\n\t\t);\n\t}\n\n\treturn EStateTreeRunStatus::Running;\n}\n\nvoid FStateTreeWaitForLandingTask::ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\t// have we transitioned from another state?\n\tif (Transition.ChangeType == EStateTreeStateChangeType::Changed)\n\t{\n\t\t// get the instance data\n\t\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t\t// bind the on enemy landed delegate\n\t\tInstanceData.Character->OnEnemyLanded.Unbind();\n\t}\n}\n\n#if WITH_EDITOR\nFText FStateTreeWaitForLandingTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const\n{\n\treturn FText::FromString(\"<b>Wait for Landing</b>\");\n}\n#endif // WITH_EDITOR\n\n////////////////////////////////////////////////////////////////////\n\nEStateTreeRunStatus FStateTreeFaceActorTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\t// have we transitioned from another state?\n\tif (Transition.ChangeType == EStateTreeStateChangeType::Changed)\n\t{\n\t\t// get the instance data\n\t\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t\t// set the AI Controller's focus\n\t\tInstanceData.Controller->SetFocus(InstanceData.ActorToFaceTowards);\n\t}\n\n\treturn EStateTreeRunStatus::Running;\n}\n\nvoid FStateTreeFaceActorTask::ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\t// have we transitioned to another state?\n\tif (Transition.ChangeType == EStateTreeStateChangeType::Changed)\n\t{\n\t\t// get the instance data\n\t\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t\t// clear the AI Controller's focus\n\t\tInstanceData.Controller->ClearFocus(EAIFocusPriority::Gameplay);\n\t}\n}\n\n#if WITH_EDITOR\nFText FStateTreeFaceActorTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const\n{\n\treturn FText::FromString(\"<b>Face Towards Actor</b>\");\n}\n#endif // WITH_EDITOR\n\n////////////////////////////////////////////////////////////////////\n\nEStateTreeRunStatus FStateTreeFaceLocationTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\t// have we transitioned from another state?\n\tif (Transition.ChangeType == EStateTreeStateChangeType::Changed)\n\t{\n\t\t// get the instance data\n\t\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t\t// set the AI Controller's focus\n\t\tInstanceData.Controller->SetFocalPoint(InstanceData.FaceLocation);\n\t}\n\n\treturn EStateTreeRunStatus::Running;\n}\n\nvoid FStateTreeFaceLocationTask::ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\t// have we transitioned to another state?\n\tif (Transition.ChangeType == EStateTreeStateChangeType::Changed)\n\t{\n\t\t// get the instance data\n\t\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t\t// clear the AI Controller's focus\n\t\tInstanceData.Controller->ClearFocus(EAIFocusPriority::Gameplay);\n\t}\n}\n\n#if WITH_EDITOR\nFText FStateTreeFaceLocationTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const\n{\n\treturn FText::FromString(\"<b>Face Towards Location</b>\");\n}\n#endif // WITH_EDITOR\n\n////////////////////////////////////////////////////////////////////\n\nEStateTreeRunStatus FStateTreeSetCharacterSpeedTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\t// have we transitioned from another state?\n\tif (Transition.ChangeType == EStateTreeStateChangeType::Changed)\n\t{\n\t\t// get the instance data\n\t\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t\t// set the character's max ground speed\n\t\tInstanceData.Character->GetCharacterMovement()->MaxWalkSpeed = InstanceData.Speed;\n\t}\n\n\treturn EStateTreeRunStatus::Running;\n}\n\n#if WITH_EDITOR\nFText FStateTreeSetCharacterSpeedTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const\n{\n\treturn FText::FromString(\"<b>Set Character Speed</b>\");\n}\n#endif // WITH_EDITOR\n\n////////////////////////////////////////////////////////////////////\n\nEStateTreeRunStatus FStateTreeGetPlayerInfoTask::Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const\n{\n\t// get the instance data\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t// get the character possessed by the first local player\n\tInstanceData.TargetPlayerCharacter = Cast<ACharacter>(UGameplayStatics::GetPlayerPawn(InstanceData.Character, 0));\n\n\t// do we have a valid target?\n\tif (InstanceData.TargetPlayerCharacter)\n\t{\n\t\t// update the last known location\n\t\tInstanceData.TargetPlayerLocation = InstanceData.TargetPlayerCharacter->GetActorLocation();\n\t}\n\n\t// update the distance\n\tInstanceData.DistanceToTarget = FVector::Distance(InstanceData.TargetPlayerLocation, InstanceData.Character->GetActorLocation());\n\n\treturn EStateTreeRunStatus::Running;\n}\n\n#if WITH_EDITOR\nFText FStateTreeGetPlayerInfoTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const\n{\n\treturn FText::FromString(\"<b>Get Player Info</b>\");\n}\n#endif // WITH_EDITOR","Variant_Combat/AI/CombatStateTreeUtility.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"StateTreeTaskBase.h\"\n#include \"StateTreeConditionBase.h\"\n\n#include \"CombatStateTreeUtility.generated.h\"\n\nclass ACharacter;\nclass AAIController;\nclass ACombatEnemy;\n\n/**\n *  Instance data struct for the FStateTreeCharacterGroundedCondition condition\n */\nUSTRUCT()\nstruct FStateTreeCharacterGroundedConditionInstanceData\n{\n\tGENERATED_BODY()\n\t\n\t/** Character to check grounded status on */\n\tUPROPERTY(EditAnywhere, Category = \"Context\")\n\tACharacter* Character;\n\n\t/** If true, the condition passes if the character is not grounded instead */\n\tUPROPERTY(EditAnywhere, Category = \"Condition\")\n\tbool bMustBeOnAir = false;\n};\nSTATETREE_POD_INSTANCEDATA(FStateTreeCharacterGroundedConditionInstanceData);\n\n/**\n *  StateTree condition to check if the character is grounded\n */\nUSTRUCT(DisplayName = \"Character is Grounded\")\nstruct FStateTreeCharacterGroundedCondition : public FStateTreeConditionCommonBase\n{\n\tGENERATED_BODY()\n\n\t/** Set the instance data type */\n\tusing FInstanceDataType = FStateTreeCharacterGroundedConditionInstanceData;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\n\t/** Default constructor */\n\tFStateTreeCharacterGroundedCondition() = default;\n\t\n\t/** Tests the StateTree condition */\n\tvirtual bool TestCondition(FStateTreeExecutionContext& Context) const override;\n\n#if WITH_EDITOR\n\n\t/** Provides the description string */\n\tvirtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;\n#endif\n\n};\n\n////////////////////////////////////////////////////////////////////\n\n/**\n *  Instance data struct for the Combat StateTree tasks\n */\nUSTRUCT()\nstruct FStateTreeAttackInstanceData\n{\n\tGENERATED_BODY()\n\n\t/** Character that will perform the attack */\n\tUPROPERTY(EditAnywhere, Category = Context)\n\tTObjectPtr<ACombatEnemy> Character;\n};\n\n/**\n *  StateTree task to perform a combo attack\n */\nUSTRUCT(meta=(DisplayName=\"Combo Attack\", Category=\"Combat\"))\nstruct FStateTreeComboAttackTask : public FStateTreeTaskCommonBase\n{\n\tGENERATED_BODY()\n\n\t/* Ensure we're using the correct instance data struct */\n\tusing FInstanceDataType = FStateTreeAttackInstanceData;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\n\t/** Runs when the owning state is entered */\n\tvirtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\n\t/** Runs when the owning state is ended */\n\tvirtual void ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\n#if WITH_EDITOR\n\tvirtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;\n#endif // WITH_EDITOR\n};\n\n/**\n *  StateTree task to perform a charged attack\n */\nUSTRUCT(meta=(DisplayName=\"Charged Attack\", Category=\"Combat\"))\nstruct FStateTreeChargedAttackTask : public FStateTreeTaskCommonBase\n{\n\tGENERATED_BODY()\n\n\t/* Ensure we're using the correct instance data struct */\n\tusing FInstanceDataType = FStateTreeAttackInstanceData;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\n\t/** Runs when the owning state is entered */\n\tvirtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\n\t/** Runs when the owning state is ended */\n\tvirtual void ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\n#if WITH_EDITOR\n\tvirtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;\n#endif // WITH_EDITOR\n};\n\n/**\n *  StateTree task to wait for the character to land\n */\nUSTRUCT(meta=(DisplayName=\"Wait for Landing\", Category=\"Combat\"))\nstruct FStateTreeWaitForLandingTask : public FStateTreeTaskCommonBase\n{\n\tGENERATED_BODY()\n\n\t/* Ensure we're using the correct instance data struct */\n\tusing FInstanceDataType = FStateTreeAttackInstanceData;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\n\t/** Runs when the owning state is entered */\n\tvirtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\n\t/** Runs when the owning state is ended */\n\tvirtual void ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\n#if WITH_EDITOR\n\tvirtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;\n#endif // WITH_EDITOR\n};\n\n////////////////////////////////////////////////////////////////////\n\n/**\n *  Instance data struct for the Face Towards Actor StateTree task\n */\nUSTRUCT()\nstruct FStateTreeFaceActorInstanceData\n{\n\tGENERATED_BODY()\n\n\t/** AI Controller that will determine the focused actor */\n\tUPROPERTY(EditAnywhere, Category = Context)\n\tTObjectPtr<AAIController> Controller;\n\n\t/** Actor that will be faced towards */\n\tUPROPERTY(EditAnywhere, Category = Input)\n\tTObjectPtr<AActor> ActorToFaceTowards;\n};\n\n/**\n *  StateTree task to face an AI-Controlled Pawn towards an Actor\n */\nUSTRUCT(meta=(DisplayName=\"Face Towards Actor\", Category=\"Combat\"))\nstruct FStateTreeFaceActorTask : public FStateTreeTaskCommonBase\n{\n\tGENERATED_BODY()\n\n\t/* Ensure we're using the correct instance data struct */\n\tusing FInstanceDataType = FStateTreeFaceActorInstanceData;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\n\t/** Runs when the owning state is entered */\n\tvirtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\n\t/** Runs when the owning state is ended */\n\tvirtual void ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\n#if WITH_EDITOR\n\tvirtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;\n#endif // WITH_EDITOR\n};\n\n////////////////////////////////////////////////////////////////////\n\n/**\n *  Instance data struct for the Face Towards Location StateTree task\n */\nUSTRUCT()\nstruct FStateTreeFaceLocationInstanceData\n{\n\tGENERATED_BODY()\n\n\t/** AI Controller that will determine the focused location */\n\tUPROPERTY(EditAnywhere, Category = Context)\n\tTObjectPtr<AAIController> Controller;\n\n\t/** Location that will be faced towards */\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tFVector FaceLocation = FVector::ZeroVector;\n};\n\n/**\n *  StateTree task to face an AI-Controlled Pawn towards a world location\n */\nUSTRUCT(meta=(DisplayName=\"Face Towards Location\", Category=\"Combat\"))\nstruct FStateTreeFaceLocationTask : public FStateTreeTaskCommonBase\n{\n\tGENERATED_BODY()\n\n\t/* Ensure we're using the correct instance data struct */\n\tusing FInstanceDataType = FStateTreeFaceLocationInstanceData;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\n\t/** Runs when the owning state is entered */\n\tvirtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\n\t/** Runs when the owning state is ended */\n\tvirtual void ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\n#if WITH_EDITOR\n\tvirtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;\n#endif // WITH_EDITOR\n};\n\n////////////////////////////////////////////////////////////////////\n\n/**\n *  Instance data struct for the Set Character Speed StateTree task\n */\nUSTRUCT()\nstruct FStateTreeSetCharacterSpeedInstanceData\n{\n\tGENERATED_BODY()\n\n\t/** Character that will be affected */\n\tUPROPERTY(EditAnywhere, Category = Context)\n\tTObjectPtr<ACharacter> Character;\n\n\t/** Max ground speed to set for the character */\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tfloat Speed = 600.0f;\n};\n\n/**\n *  StateTree task to change a Character's ground speed\n */\nUSTRUCT(meta=(DisplayName=\"Set Character Speed\", Category=\"Combat\"))\nstruct FStateTreeSetCharacterSpeedTask : public FStateTreeTaskCommonBase\n{\n\tGENERATED_BODY()\n\n\t/* Ensure we're using the correct instance data struct */\n\tusing FInstanceDataType = FStateTreeSetCharacterSpeedInstanceData;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\n\t/** Runs when the owning state is entered */\n\tvirtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\n#if WITH_EDITOR\n\tvirtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;\n#endif // WITH_EDITOR\n};\n\n////////////////////////////////////////////////////////////////////\n\n/**\n *  Instance data struct for the Get Player Info task\n */\nUSTRUCT()\nstruct FStateTreeGetPlayerInfoInstanceData\n{\n\tGENERATED_BODY()\n\n\t/** Character that owns this task */\n\tUPROPERTY(EditAnywhere, Category = Context)\n\tTObjectPtr<ACharacter> Character;\n\n\t/** Character that owns this task */\n\tUPROPERTY(VisibleAnywhere)\n\tTObjectPtr<ACharacter> TargetPlayerCharacter;\n\n\t/** Last known location for the target */\n\tUPROPERTY(VisibleAnywhere)\n\tFVector TargetPlayerLocation = FVector::ZeroVector;\n\n\t/** Distance to the target */\n\tUPROPERTY(VisibleAnywhere)\n\tfloat DistanceToTarget = 0.0f;\n};\n\n/**\n *  StateTree task to get information about the player character\n */\nUSTRUCT(meta=(DisplayName=\"GetPlayerInfo\", Category=\"Combat\"))\nstruct FStateTreeGetPlayerInfoTask : public FStateTreeTaskCommonBase\n{\n\tGENERATED_BODY()\n\n\t/* Ensure we're using the correct instance data struct */\n\tusing FInstanceDataType = FStateTreeGetPlayerInfoInstanceData;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\n\t/** Runs while the owning state is active */\n\tvirtual EStateTreeRunStatus Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;\n\n#if WITH_EDITOR\n\tvirtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;\n#endif // WITH_EDITOR\n};","Variant_Combat/AI/CombatWaveSpawner.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Variant_Combat/AI/CombatWaveSpawner.h\"\n#include \"Variant_Combat/AI/CombatEnemy.h\"\n#include \"Components/SceneComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"TimerManager.h\"\n#include \"Engine/World.h\"\n\nACombatWaveSpawner::ACombatWaveSpawner()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tRootSceneComponent = CreateDefaultSubobject<USceneComponent>(TEXT(\"RootScene\"));\n\tRootComponent = RootSceneComponent;\n\n\tSpawnCapsule = CreateDefaultSubobject<UCapsuleComponent>(TEXT(\"SpawnCapsule\"));\n\tSpawnCapsule->SetupAttachment(RootComponent);\n\tSpawnCapsule->SetRelativeLocation(FVector(0.0f, 0.0f, 90.0f));\n\tSpawnCapsule->SetCapsuleSize(35.0f, 90.0f);\n\tSpawnCapsule->SetCollisionProfileName(FName(\"NoCollision\"));\n\tSpawnCapsule->SetHiddenInGame(true);\n}\n\nvoid ACombatWaveSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (bStartWavesOnBeginPlay && WaveConfigs.Num() > 0)\n\t{\n\t\tStartWaves();\n\t}\n}\n\nvoid ACombatWaveSpawner::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\tGetWorld()->GetTimerManager().ClearTimer(WaveStartTimer);\n\tGetWorld()->GetTimerManager().ClearTimer(SpawnTimer);\n}\n\nvoid ACombatWaveSpawner::StartWaves()\n{\n\tCurrentWaveIndex = 0;\n\tCurrentWaveEnemies.Empty();\n\tAllSpawnedEnemies.Empty();\n\n\tif (WaveConfigs.Num() > 0)\n\t{\n\t\tSpawnNextWave();\n\t}\n}\n\nvoid ACombatWaveSpawner::SpawnNextWave()\n{\n\tif (CurrentWaveIndex >= WaveConfigs.Num())\n\t{\n\t\t// All waves complete\n\t\tOnAllWavesCompleted.Broadcast();\n\t\treturn;\n\t}\n\n\tconst FCombatWaveConfig& WaveConfig = WaveConfigs[CurrentWaveIndex];\n\tCurrentSpawnIndex = 0;\n\tCurrentWaveEnemies.Empty();\n\n\tOnWaveStarted.Broadcast(CurrentWaveIndex);\n\n\t// Schedule first enemy spawn after delay\n\tif (WaveConfig.WaveStartDelay > 0.0f)\n\t{\n\t\tGetWorld()->GetTimerManager().SetTimer(\n\t\t\tWaveStartTimer,\n\t\t\tthis,\n\t\t\t&ACombatWaveSpawner::SpawnEnemyInWave,\n\t\t\tWaveConfig.WaveStartDelay,\n\t\t\tfalse\n\t\t);\n\t}\n\telse\n\t{\n\t\tSpawnEnemyInWave();\n\t}\n}\n\nvoid ACombatWaveSpawner::SpawnEnemyInWave()\n{\n\tif (CurrentWaveIndex >= WaveConfigs.Num()) return;\n\n\tconst FCombatWaveConfig& WaveConfig = WaveConfigs[CurrentWaveIndex];\n\tif (CurrentSpawnIndex >= WaveConfig.EnemyCount) return;\n\n\t// Pick class: mixed pool or single\n\tTSubclassOf<ACombatEnemy> ChosenClass = nullptr;\n\tif (WaveConfig.EnemyClassPool.Num() > 0)\n\t{\n\t\tTArray<TSubclassOf<ACombatEnemy>> Valid;\n\t\tfor (TSubclassOf<ACombatEnemy> C : WaveConfig.EnemyClassPool)\n\t\t\tif (C) Valid.Add(C);\n\t\tif (Valid.Num() > 0)\n\t\t\tChosenClass = Valid[FMath::RandRange(0, Valid.Num() - 1)];\n\t}\n\tif (!ChosenClass)\n\t\tChosenClass = WaveConfig.EnemyClass;\n\n\tif (ChosenClass)\n\t{\n\t\tFActorSpawnParameters SpawnParams;\n\t\tSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;\n\n\t\tFVector SpawnLocation = GetSpawnLocation();\n\t\tOnSpawnLocationUsed();\n\t\tFRotator SpawnRotation = SpawnCapsule->GetComponentRotation();\n\t\tSpawnLocation += FVector(\n\t\t\tFMath::RandRange(-100.0f, 100.0f),\n\t\t\tFMath::RandRange(-100.0f, 100.0f),\n\t\t\t0.0f\n\t\t);\n\n\t\tACombatEnemy* SpawnedEnemy = GetWorld()->SpawnActor<ACombatEnemy>(\n\t\t\tChosenClass,\n\t\t\tSpawnLocation,\n\t\t\tSpawnRotation,\n\t\t\tSpawnParams\n\t\t);\n\n\t\tif (SpawnedEnemy)\n\t\t{\n\t\t\tSpawnedEnemy->WaveIntensityScale = FMath::Max(0.1f, WaveConfig.IntensityScale);\n\t\t\tCurrentWaveEnemies.Add(SpawnedEnemy);\n\t\t\tAllSpawnedEnemies.Add(SpawnedEnemy);\n\t\t\tSpawnedEnemy->OnEnemyDied.AddDynamic(this, &ACombatWaveSpawner::OnEnemyDied);\n\t\t\tOnEnemySpawned.Broadcast(SpawnedEnemy);\n\t\t}\n\t}\n\n\tCurrentSpawnIndex++;\n\n\tconst float NextInterval = WaveConfig.bRushWave ? 0.0f : WaveConfig.SpawnInterval;\n\tif (CurrentSpawnIndex < WaveConfig.EnemyCount)\n\t{\n\t\tGetWorld()->GetTimerManager().SetTimer(\n\t\t\tSpawnTimer,\n\t\t\tthis,\n\t\t\t&ACombatWaveSpawner::SpawnEnemyInWave,\n\t\t\tNextInterval,\n\t\t\tfalse\n\t\t);\n\t}\n}\n\nFVector ACombatWaveSpawner::GetSpawnLocation_Implementation()\n{\n\treturn SpawnCapsule ? SpawnCapsule->GetComponentLocation() : GetActorLocation();\n}\n\nvoid ACombatWaveSpawner::OnSpawnLocationUsed_Implementation()\n{\n}\n\nvoid ACombatWaveSpawner::OnEnemyDied(ACombatEnemy* DeadEnemy)\n{\n\tif (!DeadEnemy)\n\t{\n\t\treturn;\n\t}\n\n\t// Remove from current wave\n\tCurrentWaveEnemies.Remove(DeadEnemy);\n\n\t// Check if current wave is complete\n\tif (CurrentWaveEnemies.Num() == 0)\n\t{\n\t\tOnWaveCompleted.Broadcast(CurrentWaveIndex);\n\t\tCurrentWaveIndex++;\n\n\t\t// Start next wave\n\t\tif (CurrentWaveIndex < WaveConfigs.Num())\n\t\t{\n\t\t\tSpawnNextWave();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOnAllWavesCompleted.Broadcast();\n\t\t}\n\t}\n}\n\nTArray<ACombatEnemy*> ACombatWaveSpawner::GetCurrentWaveEnemies() const\n{\n\tTArray<ACombatEnemy*> Result;\n\tfor (ACombatEnemy* Enemy : CurrentWaveEnemies)\n\t{\n\t\tif (IsValid(Enemy))\n\t\t{\n\t\t\tResult.Add(Enemy);\n\t\t}\n\t}\n\treturn Result;\n}\n\nTArray<ACombatEnemy*> ACombatWaveSpawner::GetAllSpawnedEnemies() const\n{\n\tTArray<ACombatEnemy*> Result;\n\tfor (ACombatEnemy* Enemy : AllSpawnedEnemies)\n\t{\n\t\tif (IsValid(Enemy))\n\t\t{\n\t\t\tResult.Add(Enemy);\n\t\t}\n\t}\n\treturn Result;\n}\n\nbool ACombatWaveSpawner::AreAllWavesComplete() const\n{\n\treturn CurrentWaveIndex >= WaveConfigs.Num() && CurrentWaveEnemies.Num() == 0;\n}\n\nvoid ACombatWaveSpawner::ResetWaves()\n{\n\tCurrentWaveIndex = 0;\n\tCurrentSpawnIndex = 0;\n\tCurrentWaveEnemies.Empty();\n\tAllSpawnedEnemies.Empty();\n\n\tGetWorld()->GetTimerManager().ClearTimer(WaveStartTimer);\n\tGetWorld()->GetTimerManager().ClearTimer(SpawnTimer);\n}\n","Variant_Combat/AI/CombatWaveSpawner.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"CPPd1.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CombatWaveSpawner.generated.h\"\n\nclass ACombatEnemy;\nclass USceneComponent;\nclass UCapsuleComponent;\n\n/**\n * Wave configuration structure\n */\nUSTRUCT(BlueprintType)\nstruct FCombatWaveConfig\n{\n\tGENERATED_BODY()\n\n\t/** Number of enemies in this wave */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Wave\", meta = (ClampMin = 1, ClampMax = 20))\n\tint32 EnemyCount = 3;\n\n\t/** Time delay before starting this wave */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Wave\", meta = (ClampMin = 0.0f, Units = \"s\"))\n\tfloat WaveStartDelay = 2.0f;\n\n\t/** Time between enemy spawns within the wave. Rush: set to 0 for instant spawn burst. */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Wave\", meta = (ClampMin = 0.0f, Units = \"s\"))\n\tfloat SpawnInterval = 1.0f;\n\n\t/** Type of enemy to spawn (used if EnemyClassPool is empty) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Wave\")\n\tTSubclassOf<ACombatEnemy> EnemyClass;\n\n\t/** If non-empty, each spawn picks a random class from this pool (mixed wave). Otherwise use EnemyClass. */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Wave|Fun\")\n\tTArray<TSubclassOf<ACombatEnemy>> EnemyClassPool;\n\n\t/** Intensity scale for this wave. >1 = enemies deal more damage, take less, move faster. */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Wave|Fun\", meta = (ClampMin = 0.1f, ClampMax = 5.0f))\n\tfloat IntensityScale = 1.0f;\n\n\t/** If true, spawn all enemies in this wave at once (ignores SpawnInterval for a rush). */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Wave|Fun\")\n\tbool bRushWave = false;\n};\n\n/**\n * Wave-based enemy spawner that spawns enemies in waves (3, 5, etc.)\n * Enemies spawn but only one engages at a time (managed by CombatEngagementManager)\n */\nUCLASS(BlueprintType, Blueprintable)\nclass CPPd1_API ACombatWaveSpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACombatWaveSpawner();\n\nprotected:\n\t/** Root scene component */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tTObjectPtr<USceneComponent> RootSceneComponent;\n\n\t/** Spawn point capsule (visual reference) */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tTObjectPtr<UCapsuleComponent> SpawnCapsule;\n\n\t/** Array of wave configurations */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Waves\")\n\tTArray<FCombatWaveConfig> WaveConfigs;\n\n\t/** If true, start spawning waves immediately on BeginPlay */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Waves\")\n\tbool bStartWavesOnBeginPlay = true;\n\n\t/** Current wave index */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Waves\")\n\tint32 CurrentWaveIndex = 0;\n\n\t/** Enemies spawned in current wave (waiting to engage) */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Waves\")\n\tTArray<TObjectPtr<ACombatEnemy>> CurrentWaveEnemies;\n\n\t/** All enemies spawned by this spawner */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Waves\")\n\tTArray<TObjectPtr<ACombatEnemy>> AllSpawnedEnemies;\n\n\t/** Timer handles */\n\tFTimerHandle WaveStartTimer;\n\tFTimerHandle SpawnTimer;\n\n\t/** Current spawn index within wave */\n\tint32 CurrentSpawnIndex = 0;\n\npublic:\n\tvirtual void BeginPlay() override;\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n\n\t/** Start spawning waves */\n\tUFUNCTION(BlueprintCallable, Category = \"Waves\")\n\tvoid StartWaves();\n\n\t/** Spawn the next wave */\n\tUFUNCTION(BlueprintCallable, Category = \"Waves\")\n\tvoid SpawnNextWave();\n\n\t/** Spawn a single enemy in the current wave */\n\tvoid SpawnEnemyInWave();\n\n\t/** Override to change where the next enemy spawns (e.g. spinning radius). Default: SpawnCapsule location. */\n\tUFUNCTION(BlueprintNativeEvent, Category = \"Waves\")\n\tFVector GetSpawnLocation();\n\tvirtual FVector GetSpawnLocation_Implementation();\n\n\t/** Called after an enemy is spawned at GetSpawnLocation (e.g. to advance a spinning angle). */\n\tUFUNCTION(BlueprintNativeEvent, Category = \"Waves\")\n\tvoid OnSpawnLocationUsed();\n\tvirtual void OnSpawnLocationUsed_Implementation();\n\n\t/** Called when an enemy dies */\n\tUFUNCTION()\n\tvoid OnEnemyDied(ACombatEnemy* DeadEnemy);\n\n\t/** Get all enemies in current wave */\n\tUFUNCTION(BlueprintPure, Category = \"Waves\")\n\tTArray<ACombatEnemy*> GetCurrentWaveEnemies() const;\n\n\t/** Get all spawned enemies */\n\tUFUNCTION(BlueprintPure, Category = \"Waves\")\n\tTArray<ACombatEnemy*> GetAllSpawnedEnemies() const;\n\n\t/** Get current wave index (0-based) */\n\tUFUNCTION(BlueprintPure, Category = \"Waves\")\n\tint32 GetCurrentWaveIndex() const { return CurrentWaveIndex; }\n\n\t/** Check if all waves are complete */\n\tUFUNCTION(BlueprintPure, Category = \"Waves\")\n\tbool AreAllWavesComplete() const;\n\n\t/** Reset spawner to start from first wave */\n\tUFUNCTION(BlueprintCallable, Category = \"Waves\")\n\tvoid ResetWaves();\n\nprotected:\n\t/** Delegate for when a wave starts */\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnWaveStarted, int32, WaveIndex);\n\n\t/** Delegate for when a wave completes */\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnWaveCompleted, int32, WaveIndex);\n\n\t/** Delegate for when all waves complete */\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnAllWavesCompleted);\n\n\t/** Delegate for when a single enemy is spawned (so engagement manager can register it) */\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnEnemySpawned, ACombatEnemy*, Enemy);\n\npublic:\n\t/** Event fired when a wave starts */\n\tUPROPERTY(BlueprintAssignable, Category = \"Events\")\n\tFOnWaveStarted OnWaveStarted;\n\n\t/** Event fired when an enemy is spawned in a wave */\n\tUPROPERTY(BlueprintAssignable, Category = \"Events\")\n\tFOnEnemySpawned OnEnemySpawned;\n\n\t/** Event fired when a wave completes */\n\tUPROPERTY(BlueprintAssignable, Category = \"Events\")\n\tFOnWaveCompleted OnWaveCompleted;\n\n\t/** Event fired when all waves complete */\n\tUPROPERTY(BlueprintAssignable, Category = \"Events\")\n\tFOnAllWavesCompleted OnAllWavesCompleted;\n};\n","Variant_Combat/AI/EnvQueryContext_Player.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"EnvQueryContext_Player.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"EnvironmentQuery/EnvQueryTypes.h\"\n#include \"EnvironmentQuery/Items/EnvQueryItemType_Actor.h\"\n#include \"GameFramework/Pawn.h\"\n\nvoid UEnvQueryContext_Player::ProvideContext(FEnvQueryInstance& QueryInstance, FEnvQueryContextData& ContextData) const\n{\n\t// get the player pawn for the first local player\n\tAActor* PlayerPawn = UGameplayStatics::GetPlayerPawn(QueryInstance.Owner.Get(), 0);\n\tcheck(PlayerPawn);\n\n\t// add the actor data to the context\n\tUEnvQueryItemType_Actor::SetContextHelper(ContextData, PlayerPawn);\n}\n","Variant_Combat/AI/EnvQueryContext_Player.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"EnvironmentQuery/EnvQueryContext.h\"\n#include \"EnvQueryContext_Player.generated.h\"\n\n/**\n *  UEnvQueryContext_Player\n *  Basic EnvQuery Context that returns the first local player\n */\nUCLASS()\nclass UEnvQueryContext_Player : public UEnvQueryContext\n{\n\tGENERATED_BODY()\n\t\npublic:\n\n\t/** Provides the context locations or actors for this EnvQuery */\n\tvirtual void ProvideContext(FEnvQueryInstance& QueryInstance, FEnvQueryContextData& ContextData) const override;\n};\n","Variant_Combat/AI/NinjaEnemy.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"NinjaEnemy.h\"\n\nANinjaEnemy::ANinjaEnemy()\n{\n\t// Slightly tougher default for ninja vs ninja feel\n\tMaxHP = 4.0f;\n\tCurrentHP = MaxHP;\n}\n","Variant_Combat/AI/NinjaEnemy.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Variant_Combat/AI/CombatEnemy.h\"\n#include \"NinjaEnemy.generated.h\"\n\n/**\n * Concrete enemy for wave spawner. Lock-on-able, takes damage, uses combo/charged attacks via AI.\n * Assign this (or a Blueprint child) as Wave Config Enemy Class in CombatWaveSpawner.\n */\nUCLASS(BlueprintType, Blueprintable)\nclass CPPd1_API ANinjaEnemy : public ACombatEnemy\n{\n\tGENERATED_BODY()\n\npublic:\n\tANinjaEnemy();\n};\n","Variant_Combat/AI/SpinningRadiusWaveSpawner.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"SpinningRadiusWaveSpawner.h\"\n#include \"Variant_Combat/AI/CombatWaveSpawner.h\"\n\nASpinningRadiusWaveSpawner::ASpinningRadiusWaveSpawner()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nFVector ASpinningRadiusWaveSpawner::GetSpawnLocation_Implementation()\n{\n\tconst float Rad = FMath::DegreesToRadians(CurrentSpawnAngle);\n\tconst FVector Offset(\n\t\tSpawnRadius * FMath::Cos(Rad),\n\t\tSpawnRadius * FMath::Sin(Rad),\n\t\tSpawnHeightOffset\n\t);\n\treturn GetActorLocation() + Offset;\n}\n\nvoid ASpinningRadiusWaveSpawner::OnSpawnLocationUsed_Implementation()\n{\n\tCurrentSpawnAngle += AngleStepPerSpawn;\n\tif (CurrentSpawnAngle >= 360.0f) CurrentSpawnAngle -= 360.0f;\n\tif (CurrentSpawnAngle < 0.0f) CurrentSpawnAngle += 360.0f;\n}\n","Variant_Combat/AI/SpinningRadiusWaveSpawner.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Variant_Combat/AI/CombatWaveSpawner.h\"\n#include \"SpinningRadiusWaveSpawner.generated.h\"\n\n/**\n * Wave spawner that spawns enemies on a circle around the actor. Each spawn advances the angle\n * so spawn points \"spin\" around the radius—great for marauders emerging from a zone.\n * Use Wave Configs and Enemy Class / Enemy Class Pool (e.g. TricksterMarauder, BruteMarauder) as with CombatWaveSpawner.\n */\nUCLASS(BlueprintType, Blueprintable)\nclass CPPd1_API ASpinningRadiusWaveSpawner : public ACombatWaveSpawner\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpinningRadiusWaveSpawner();\n\n\t/** Radius from this actor's location to spawn on the circle (cm). */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Spinning Radius\", meta = (ClampMin = 50.0f, Units = \"cm\"))\n\tfloat SpawnRadius = 400.0f;\n\n\t/** Degrees to advance the spawn angle after each spawn (e.g. 45 = 8 positions around the circle). */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Spinning Radius\", meta = (ClampMin = 1.0f, ClampMax = 360.0f, Units = \"deg\"))\n\tfloat AngleStepPerSpawn = 45.0f;\n\n\t/** Height offset from the circle plane (Z added to spawn position). */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Spinning Radius\", meta = (Units = \"cm\"))\n\tfloat SpawnHeightOffset = 90.0f;\n\n\tvirtual FVector GetSpawnLocation_Implementation() override;\n\tvirtual void OnSpawnLocationUsed_Implementation() override;\n\nprotected:\n\t/** Current angle in degrees for the next spawn (0 = +X, 90 = +Y in Unreal). */\n\tUPROPERTY()\n\tfloat CurrentSpawnAngle = 0.0f;\n};\n","Variant_Combat/AI/TricksterMarauder.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"TricksterMarauder.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n\nATricksterMarauder::ATricksterMarauder()\n{\n\tMaxHP = 2.0f;\n\tCurrentHP = MaxHP;\n\tMeleeDamage = 0.8f;\n\tMeleeTraceDistance = 60.0f;\n\t// Fast and hard to catch\n\tif (UCharacterMovementComponent* Move = GetCharacterMovement())\n\t\tMove->MaxWalkSpeed = 520.0f;\n}\n","Variant_Combat/AI/TricksterMarauder.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Variant_Combat/AI/CombatEnemy.h\"\n#include \"TricksterMarauder.generated.h\"\n\n/**\n * Marauder type: tricksters. Slippery, hard to catch—they dodge and feint; landing a hit feels earned.\n * Tuned: faster movement, lower HP. Use in wave configs / spinning radius spawner.\n */\nUCLASS(BlueprintType, Blueprintable)\nclass CPPd1_API ATricksterMarauder : public ACombatEnemy\n{\n\tGENERATED_BODY()\n\npublic:\n\tATricksterMarauder();\n};\n","Variant_Combat/Animation/AnimNotify_CheckChargedAttack.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"AnimNotify_CheckChargedAttack.h\"\n#include \"CombatAttacker.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n\nvoid UAnimNotify_CheckChargedAttack::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference)\n{\n\t// cast the owner to the attacker interface\n\tif (ICombatAttacker* AttackerInterface = Cast<ICombatAttacker>(MeshComp->GetOwner()))\n\t{\n\t\t// tell the actor to check for a charged attack loop\n\t\tAttackerInterface->CheckChargedAttack();\n\t}\n}\n\nFString UAnimNotify_CheckChargedAttack::GetNotifyName_Implementation() const\n{\n\treturn FString(\"Check Charged Attack\");\n}\n","Variant_Combat/Animation/AnimNotify_CheckChargedAttack.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Animation/AnimNotifies/AnimNotify.h\"\n#include \"AnimNotify_CheckChargedAttack.generated.h\"\n\n/**\n *  AnimNotify to perform a charged attack hold check.\n */\nUCLASS()\nclass UAnimNotify_CheckChargedAttack : public UAnimNotify\n{\n\tGENERATED_BODY()\n\t\npublic:\n\n\t/** Perform the Anim Notify */\n\tvirtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference) override;\n\n\t/** Get the notify name */\n\tvirtual FString GetNotifyName_Implementation() const override;\n};\n","Variant_Combat/Animation/AnimNotify_CheckCombo.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"AnimNotify_CheckCombo.h\"\n#include \"CombatAttacker.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n\nvoid UAnimNotify_CheckCombo::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference)\n{\n\t// cast the owner to the attacker interface\n\tif (ICombatAttacker* AttackerInterface = Cast<ICombatAttacker>(MeshComp->GetOwner()))\n\t{\n\t\t// tell the actor to check for combo string\n\t\tAttackerInterface->CheckCombo();\n\t}\n}\n\nFString UAnimNotify_CheckCombo::GetNotifyName_Implementation() const\n{\n\treturn FString(\"Check Combo String\");\n}\n","Variant_Combat/Animation/AnimNotify_CheckCombo.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Animation/AnimNotifies/AnimNotify.h\"\n#include \"AnimNotify_CheckCombo.generated.h\"\n\n/**\n *  AnimNotify to perform a combo string check.\n */\nUCLASS()\nclass UAnimNotify_CheckCombo : public UAnimNotify\n{\n\tGENERATED_BODY()\n\t\npublic:\n\n\t/** Perform the Anim Notify */\n\tvirtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference) override;\n\n\t/** Get the notify name */\n\tvirtual FString GetNotifyName_Implementation() const override;\n};\n","Variant_Combat/Animation/AnimNotify_DoAttackTrace.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"AnimNotify_DoAttackTrace.h\"\n#include \"CombatAttacker.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n\nvoid UAnimNotify_DoAttackTrace::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference)\n{\n\t// cast the owner to the attacker interface\n\tif (ICombatAttacker* AttackerInterface = Cast<ICombatAttacker>(MeshComp->GetOwner()))\n\t{\n\t\tAttackerInterface->DoAttackTrace(AttackBoneName);\n\t}\n}\n\nFString UAnimNotify_DoAttackTrace::GetNotifyName_Implementation() const\n{\n\treturn FString(\"Do Attack Trace\");\n}","Variant_Combat/Animation/AnimNotify_DoAttackTrace.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Animation/AnimNotifies/AnimNotify.h\"\n#include \"AnimNotify_DoAttackTrace.generated.h\"\n\n/**\n *  AnimNotify to tell the actor to perform an attack trace check to look for targets to damage.\n */\nUCLASS()\nclass UAnimNotify_DoAttackTrace : public UAnimNotify\n{\n\tGENERATED_BODY()\n\t\nprotected:\n\n\t/** Source bone for the attack trace */\n\tUPROPERTY(EditAnywhere, Category=\"Attack\")\n\tFName AttackBoneName;\n\npublic:\n\n\t/** Perform the Anim Notify */\n\tvirtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference) override;\n\n\t/** Get the notify name */\n\tvirtual FString GetNotifyName_Implementation() const override;\n};\n","Variant_Combat/CombatAdvancedMechanics.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CombatAdvancedMechanics.h\"\n#include \"CombatStaminaSystem.h\"\n#include \"CombatSkillSystem.h\"\n\nUCombatAdvancedMechanics::UCombatAdvancedMechanics()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UCombatAdvancedMechanics::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Drain stamina while blocking\n\tif (bIsBlocking)\n\t{\n\t\tif (UCombatStaminaSystem* StaminaSystem = GetOwner()->FindComponentByClass<UCombatStaminaSystem>())\n\t\t{\n\t\t\tStaminaSystem->DrainStamina(BlockStaminaDrain * DeltaTime);\n\t\t\t\n\t\t\t// Stop blocking if out of stamina\n\t\t\tif (StaminaSystem->IsExhausted())\n\t\t\t{\n\t\t\t\tStopBlocking();\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update parry timing\n\tif (ParryInputTime >= 0.0f)\n\t{\n\t\tParryInputTime += DeltaTime;\n\t\tif (ParryInputTime > GoodParryWindow)\n\t\t{\n\t\t\tParryInputTime = -1.0f;\n\t\t}\n\t}\n\n\t// Update counter-attack window\n\tif (bCanCounterAttack)\n\t{\n\t\tTimeSinceLastParry += DeltaTime;\n\t\tif (TimeSinceLastParry > CounterAttackWindow)\n\t\t{\n\t\t\tbCanCounterAttack = false;\n\t\t}\n\t}\n}\n\nEParryResult UCombatAdvancedMechanics::AttemptParry()\n{\n\tif (ParryInputTime < 0.0f)\n\t{\n\t\tParryInputTime = 0.0f;\n\t\treturn EParryResult::Missed;\n\t}\n\n\tif (ParryInputTime <= PerfectParryWindow)\n\t{\n\t\tbCanCounterAttack = true;\n\t\tTimeSinceLastParry = 0.0f;\n\t\tParryInputTime = -1.0f;\n\t\treturn EParryResult::Perfect;\n\t}\n\telse if (ParryInputTime <= GoodParryWindow)\n\t{\n\t\tbCanCounterAttack = true;\n\t\tTimeSinceLastParry = 0.0f;\n\t\tParryInputTime = -1.0f;\n\t\treturn EParryResult::Good;\n\t}\n\n\treturn EParryResult::Missed;\n}\n\nvoid UCombatAdvancedMechanics::StartBlocking()\n{\n\tbIsBlocking = true;\n}\n\nvoid UCombatAdvancedMechanics::StopBlocking()\n{\n\tbIsBlocking = false;\n}\n\nbool UCombatAdvancedMechanics::IsInParryWindow() const\n{\n\treturn ParryInputTime >= 0.0f && ParryInputTime <= GoodParryWindow;\n}\n\nvoid UCombatAdvancedMechanics::PerformCounterAttack()\n{\n\tif (bCanCounterAttack)\n\t{\n\t\t// Counter-attack logic would trigger attack with multiplier\n\t\tbCanCounterAttack = false;\n\t\tTimeSinceLastParry = -1.0f;\n\t}\n}\n\nfloat UCombatAdvancedMechanics::GetBlockEffectiveness() const\n{\n\tfloat Effectiveness = BaseBlockEffectiveness;\n\t\n\t// Improve with defense skill\n\tif (UCombatSkillSystem* SkillSystem = GetOwner()->FindComponentByClass<UCombatSkillSystem>())\n\t{\n\t\tEffectiveness = SkillSystem->GetDefenseEffectiveness();\n\t}\n\n\treturn Effectiveness;\n}\n\nvoid UCombatAdvancedMechanics::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n","Variant_Combat/CombatAdvancedMechanics.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CombatAdvancedMechanics.generated.h\"\n\n/** Parry timing window result */\nUENUM(BlueprintType)\nenum class EParryResult : uint8\n{\n\tMissed,\t\t\t// Too early/late\n\tPerfect,\t\t// Perfect timing\n\tGood,\t\t\t// Good timing\n\tLate\t\t\t// Late but still successful\n};\n\n/**\n * Advanced combat mechanics inspired by UFC 5\n * Handles parrying, blocking, counter-attacks, and timing-based mechanics\n */\nUCLASS(ClassGroup=(CPPd1), meta=(BlueprintSpawnableComponent))\nclass UCombatAdvancedMechanics : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\n\tUCombatAdvancedMechanics();\n\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\t/** Attempt to parry an incoming attack */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Advanced\")\n\tEParryResult AttemptParry();\n\n\t/** Start blocking */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Advanced\")\n\tvoid StartBlocking();\n\n\t/** Stop blocking */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Advanced\")\n\tvoid StopBlocking();\n\n\t/** Check if currently blocking */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Advanced\")\n\tbool IsBlocking() const { return bIsBlocking; }\n\n\t/** Check if in parry window */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Advanced\")\n\tbool IsInParryWindow() const;\n\n\t/** Perform a counter-attack after successful parry */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Advanced\")\n\tvoid PerformCounterAttack();\n\n\t/** Get block effectiveness (damage reduction) */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Advanced\")\n\tfloat GetBlockEffectiveness() const;\n\nprotected:\n\n\t/** Is currently blocking */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Combat|Advanced\")\n\tbool bIsBlocking = false;\n\n\t/** Parry window duration (perfect timing) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Advanced\")\n\tfloat PerfectParryWindow = 0.1f;\n\n\t/** Good parry window duration */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Advanced\")\n\tfloat GoodParryWindow = 0.2f;\n\n\t/** Time since parry input */\n\tfloat ParryInputTime = -1.0f;\n\n\t/** Block stamina drain per second */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Advanced\")\n\tfloat BlockStaminaDrain = 0.1f;\n\n\t/** Base block effectiveness (damage reduction) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Advanced\")\n\tfloat BaseBlockEffectiveness = 0.5f;\n\n\t/** Perfect parry damage multiplier */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Advanced\")\n\tfloat PerfectParryDamageMultiplier = 2.0f;\n\n\t/** Counter-attack window after parry */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Advanced\")\n\tfloat CounterAttackWindow = 1.0f;\n\n\t/** Time since last parry */\n\tfloat TimeSinceLastParry = -1.0f;\n\n\t/** Can perform counter-attack */\n\tbool bCanCounterAttack = false;\n\n\tvirtual void BeginPlay() override;\n};\n","Variant_Combat/CombatCharacter.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatCharacter.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"Components/WidgetComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"CombatLifeBar.h\"\n#include \"Engine/DamageEvents.h\"\n#include \"TimerManager.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"CombatPlayerController.h\"\n#include \"CPPd1LockOnTargetComponent.h\"\n#include \"CombatStaminaSystem.h\"\n#include \"CombatFlowSystem.h\"\n#include \"CombatAdvancedMechanics.h\"\n#include \"CombatSkillSystem.h\"\n\nACombatCharacter::ACombatCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// bind the attack montage ended delegate\n\tOnAttackMontageEnded.BindUObject(this, &ACombatCharacter::AttackMontageEnded);\n\n\t// Set size for collision capsule\n\tGetCapsuleComponent()->InitCapsuleSize(35.0f, 90.0f);\n\n\t// Configure character movement (will be overridden by tuning variables in BeginPlay)\n\tGetCharacterMovement()->MaxWalkSpeed = MovementSpeed;\n\tGetCharacterMovement()->JumpZVelocity = JumpVelocity;\n\tGetCharacterMovement()->AirControl = AirControl;\n\tGetCharacterMovement()->RotationRate = FRotator(0.0f, RotationRate, 0.0f);\n\n\t// create the camera boom\n\tCameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraBoom\"));\n\tCameraBoom->SetupAttachment(RootComponent);\n\n\tCameraBoom->TargetArmLength = DefaultCameraDistance;\n\tCameraBoom->bUsePawnControlRotation = true;\n\tCameraBoom->bEnableCameraLag = true;\n\tCameraBoom->bEnableCameraRotationLag = true;\n\n\t// create the orbiting camera\n\tFollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FollowCamera\"));\n\tFollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName);\n\tFollowCamera->bUsePawnControlRotation = false;\n\n\t// create the life bar widget component\n\tLifeBar = CreateDefaultSubobject<UWidgetComponent>(TEXT(\"LifeBar\"));\n\tLifeBar->SetupAttachment(RootComponent);\n\n\t// set the player tag\n\tTags.Add(FName(\"Player\"));\n}\n\nvoid ACombatCharacter::Move(const FInputActionValue& Value)\n{\n\t// input is a Vector2D\n\tFVector2D MovementVector = Value.Get<FVector2D>();\n\n\t// route the input\n\tDoMove(MovementVector.X, MovementVector.Y);\n}\n\nvoid ACombatCharacter::Look(const FInputActionValue& Value)\n{\n\tFVector2D LookAxisVector = Value.Get<FVector2D>();\n\n\t// route the input\n\tDoLook(LookAxisVector.X, LookAxisVector.Y);\n}\n\nvoid ACombatCharacter::ComboAttackPressed()\n{\n\t// route the input\n\tDoComboAttackStart();\n}\n\nvoid ACombatCharacter::ChargedAttackPressed()\n{\n\t// route the input\n\tDoChargedAttackStart();\n}\n\nvoid ACombatCharacter::ChargedAttackReleased()\n{\n\t// route the input\n\tDoChargedAttackEnd();\n}\n\nvoid ACombatCharacter::LockOnPressed()\n{\n\tif (LockOnTarget)\n\t{\n\t\tDoClearLockOn();\n\t}\n\telse\n\t{\n\t\tDoLockOn();\n\t}\n}\n\nvoid ACombatCharacter::DoLockOn()\n{\n\tTArray<AActor*> Targets;\n\tUCPPd1LockOnTargetComponent::FindLockOnTargetsInRadius(GetWorld(), GetActorLocation(), LockOnRadius, Targets);\n\tLockOnTarget = Targets.Num() > 0 ? Targets[0] : nullptr;\n\tif (GhostCharacter) GhostCharacter->DoLockOn();\n}\n\nvoid ACombatCharacter::DoClearLockOn()\n{\n\tLockOnTarget = nullptr;\n\tif (GhostCharacter) GhostCharacter->DoClearLockOn();\n}\n\nvoid ACombatCharacter::DoCycleLockOn()\n{\n\tTArray<AActor*> Targets;\n\tUCPPd1LockOnTargetComponent::FindLockOnTargetsInRadius(GetWorld(), GetActorLocation(), LockOnRadius, Targets);\n\tif (Targets.Num() == 0)\n\t{\n\t\tLockOnTarget = nullptr;\n\t\tif (GhostCharacter) GhostCharacter->DoCycleLockOn();\n\t\treturn;\n\t}\n\tint32 Index = Targets.IndexOfByKey(LockOnTarget);\n\tif (Index == INDEX_NONE) Index = -1;\n\tIndex = (Index + 1) % Targets.Num();\n\tLockOnTarget = Targets[Index];\n\tif (GhostCharacter) GhostCharacter->DoCycleLockOn();\n}\n\nvoid ACombatCharacter::SetGhostCharacter(ACombatCharacter* Ghost)\n{\n\tGhostCharacter = Ghost;\n}\n\nFRotator ACombatCharacter::GetEffectiveControlRotation() const\n{\n\tif (GetController())\n\t{\n\t\treturn GetController()->GetControlRotation();\n\t}\n\treturn StoredControlRotation;\n}\n\nvoid ACombatCharacter::DoMove(float Right, float Forward)\n{\n\tconst FRotator Rotation = GetEffectiveControlRotation();\n\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\n\tconst FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n\tconst FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n\tAddMovementInput(ForwardDirection, Forward);\n\tAddMovementInput(RightDirection, Right);\n\n\tif (GhostCharacter)\n\t{\n\t\tGhostCharacter->StoredControlRotation = Rotation;\n\t\tGhostCharacter->DoMove(Right, Forward);\n\t}\n}\n\nvoid ACombatCharacter::DoLook(float Yaw, float Pitch)\n{\n\tif (GetController() != nullptr)\n\t{\n\t\tAddControllerYawInput(Yaw);\n\t\tAddControllerPitchInput(Pitch);\n\t}\n\telse\n\t{\n\t\tStoredControlRotation.Yaw += Yaw;\n\t\tStoredControlRotation.Pitch += Pitch;\n\t\tStoredControlRotation.Pitch = FMath::Clamp(StoredControlRotation.Pitch, -89.f, 89.f);\n\t}\n\tif (GhostCharacter)\n\t{\n\t\tGhostCharacter->StoredControlRotation = GetEffectiveControlRotation();\n\t\tGhostCharacter->DoLook(Yaw, Pitch);\n\t}\n}\n\nvoid ACombatCharacter::DoComboAttackStart()\n{\n\t// are we already playing an attack animation?\n\tif (bIsAttacking)\n\t{\n\t\t// cache the input time so we can check it later\n\t\tCachedAttackInputTime = GetWorld()->GetTimeSeconds();\n\n\t\treturn;\n\t}\n\n\t// perform a combo attack\n\tComboAttack();\n\tif (GhostCharacter) GhostCharacter->DoComboAttackStart();\n}\n\nvoid ACombatCharacter::DoComboAttackEnd()\n{\n\tif (GhostCharacter) GhostCharacter->DoComboAttackEnd();\n}\n\nvoid ACombatCharacter::DoChargedAttackStart()\n{\n\t// raise the charging attack flag\n\tbIsChargingAttack = true;\n\n\tif (GhostCharacter) GhostCharacter->DoChargedAttackStart();\n\n\tif (bIsAttacking)\n\t{\n\t\t// cache the input time so we can check it later\n\t\tCachedAttackInputTime = GetWorld()->GetTimeSeconds();\n\n\t\treturn;\n\t}\n\n\tChargedAttack();\n}\n\nvoid ACombatCharacter::DoChargedAttackEnd()\n{\n\tbIsChargingAttack = false;\n\tif (GhostCharacter) GhostCharacter->DoChargedAttackEnd();\n\n\tif (bHasLoopedChargedAttack)\n\t{\n\t\tCheckChargedAttack();\n\t}\n}\n\nvoid ACombatCharacter::ResetHP()\n{\n\t// reset the current HP total\n\tCurrentHP = MaxHP;\n\n\t// update the life bar\n\tLifeBarWidget->SetLifePercentage(1.0f);\n}\n\nvoid ACombatCharacter::ComboAttack()\n{\n\t// raise the attacking flag\n\tbIsAttacking = true;\n\n\t// reset the combo count\n\tComboCount = 0;\n\n\t// play the attack montage\n\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t{\n\t\tconst float MontageLength = AnimInstance->Montage_Play(ComboAttackMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);\n\n\t\t// subscribe to montage completed and interrupted events\n\t\tif (MontageLength > 0.0f)\n\t\t{\n\t\t\t// set the end delegate for the montage\n\t\t\tAnimInstance->Montage_SetEndDelegate(OnAttackMontageEnded, ComboAttackMontage);\n\t\t}\n\t}\n\n}\n\nvoid ACombatCharacter::ChargedAttack()\n{\n\t// raise the attacking flag\n\tbIsAttacking = true;\n\n\t// reset the charge loop flag\n\tbHasLoopedChargedAttack = false;\n\n\t// play the charged attack montage\n\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t{\n\t\tconst float MontageLength = AnimInstance->Montage_Play(ChargedAttackMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);\n\n\t\t// subscribe to montage completed and interrupted events\n\t\tif (MontageLength > 0.0f)\n\t\t{\n\t\t\t// set the end delegate for the montage\n\t\t\tAnimInstance->Montage_SetEndDelegate(OnAttackMontageEnded, ChargedAttackMontage);\n\t\t}\n\t}\n}\n\nvoid ACombatCharacter::AttackMontageEnded(UAnimMontage* Montage, bool bInterrupted)\n{\n\t// reset the attacking flag\n\tbIsAttacking = false;\n\n\t// check if we have a non-stale cached input\n\tif (GetWorld()->GetTimeSeconds() - CachedAttackInputTime <= AttackInputCacheTimeTolerance)\n\t{\n\t\t// are we holding the charged attack button?\n\t\tif (bIsChargingAttack)\n\t\t{\n\t\t\t// do a charged attack\n\t\t\tChargedAttack();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// do a regular attack\n\t\t\tComboAttack();\n\t\t}\n\t}\n}\n\nvoid ACombatCharacter::DoAttackTrace(FName DamageSourceBone)\n{\n\t// sweep for objects in front of the character to be hit by the attack\n\tTArray<FHitResult> OutHits;\n\n\t// start at the provided socket location, sweep forward\n\tconst FVector TraceStart = GetMesh()->GetSocketLocation(DamageSourceBone);\n\tconst FVector TraceEnd = TraceStart + (GetActorForwardVector() * MeleeTraceDistance);\n\n\t// check for pawn and world dynamic collision object types\n\tFCollisionObjectQueryParams ObjectParams;\n\tObjectParams.AddObjectTypesToQuery(ECC_Pawn);\n\tObjectParams.AddObjectTypesToQuery(ECC_WorldDynamic);\n\n\t// use a sphere shape for the sweep\n\tFCollisionShape CollisionShape;\n\tCollisionShape.SetSphere(MeleeTraceRadius);\n\n\t// ignore self\n\tFCollisionQueryParams QueryParams;\n\tQueryParams.AddIgnoredActor(this);\n\n\tif (GetWorld()->SweepMultiByObjectType(OutHits, TraceStart, TraceEnd, FQuat::Identity, ObjectParams, CollisionShape, QueryParams))\n\t{\n\t\t// iterate over each object hit\n\t\tfor (const FHitResult& CurrentHit : OutHits)\n\t\t{\n\t\t\t// check if we've hit a damageable actor\n\t\t\tICombatDamageable* Damageable = Cast<ICombatDamageable>(CurrentHit.GetActor());\n\n\t\t\tif (Damageable)\n\t\t\t{\n\t\t\t\t// knock upwards and away from the impact normal\n\t\t\t\tconst FVector Impulse = (CurrentHit.ImpactNormal * -MeleeKnockbackImpulse) + (FVector::UpVector * MeleeLaunchImpulse);\n\n\t\t\t\t// Apply global damage multiplier\n\t\t\t\tfloat FinalDamage = MeleeDamage * GlobalDamageMultiplier;\n\n\t\t\t\t// pass the damage event to the actor\n\t\t\t\tDamageable->ApplyDamage(FinalDamage, this, CurrentHit.ImpactPoint, Impulse);\n\n\t\t\t\t// call the BP handler to play effects, etc.\n\t\t\t\tDealtDamage(FinalDamage, CurrentHit.ImpactPoint);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ACombatCharacter::CheckCombo()\n{\n\t// are we playing a non-charge attack animation?\n\tif (bIsAttacking && !bIsChargingAttack)\n\t{\n\t\t// is the last attack input not stale?\n\t\tif (GetWorld()->GetTimeSeconds() - CachedAttackInputTime <= ComboInputCacheTimeTolerance)\n\t\t{\n\t\t\t// consume the attack input so we don't accidentally trigger it twice\n\t\t\tCachedAttackInputTime = 0.0f;\n\n\t\t\t// increase the combo counter\n\t\t\t++ComboCount;\n\n\t\t\t// do we still have a combo section to play?\n\t\t\tif (ComboCount < ComboSectionNames.Num())\n\t\t\t{\n\t\t\t\t// jump to the next combo section\n\t\t\t\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t\t\t\t{\n\t\t\t\t\tAnimInstance->Montage_JumpToSection(ComboSectionNames[ComboCount], ComboAttackMontage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ACombatCharacter::CheckChargedAttack()\n{\n\t// raise the looped charged attack flag\n\tbHasLoopedChargedAttack = true;\n\n\t// jump to either the loop or the attack section depending on whether we're still holding the charge button\n\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t{\n\t\tAnimInstance->Montage_JumpToSection(bIsChargingAttack ? ChargeLoopSection : ChargeAttackSection, ChargedAttackMontage);\n\t}\n}\n\nvoid ACombatCharacter::ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse)\n{\n\t// pass the damage event to the actor\n\tFDamageEvent DamageEvent;\n\tconst float ActualDamage = TakeDamage(Damage, DamageEvent, nullptr, DamageCauser);\n\n\t// only process knockback and effects if we received nonzero damage\n\tif (ActualDamage > 0.0f)\n\t{\n\t\t// apply the knockback impulse\n\t\tGetCharacterMovement()->AddImpulse(DamageImpulse, true);\n\n\t\t// is the character ragdolling?\n\t\tif (GetMesh()->IsSimulatingPhysics())\n\t\t{\n\t\t\t// apply an impulse to the ragdoll\n\t\t\tGetMesh()->AddImpulseAtLocation(DamageImpulse * GetMesh()->GetMass(), DamageLocation);\n\t\t}\n\n\t\t// pass control to BP to play effects, etc.\n\t\tReceivedDamage(ActualDamage, DamageLocation, DamageImpulse.GetSafeNormal());\n\t}\n\n}\n\nvoid ACombatCharacter::HandleDeath()\n{\n\t// disable movement while we're dead\n\tGetCharacterMovement()->DisableMovement();\n\n\t// enable full ragdoll physics\n\tGetMesh()->SetSimulatePhysics(true);\n\n\t// hide the life bar\n\tLifeBar->SetHiddenInGame(true);\n\n\t// pull back the camera\n\tGetCameraBoom()->TargetArmLength = DeathCameraDistance;\n\n\t// schedule respawning\n\tGetWorld()->GetTimerManager().SetTimer(RespawnTimer, this, &ACombatCharacter::RespawnCharacter, RespawnTime, false);\n}\n\nvoid ACombatCharacter::ApplyHealing(float Healing, AActor* Healer)\n{\n\tif (bIsGhost || CurrentHP <= 0.0f) return;\n\tCurrentHP = FMath::Min(CurrentHP + Healing, MaxHP);\n\tif (LifeBarWidget)\n\t\tLifeBarWidget->SetLifePercentage(CurrentHP / MaxHP);\n}\n\nvoid ACombatCharacter::RespawnCharacter()\n{\n\t// destroy the character and let it be respawned by the Player Controller\n\tDestroy();\n}\n\nfloat ACombatCharacter::TakeDamage(float Damage, struct FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser)\n{\n\t// ghosts don't take damage\n\tif (bIsGhost)\n\t{\n\t\treturn 0.0f;\n\t}\n\n\t// Check invincibility frames\n\tif (TimeSinceLastDamage < InvincibilityFrames)\n\t{\n\t\treturn 0.0f;\n\t}\n\n\t// Apply global defense multiplier\n\tDamage *= GlobalDefenseMultiplier;\n\n\t// only process damage if the character is still alive\n\tif (CurrentHP <= 0.0f)\n\t{\n\t\treturn 0.0f;\n\t}\n\n\t// reduce the current HP\n\tCurrentHP -= Damage;\n\n\t// have we run out of HP?\n\tif (CurrentHP <= 0.0f)\n\t{\n\t\t// die\n\t\tHandleDeath();\n\t}\n\telse\n\t{\n\t\t// update the life bar\n\t\tLifeBarWidget->SetLifePercentage(CurrentHP / MaxHP);\n\n\t\t// enable partial ragdoll physics, but keep the pelvis vertical\n\t\tGetMesh()->SetPhysicsBlendWeight(0.5f);\n\t\tGetMesh()->SetBodySimulatePhysics(PelvisBoneName, false);\n\t}\n\n\t// Reset invincibility timer\n\tTimeSinceLastDamage = 0.0f;\n\n\t// return the received damage amount\n\treturn Damage;\n}\n\nvoid ACombatCharacter::Landed(const FHitResult& Hit)\n{\n\tSuper::Landed(Hit);\n\n\t// is the character still alive?\n\tif (CurrentHP >= 0.0f)\n\t{\n\t\t// disable ragdoll physics\n\t\tGetMesh()->SetPhysicsBlendWeight(0.0f);\n\t}\n}\n\nvoid ACombatCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Apply tuning variables to character movement\n\tGetCharacterMovement()->MaxWalkSpeed = MovementSpeed;\n\tGetCharacterMovement()->JumpZVelocity = JumpVelocity;\n\tGetCharacterMovement()->AirControl = AirControl;\n\tGetCharacterMovement()->RotationRate = FRotator(0.0f, RotationRate, 0.0f);\n\n\t// get the life bar from the widget component\n\tLifeBarWidget = Cast<UCombatLifeBar>(LifeBar->GetUserWidgetObject());\n\tcheck(LifeBarWidget);\n\n\t// initialize the camera\n\tGetCameraBoom()->TargetArmLength = DefaultCameraDistance;\n\n\t// save the relative transform for the mesh so we can reset the ragdoll later\n\tMeshStartingTransform = GetMesh()->GetRelativeTransform();\n\n\t// set the life bar color\n\tLifeBarWidget->SetBarColor(LifeBarColor);\n\n\t// reset HP to maximum\n\tResetHP();\n\n\t// Initialize tuning variables for component systems\n\tInitializeTuningVariables();\n\n\tif (bIsGhost)\n\t{\n\t\tif (LifeBar) LifeBar->SetHiddenInGame(true);\n\t\tif (CameraBoom) CameraBoom->SetHiddenInGame(true);\n\t\tif (FollowCamera) FollowCamera->SetHiddenInGame(true);\n\t}\n}\n\nvoid ACombatCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\t// Update invincibility frames\n\tTimeSinceLastDamage += DeltaTime;\n\n\t// Keep ghost's control rotation in sync when we have a ghost (solo 2P)\n\tif (GhostCharacter && GetController())\n\t{\n\t\tGhostCharacter->StoredControlRotation = GetController()->GetControlRotation();\n\t}\n\t// Handle lock-on rotation\n\tif (LockOnTarget && CurrentHP > 0.0f && GetController())\n\t{\n\t\tUCPPd1LockOnTargetComponent* Comp = LockOnTarget->FindComponentByClass<UCPPd1LockOnTargetComponent>();\n\t\tif (Comp)\n\t\t{\n\t\t\tFVector TargetLoc = Comp->GetLockOnWorldLocation();\n\t\t\tFVector ToTarget = (TargetLoc - GetActorLocation()).GetSafeNormal2D();\n\t\t\tif (ToTarget.IsNearlyZero() == false)\n\t\t\t{\n\t\t\t\tFRotator DesiredYaw = ToTarget.Rotation();\n\t\t\t\tDesiredYaw.Pitch = 0.f;\n\t\t\t\tDesiredYaw.Roll = 0.f;\n\t\t\t\tFRotator Current = GetController()->GetControlRotation();\n\t\t\t\tCurrent.Pitch = 0.f;\n\t\t\t\tCurrent.Roll = 0.f;\n\t\t\t\tFRotator NewRot = FMath::RInterpTo(Current, DesiredYaw, DeltaTime, LockOnRotationSpeed / 360.f);\n\t\t\t\tGetController()->SetControlRotation(FRotator(GetController()->GetControlRotation().Pitch, NewRot.Yaw, NewRot.Roll));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLockOnTarget = nullptr;\n\t\t}\n\t}\n}\n\nvoid ACombatCharacter::InitializeTuningVariables()\n{\n\t// Initialize component systems with tuning variables if they exist\n\t// This allows the tuning variables to be set in the inspector and applied to components\n\t\n\t// Stamina System\n\tif (UCombatStaminaSystem* StaminaSystem = FindComponentByClass<UCombatStaminaSystem>())\n\t{\n\t\t// Note: These would need setters in the component, or we set them via reflection\n\t\t// For now, the component uses its own defaults, but you can override in Blueprint\n\t}\n\n\t// Flow System\n\tif (UCombatFlowSystem* FlowSystem = FindComponentByClass<UCombatFlowSystem>())\n\t{\n\t\t// Same note as above\n\t}\n\n\t// Advanced Mechanics\n\tif (UCombatAdvancedMechanics* AdvancedMech = FindComponentByClass<UCombatAdvancedMechanics>())\n\t{\n\t\t// Same note as above\n\t}\n\n\t// Skill System\n\tif (UCombatSkillSystem* SkillSystem = FindComponentByClass<UCombatSkillSystem>())\n\t{\n\t\t// Same note as above\n\t}\n}\n\nvoid ACombatCharacter::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\t// clear the respawn timer\n\tGetWorld()->GetTimerManager().ClearTimer(RespawnTimer);\n}\n\nvoid ACombatCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Set up action bindings\n\tif (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))\n\t{\n\t\t// Moving\n\t\tEnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &ACombatCharacter::Move);\n\n\t\t// Looking\n\t\tEnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &ACombatCharacter::Look);\n\t\tEnhancedInputComponent->BindAction(MouseLookAction, ETriggerEvent::Triggered, this, &ACombatCharacter::Look);\n\n\t\t// Combo Attack\n\t\tEnhancedInputComponent->BindAction(ComboAttackAction, ETriggerEvent::Started, this, &ACombatCharacter::ComboAttackPressed);\n\n\t\t// Charged Attack\n\t\tEnhancedInputComponent->BindAction(ChargedAttackAction, ETriggerEvent::Started, this, &ACombatCharacter::ChargedAttackPressed);\n\t\tEnhancedInputComponent->BindAction(ChargedAttackAction, ETriggerEvent::Completed, this, &ACombatCharacter::ChargedAttackReleased);\n\n\t\t// Lock-On\n\t\tEnhancedInputComponent->BindAction(LockOnAction, ETriggerEvent::Started, this, &ACombatCharacter::LockOnPressed);\n\t}\n}\n\nvoid ACombatCharacter::NotifyControllerChanged()\n{\n\tSuper::NotifyControllerChanged();\n\n\t// update the respawn transform on the Player Controller\n\tif (ACombatPlayerController* PC = Cast<ACombatPlayerController>(GetController()))\n\t{\n\t\tPC->SetRespawnTransform(GetActorTransform());\n\t}\n}\n\n","Variant_Combat/CombatCharacter.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"CombatAttacker.h\"\n#include \"CombatDamageable.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"CombatCharacter.generated.h\"\n\nclass USpringArmComponent;\nclass UCameraComponent;\nclass UInputAction;\nstruct FInputActionValue;\nclass UCombatLifeBar;\nclass UWidgetComponent;\n\nDECLARE_LOG_CATEGORY_EXTERN(LogCombatCharacter, Log, All);\n\n/**\n *  An enhanced Third Person Character with melee combat capabilities:\n *  - Combo attack string\n *  - Press and hold charged attack\n *  - Damage dealing and reaction\n *  - Death\n *  - Respawning\n */\nUCLASS(BlueprintType, Blueprintable)\nclass ACombatCharacter : public ACharacter, public ICombatAttacker, public ICombatDamageable\n{\n\tGENERATED_BODY()\n\n\t/** Camera boom positioning the camera behind the character */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUSpringArmComponent* CameraBoom;\n\n\t/** Follow camera */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUCameraComponent* FollowCamera;\n\n\t/** Life bar widget component */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUWidgetComponent* LifeBar;\n\t\nprotected:\n\n\t/** Jump Input Action */\n\tUPROPERTY(EditAnywhere, Category =\"Input\")\n\tUInputAction* JumpAction;\n\n\t/** Move Input Action */\n\tUPROPERTY(EditAnywhere, Category =\"Input\")\n\tUInputAction* MoveAction;\n\n\t/** Look Input Action */\n\tUPROPERTY(EditAnywhere, Category =\"Input\")\n\tUInputAction* LookAction;\n\n\t/** Mouse Look Input Action */\n\tUPROPERTY(EditAnywhere, Category=\"Input\")\n\tUInputAction* MouseLookAction;\n\n\t/** Combo Attack Input Action */\n\tUPROPERTY(EditAnywhere, Category =\"Input\")\n\tUInputAction* ComboAttackAction;\n\n\t/** Charged Attack Input Action */\n\tUPROPERTY(EditAnywhere, Category =\"Input\")\n\tUInputAction* ChargedAttackAction;\n\n\t/** Lock-On Input Action (toggle or hold) */\n\tUPROPERTY(EditAnywhere, Category =\"Input\")\n\tUInputAction* LockOnAction;\n\n\t/** Lock-on: search radius for targets */\n\tUPROPERTY(EditAnywhere, Category =\"Lock-On\", meta = (ClampMin = 0, Units = \"cm\"))\n\tfloat LockOnRadius = 1500.0f;\n\n\t/** Lock-on: rotation blend speed toward target */\n\tUPROPERTY(EditAnywhere, Category =\"Lock-On\", meta = (ClampMin = 0, Units = \"deg/s\"))\n\tfloat LockOnRotationSpeed = 360.0f;\n\n\t/** Current lock-on target (enemy or other actor with CPPd1LockOnTargetComponent) */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =\"Lock-On\")\n\tTObjectPtr<AActor> LockOnTarget;\n\n\t/** Ghost character that mirrors this one when playing solo (this drives it with the same input). */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =\"CPPd1|Ghost\")\n\tTObjectPtr<ACombatCharacter> GhostCharacter;\n\npublic:\n\n\t/** When true, this is a ghost copy (solo 2P); takes no damage and mirrors the main character. */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =\"CPPd1|Ghost\")\n\tbool bIsGhost = false;\n\n\t/** Control rotation used when not possessed (e.g. ghost mirroring main). */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =\"CPPd1|Ghost\")\n\tFRotator StoredControlRotation;\n\nprotected:\n\n\t/** Max amount of HP the character will have on respawn */\n\tUPROPERTY(EditAnywhere, Category=\"Damage\", meta = (ClampMin = 0, ClampMax = 100))\n\tfloat MaxHP = 5.0f;\n\n\t/** Current amount of HP the character has */\n\tUPROPERTY(VisibleAnywhere, Category=\"Damage\")\n\tfloat CurrentHP = 0.0f;\n\n\t/** Life bar widget fill color */\n\tUPROPERTY(EditAnywhere, Category=\"Damage\")\n\tFLinearColor LifeBarColor;\n\n\t/** Name of the pelvis bone, for damage ragdoll physics */\n\tUPROPERTY(EditAnywhere, Category=\"Damage\")\n\tFName PelvisBoneName;\n\n\t/** Pointer to the life bar widget */\n\tUPROPERTY(EditAnywhere, Category=\"Damage\")\n\tTObjectPtr<UCombatLifeBar> LifeBarWidget;\n\n\t/** Max amount of time that may elapse for a non-combo attack input to not be considered stale */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack\", meta = (ClampMin = 0, ClampMax = 5, Units = \"s\"))\n\tfloat AttackInputCacheTimeTolerance = 1.0f;\n\n\t/** Time at which an attack button was last pressed */\n\tfloat CachedAttackInputTime = 0.0f;\n\n\t/** If true, the character is currently playing an attack animation */\n\tbool bIsAttacking = false;\n\n\t/** Distance ahead of the character that melee attack sphere collision traces will extend */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Trace\", meta = (ClampMin = 0, ClampMax = 500, Units=\"cm\"))\n\tfloat MeleeTraceDistance = 75.0f;\n\n\t/** Radius of the sphere trace for melee attacks */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Trace\", meta = (ClampMin = 0, ClampMax = 200, Units = \"cm\"))\n\tfloat MeleeTraceRadius = 75.0f;\n\n\t/** Amount of damage a melee attack will deal */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Damage\", meta = (ClampMin = 0, ClampMax = 100))\n\tfloat MeleeDamage = 1.0f;\n\n\t/** Amount of knockback impulse a melee attack will apply */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Damage\", meta = (ClampMin = 0, ClampMax = 1000, Units = \"cm/s\"))\n\tfloat MeleeKnockbackImpulse = 250.0f;\n\n\t/** Amount of upwards impulse a melee attack will apply */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Damage\", meta = (ClampMin = 0, ClampMax = 1000, Units = \"cm/s\"))\n\tfloat MeleeLaunchImpulse = 300.0f;\n\n\t/** AnimMontage that will play for combo attacks */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Combo\")\n\tUAnimMontage* ComboAttackMontage;\n\n\t/** Names of the AnimMontage sections that correspond to each stage of the combo attack */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Combo\")\n\tTArray<FName> ComboSectionNames;\n\n\t/** Max amount of time that may elapse for a combo attack input to not be considered stale */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Combo\", meta = (ClampMin = 0, ClampMax = 5, Units = \"s\"))\n\tfloat ComboInputCacheTimeTolerance = 0.45f;\n\n\t/** Index of the current stage of the melee attack combo */\n\tint32 ComboCount = 0;\n\n\t/** AnimMontage that will play for charged attacks */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Charged\")\n\tUAnimMontage* ChargedAttackMontage;\n\n\t/** Name of the AnimMontage section that corresponds to the charge loop */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Charged\")\n\tFName ChargeLoopSection;\n\n\t/** Name of the AnimMontage section that corresponds to the attack */\n\tUPROPERTY(EditAnywhere, Category=\"Melee Attack|Charged\")\n\tFName ChargeAttackSection;\n\n\t/** Flag that determines if the player is currently holding the charged attack input */\n\tbool bIsChargingAttack = false;\n\t\n\t/** If true, the charged attack hold check has been tested at least once */\n\tbool bHasLoopedChargedAttack = false;\n\n\t/** Camera boom length while the character is dead */\n\tUPROPERTY(EditAnywhere, Category=\"Camera\", meta = (ClampMin = 0, ClampMax = 1000, Units = \"cm\"))\n\tfloat DeathCameraDistance = 400.0f;\n\n\t/** Camera boom length when the character respawns */\n\tUPROPERTY(EditAnywhere, Category=\"Camera\", meta = (ClampMin = 0, ClampMax = 1000, Units = \"cm\"))\n\tfloat DefaultCameraDistance = 100.0f;\n\n\t/** Time to wait before respawning the character */\n\tUPROPERTY(EditAnywhere, Category=\"Respawn\", meta = (ClampMin = 0, ClampMax = 10, Units = \"s\"))\n\tfloat RespawnTime = 3.0f;\n\n\t// ========== TUNING VARIABLES - EXPOSED FOR INSPECTOR ==========\n\n\t/** Character movement speed (walk speed) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Movement\", meta = (ClampMin = 0, Units = \"cm/s\"))\n\tfloat MovementSpeed = 400.0f;\n\n\t/** Character jump velocity */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Movement\", meta = (ClampMin = 0, Units = \"cm/s\"))\n\tfloat JumpVelocity = 500.0f;\n\n\t/** Air control amount (0.0 = no control, 1.0 = full control) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Movement\", meta = (ClampMin = 0.0f, ClampMax = 1.0f))\n\tfloat AirControl = 0.35f;\n\n\t/** Character rotation rate (how fast character turns) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Movement\", meta = (ClampMin = 0, Units = \"deg/s\"))\n\tfloat RotationRate = 500.0f;\n\n\t// Trick System Tuning\n\t/** Maximum time between trick inputs to maintain combo (in seconds) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Trick System\", meta = (ClampMin = 0.0f, ClampMax = 2.0f, Units = \"s\"))\n\tfloat TrickInputGapTime = 0.5f;\n\n\t/** Base flow points awarded for any trick */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Trick System\", meta = (ClampMin = 0.0f))\n\tfloat BaseTrickFlowPoints = 10.0f;\n\n\t/** Flow point multiplier for complex tricks */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Trick System\", meta = (ClampMin = 1.0f))\n\tfloat ComplexTrickMultiplier = 1.5f;\n\n\t// Skill System Tuning\n\t/** Starting skill level for all skills (0-100) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Skill System\", meta = (ClampMin = 0.0f, ClampMax = 100.0f))\n\tfloat StartingSkillLevel = 0.0f;\n\n\t/** Experience multiplier for skill gains (1.0 = normal, 2.0 = double) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Skill System\", meta = (ClampMin = 0.1f, ClampMax = 10.0f))\n\tfloat SkillExperienceMultiplier = 1.0f;\n\n\t/** Base damage multiplier at skill level 0 */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Skill System\", meta = (ClampMin = 0.1f))\n\tfloat BaseDamageMultiplier = 0.5f;\n\n\t/** Maximum damage multiplier at skill level 100 */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Skill System\", meta = (ClampMin = 1.0f))\n\tfloat MaxDamageMultiplier = 2.0f;\n\n\t// Stamina System Tuning\n\t/** Maximum stamina (0.0 to 1.0) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Stamina\", meta = (ClampMin = 0.0f, ClampMax = 1.0f))\n\tfloat MaxStamina = 1.0f;\n\n\t/** Stamina drain per light attack */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Stamina\", meta = (ClampMin = 0.0f, ClampMax = 1.0f))\n\tfloat LightAttackStaminaCost = 0.10f;\n\n\t/** Stamina drain per heavy attack */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Stamina\", meta = (ClampMin = 0.0f, ClampMax = 1.0f))\n\tfloat HeavyAttackStaminaCost = 0.25f;\n\n\t/** Stamina drain per second while blocking */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Stamina\", meta = (ClampMin = 0.0f, ClampMax = 1.0f))\n\tfloat BlockStaminaDrainRate = 0.15f;\n\n\t/** Base stamina recovery rate per second */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Stamina\", meta = (ClampMin = 0.0f))\n\tfloat BaseStaminaRecoveryRate = 0.2f;\n\n\t/** Time delay before stamina starts recovering after drain */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Stamina\", meta = (ClampMin = 0.0f, Units = \"s\"))\n\tfloat StaminaRecoveryDelay = 1.0f;\n\n\t/** Stamina threshold for exhaustion (below this = exhausted) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Stamina\", meta = (ClampMin = 0.0f, ClampMax = 1.0f))\n\tfloat ExhaustionThreshold = 0.2f;\n\n\t// Flow System Tuning\n\t/** Maximum flow meter (0.0 to 1.0) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Flow System\", meta = (ClampMin = 0.0f, ClampMax = 1.0f))\n\tfloat MaxFlow = 1.0f;\n\n\t/** Flow decay rate per second */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Flow System\", meta = (ClampMin = 0.0f))\n\tfloat FlowDecayRate = 0.1f;\n\n\t/** Flow threshold to enter flow state (0.0 to 1.0) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Flow System\", meta = (ClampMin = 0.0f, ClampMax = 1.0f))\n\tfloat FlowStateThreshold = 0.7f;\n\n\t/** Damage/speed multiplier when in flow state */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Flow System\", meta = (ClampMin = 1.0f))\n\tfloat FlowStateMultiplier = 1.5f;\n\n\t/** Flow points per combo hit */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Flow System\", meta = (ClampMin = 0.0f))\n\tfloat FlowPointsPerCombo = 5.0f;\n\n\t/** Time before combo resets (in seconds) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Flow System\", meta = (ClampMin = 0.0f, Units = \"s\"))\n\tfloat ComboResetTime = 3.0f;\n\n\t// Advanced Mechanics Tuning\n\t/** Perfect parry window duration (in seconds) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Advanced Mechanics\", meta = (ClampMin = 0.0f, ClampMax = 1.0f, Units = \"s\"))\n\tfloat PerfectParryWindow = 0.1f;\n\n\t/** Good parry window duration (in seconds) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Advanced Mechanics\", meta = (ClampMin = 0.0f, ClampMax = 1.0f, Units = \"s\"))\n\tfloat GoodParryWindow = 0.2f;\n\n\t/** Perfect parry damage multiplier */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Advanced Mechanics\", meta = (ClampMin = 1.0f))\n\tfloat PerfectParryDamageMultiplier = 2.0f;\n\n\t/** Counter-attack window after parry (in seconds) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Advanced Mechanics\", meta = (ClampMin = 0.0f, Units = \"s\"))\n\tfloat CounterAttackWindow = 1.0f;\n\n\t/** Base block effectiveness (damage reduction, 0.0 to 1.0) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Advanced Mechanics\", meta = (ClampMin = 0.0f, ClampMax = 1.0f))\n\tfloat BaseBlockEffectiveness = 0.5f;\n\n\t// General Combat Tuning\n\t/** Global damage multiplier (affects all damage dealt) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Combat\", meta = (ClampMin = 0.0f))\n\tfloat GlobalDamageMultiplier = 1.0f;\n\n\t/** Global defense multiplier (affects all damage received) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Combat\", meta = (ClampMin = 0.0f))\n\tfloat GlobalDefenseMultiplier = 1.0f;\n\n\t/** Invincibility frames after taking damage (in seconds) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tuning|Combat\", meta = (ClampMin = 0.0f, Units = \"s\"))\n\tfloat InvincibilityFrames = 0.5f;\n\n\t/** Time since last damage taken */\n\tfloat TimeSinceLastDamage = 0.0f;\n\n\t/** Attack montage ended delegate */\n\tFOnMontageEnded OnAttackMontageEnded;\n\n\t/** Character respawn timer */\n\tFTimerHandle RespawnTimer;\n\n\t/** Copy of the mesh's transform so we can reset it after ragdoll animations */\n\tFTransform MeshStartingTransform;\n\npublic:\n\t\n\t/** Constructor */\n\tACombatCharacter();\n\nprotected:\n\n\t/** Called for movement input */\n\tvoid Move(const FInputActionValue& Value);\n\n\t/** Called for looking input */\n\tvoid Look(const FInputActionValue& Value);\n\n\t/** Called for combo attack input */\n\tvoid ComboAttackPressed();\n\n\t/** Called for combo attack input pressed */\n\tvoid ChargedAttackPressed();\n\n\t/** Called for combo attack input released */\n\tvoid ChargedAttackReleased();\n\n\t/** Called when lock-on input is triggered */\n\tvoid LockOnPressed();\n\npublic:\n\n\t/** Handles move inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoMove(float Right, float Forward);\n\n\t/** Handles look inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoLook(float Yaw, float Pitch);\n\n\t/** Handles combo attack pressed from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoComboAttackStart();\n\n\t/** Handles combo attack released from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoComboAttackEnd();\n\n\t/** Handles charged attack pressed from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoChargedAttackStart();\n\n\t/** Handles charged attack released from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoChargedAttackEnd();\n\n\t/** Lock on to nearest valid target in radius. */\n\tUFUNCTION(BlueprintCallable, Category=\"Lock-On\")\n\tvirtual void DoLockOn();\n\n\t/** Clear current lock-on target. */\n\tUFUNCTION(BlueprintCallable, Category=\"Lock-On\")\n\tvirtual void DoClearLockOn();\n\n\t/** Cycle to next lock-on target in radius (or clear if none). */\n\tUFUNCTION(BlueprintCallable, Category=\"Lock-On\")\n\tvirtual void DoCycleLockOn();\n\n\t/** Set the ghost character that mirrors this one (solo play). Ghost receives the same input. */\n\tUFUNCTION(BlueprintCallable, Category=\"CPPd1|Ghost\")\n\tvirtual void SetGhostCharacter(ACombatCharacter* Ghost);\n\n\t/** Get the ghost character (if any). */\n\tUFUNCTION(BlueprintPure, Category=\"CPPd1|Ghost\")\n\tACombatCharacter* GetGhostCharacter() const { return GhostCharacter; }\n\n\t/** Get control rotation (from controller or StoredControlRotation when unpossessed). */\n\tUFUNCTION(BlueprintPure, Category=\"CPPd1|Ghost\")\n\tFRotator GetEffectiveControlRotation() const;\n\nprotected:\n\n\t/** Resets the character's current HP to maximum */\n\tvoid ResetHP();\n\n\t/** Performs a combo attack */\n\tvoid ComboAttack();\n\n\t/** Performs a charged attack */\n\tvoid ChargedAttack();\n\n\t/** Called from a delegate when the attack montage ends */\n\tvoid AttackMontageEnded(UAnimMontage* Montage, bool bInterrupted);\n\n\t\npublic:\n\n\t// ~begin CombatAttacker interface\n\n\t/** Performs the collision check for an attack */\n\tvirtual void DoAttackTrace(FName DamageSourceBone) override;\n\n\t/** Performs the combo string check */\n\tvirtual void CheckCombo() override;\n\n\t/** Performs the charged attack hold check */\n\tvirtual void CheckChargedAttack() override;\n\n\t// ~end CombatAttacker interface\n\n\t// ~begin CombatDamageable interface\n\n\t/** Handles damage and knockback events */\n\tvirtual void ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse) override;\n\n\t/** Handles death events */\n\tvirtual void HandleDeath() override;\n\n\t/** Handles healing events */\n\tvirtual void ApplyHealing(float Healing, AActor* Healer) override;\n\n\t// ~end CombatDamageable interface\n\n\t/** Called from the respawn timer to destroy and re-create the character */\n\tvoid RespawnCharacter();\n\npublic:\n\n\t/** Overrides the default TakeDamage functionality */\n\tvirtual float TakeDamage(float Damage, struct FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser) override;\n\n\t/** Overrides landing to reset damage ragdoll physics */\n\tvirtual void Landed(const FHitResult& Hit) override;\n\nprotected:\n\n\t/** Blueprint handler to play damage dealt effects */\n\tUFUNCTION(BlueprintImplementableEvent, Category=\"Combat\")\n\tvoid DealtDamage(float Damage, const FVector& ImpactPoint);\n\n\t/** Blueprint handler to play damage received effects */\n\tUFUNCTION(BlueprintImplementableEvent, Category=\"Combat\")\n\tvoid ReceivedDamage(float Damage, const FVector& ImpactPoint, const FVector& DamageDirection);\n\nprotected:\n\n\t/** Initialization */\n\tvirtual void BeginPlay() override;\n\n\t/** Called every frame */\n\tvirtual void Tick(float DeltaTime) override;\n\n\t/** Initialize tuning variables for component systems */\n\tvoid InitializeTuningVariables();\n\n\t/** Cleanup */\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n\n\t/** Handles input bindings */\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t/** Handles possessed initialization */\n\tvirtual void NotifyControllerChanged() override;\n\npublic:\n\n\t/** Returns CameraBoom subobject **/\n\tFORCEINLINE class USpringArmComponent* GetCameraBoom() const { return CameraBoom; }\n\n\t/** Returns FollowCamera subobject **/\n\tFORCEINLINE class UCameraComponent* GetFollowCamera() const { return FollowCamera; }\n};\n","Variant_Combat/CombatFlowSystem.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CombatFlowSystem.h\"\n\nUCombatFlowSystem::UCombatFlowSystem()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCurrentFlow = 0.0f;\n}\n\nvoid UCombatFlowSystem::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Decay flow over time\n\tif (CurrentFlow > 0.0f)\n\t{\n\t\tCurrentFlow = FMath::Max(0.0f, CurrentFlow - (FlowDecayRate * DeltaTime));\n\t}\n\n\t// Reset combo if too much time has passed\n\tTimeSinceLastCombo += DeltaTime;\n\tif (TimeSinceLastCombo > ComboResetTime && ComboCount > 0)\n\t{\n\t\tResetCombo();\n\t}\n}\n\nvoid UCombatFlowSystem::AddFlowPoints(float Amount)\n{\n\tCurrentFlow = FMath::Min(MaxFlow, CurrentFlow + Amount);\n}\n\nfloat UCombatFlowSystem::GetFlowMultiplier() const\n{\n\tif (IsInFlowState())\n\t{\n\t\treturn FlowStateMultiplier;\n\t}\n\treturn 1.0f;\n}\n\nvoid UCombatFlowSystem::IncrementCombo()\n{\n\tComboCount++;\n\tTimeSinceLastCombo = 0.0f;\n\t\n\t// Add flow points for combos\n\tAddFlowPoints(0.05f * ComboCount); // More flow for longer combos\n}\n\nvoid UCombatFlowSystem::ResetCombo()\n{\n\tComboCount = 0;\n\tTimeSinceLastCombo = 0.0f;\n}\n\nvoid UCombatFlowSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n","Variant_Combat/CombatFlowSystem.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CombatFlowSystem.generated.h\"\n\n/**\n * Flow/Style meter system inspired by Skate 4\n * Tracks combo chains, style points, and flow state\n */\nUCLASS(ClassGroup=(CPPd1), meta=(BlueprintSpawnableComponent))\nclass UCombatFlowSystem : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\n\tUCombatFlowSystem();\n\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\t/** Add flow points (from tricks, combos, style moves) */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Flow\")\n\tvoid AddFlowPoints(float Amount);\n\n\t/** Get current flow meter (0.0 to 1.0) */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Flow\")\n\tfloat GetFlowMeter() const { return CurrentFlow; }\n\n\t/** Get flow percentage (0-100) */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Flow\")\n\tfloat GetFlowPercentage() const { return CurrentFlow * 100.0f; }\n\n\t/** Check if in flow state (high flow meter) */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Flow\")\n\tbool IsInFlowState() const { return CurrentFlow >= FlowStateThreshold; }\n\n\t/** Get flow multiplier (affects damage, speed, etc.) */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Flow\")\n\tfloat GetFlowMultiplier() const;\n\n\t/** Get current combo count */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Flow\")\n\tint32 GetComboCount() const { return ComboCount; }\n\n\t/** Increment combo count */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Flow\")\n\tvoid IncrementCombo();\n\n\t/** Reset combo count */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Flow\")\n\tvoid ResetCombo();\n\nprotected:\n\n\t/** Maximum flow */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Flow\", meta = (ClampMin = 0.0f, ClampMax = 1.0f))\n\tfloat MaxFlow = 1.0f;\n\n\t/** Current flow */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Combat|Flow\", meta = (ClampMin = 0.0f, ClampMax = 1.0f))\n\tfloat CurrentFlow = 0.0f;\n\n\t/** Flow decay rate per second */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Flow\")\n\tfloat FlowDecayRate = 0.1f;\n\n\t/** Flow threshold for flow state */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Flow\", meta = (ClampMin = 0.0f, ClampMax = 1.0f))\n\tfloat FlowStateThreshold = 0.7f;\n\n\t/** Flow multiplier when in flow state */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Flow\")\n\tfloat FlowStateMultiplier = 1.5f;\n\n\t/** Current combo count */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Combat|Flow\")\n\tint32 ComboCount = 0;\n\n\t/** Time since last combo increment */\n\tfloat TimeSinceLastCombo = 0.0f;\n\n\t/** Time before combo resets */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Flow\")\n\tfloat ComboResetTime = 3.0f;\n\n\tvirtual void BeginPlay() override;\n};\n","Variant_Combat/CombatGameMode.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"Variant_Combat/CombatGameMode.h\"\n#include \"Variant_Combat/CombatCharacter.h\"\n#include \"Variant_Combat/CombatPlayerController.h\"\n#include \"Variant_Combat/AI/CombatEngagementManager.h\"\n#include \"CPPd1SplitScreenManager.h\"\n#include \"Variant_Combat/AI/CombatWaveSpawner.h\"\n#include \"Variant_Combat/AI/CombatEnemy.h\"\n#include \"CombatDamageable.h\"\n#include \"Engine/GameInstance.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/PlayerState.h\"\n\nACombatGameMode::ACombatGameMode()\n{\n\t// Set default pawn class to CombatCharacter\n\tDefaultPawnClass = ACombatCharacter::StaticClass();\n\t\n\t// Set default player controller\n\tPlayerControllerClass = ACombatPlayerController::StaticClass();\n\n\t// Create engagement manager component\n\tEngagementManager = CreateDefaultSubobject<UCombatEngagementManager>(TEXT(\"EngagementManager\"));\n\n\t// Create split-screen manager component\n\tSplitScreenManager = CreateDefaultSubobject<UCPPd1SplitScreenManager>(TEXT(\"SplitScreenManager\"));\n}\n\nvoid ACombatGameMode::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tInitializeEngagementManager();\n\tInitializeSplitScreen();\n\n\t// Connect wave spawner if set\n\tif (WaveSpawner)\n\t{\n\t\tRegisterWaveSpawner(WaveSpawner);\n\t}\n}\n\nvoid ACombatGameMode::InitializeEngagementManager()\n{\n\tif (!EngagementManager)\n\t{\n\t\treturn;\n\t}\n\n\t// Engagement manager will auto-find player characters in BeginPlay\n}\n\nvoid ACombatGameMode::InitializeSplitScreen()\n{\n\tif (bEnableSplitScreen)\n\t{\n\t\tSetupSplitScreen();\n\t}\n}\n\nvoid ACombatGameMode::SetupSplitScreen()\n{\n\tUWorld* World = GetWorld();\n\tif (!World || !World->GetGameInstance())\n\t{\n\t\treturn;\n\t}\n\n\t// Split-screen is handled by the SplitScreenManager component\n\tif (SplitScreenManager)\n\t{\n\t\tSplitScreenManager->SetupSplitScreenForPlayers();\n\t}\n}\n\nvoid ACombatGameMode::RegisterWaveSpawner(ACombatWaveSpawner* Spawner)\n{\n\tif (!Spawner || !EngagementManager)\n\t{\n\t\treturn;\n\t}\n\n\tWaveSpawner = Spawner;\n\tWaveSpawner->OnEnemySpawned.AddDynamic(this, &ACombatGameMode::OnEnemySpawned);\n\tWaveSpawner->OnWaveCompleted.AddDynamic(this, &ACombatGameMode::OnWaveCompleted);\n\tWaveSpawner->OnAllWavesCompleted.AddDynamic(this, &ACombatGameMode::OnAllWavesCompleted);\n}\n\nvoid ACombatGameMode::OnEnemySpawned(ACombatEnemy* Enemy)\n{\n\tif (EngagementManager && Enemy)\n\t\tEngagementManager->RegisterEnemy(Enemy);\n}\n\nvoid ACombatGameMode::OnWaveCompleted(int32 WaveIndex)\n{\n\t// Restore the gods: heal all player characters (duo ninjas) after each wave cleared\n\tUWorld* World = GetWorld();\n\tif (!World || HealPerWaveCleared <= 0.0f) return;\n\tfor (FConstPlayerControllerIterator It = World->GetPlayerControllerIterator(); It; ++It)\n\t{\n\t\tif (APawn* Pawn = It->Get()->GetPawn())\n\t\t{\n\t\t\tif (ICombatDamageable* Damageable = Cast<ICombatDamageable>(Pawn))\n\t\t\t\tDamageable->ApplyHealing(HealPerWaveCleared, this);\n\t\t}\n\t}\n}\n\nvoid ACombatGameMode::OnAllWavesCompleted()\n{\n\t// Full restoration: heal all player gods to max (realm is restored)\n\tUWorld* World = GetWorld();\n\tif (!World) return;\n\tfor (FConstPlayerControllerIterator It = World->GetPlayerControllerIterator(); It; ++It)\n\t{\n\t\tif (APawn* Pawn = It->Get()->GetPawn())\n\t\t{\n\t\t\tif (ACombatCharacter* Char = Cast<ACombatCharacter>(Pawn))\n\t\t\t{\n\t\t\t\t// Heal to full (use a large value; ApplyHealing clamps to MaxHP)\n\t\t\t\tChar->ApplyHealing(999.0f, this);\n\t\t\t}\n\t\t}\n\t}\n\t// NPCs congratulate and worship: broadcast so Blueprint/level can trigger NPC behavior\n\tOnGodsDefendedRealm.Broadcast();\n}","Variant_Combat/CombatGameMode.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"CPPd1.h\"\n#include \"CPPd1GameModeBase.h\"\n#include \"CombatGameMode.generated.h\"\n\nclass UCombatEngagementManager;\nclass UCPPd1SplitScreenManager;\nclass ACombatWaveSpawner;\nclass ACombatEnemy;\n\n/**\n *  Combat GameMode with wave-based enemies, sequential engagement, and split-screen support\n */\nUCLASS(BlueprintType, Blueprintable)\nclass CPPd1_API ACombatGameMode : public ACPPd1GameModeBase\n{\n\tGENERATED_BODY()\n\t\npublic:\n\n\tACombatGameMode();\n\n\tvirtual void BeginPlay() override;\n\n\t/** Enable split-screen (vertical by default, always on even for solo) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"CPPd1|Split Screen\")\n\tbool bEnableSplitScreen = true;\n\n\t/** Use vertical split (left/right) instead of horizontal (top/bottom) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"CPPd1|Split Screen\")\n\tbool bUseVerticalSplit = true;\n\n\t/** Force split-screen even with 1 player (solo play) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"CPPd1|Split Screen\")\n\tbool bForceSplitScreenForSolo = true;\n\n\t/** Number of players for split-screen (2 by default) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"CPPd1|Split Screen\", meta = (ClampMin = 1, ClampMax = 2))\n\tint32 NumSplitScreenPlayers = 2;\n\n\t/** Engagement manager component (manages sequential enemy fights) */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"CPPd1|Combat\")\n\tTObjectPtr<UCombatEngagementManager> EngagementManager;\n\n\t/** Split-screen manager component */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"CPPd1|Split Screen\")\n\tTObjectPtr<UCPPd1SplitScreenManager> SplitScreenManager;\n\n\t/** Wave spawner reference (set in Blueprint or level) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"CPPd1|Waves\")\n\tTObjectPtr<ACombatWaveSpawner> WaveSpawner;\n\n\t/** HUD widget class to spawn for players */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"CPPd1|UI\")\n\tTSubclassOf<class UCombatHUD> HUDWidgetClass;\n\n\t/** Setup split-screen viewports */\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1|Split Screen\")\n\tvoid SetupSplitScreen();\n\n\t/** Register wave spawner and connect to engagement manager */\n\tUFUNCTION(BlueprintCallable, Category = \"CPPd1|Waves\")\n\tvoid RegisterWaveSpawner(ACombatWaveSpawner* Spawner);\n\n\t/** Called when an enemy is spawned - register with engagement manager (one-on-one fights) */\n\tUFUNCTION()\n\tvoid OnEnemySpawned(ACombatEnemy* Enemy);\n\n\t/** Healing the gods receive when they clear a wave (restoration of damage done by marauders). */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"CPPd1|Restoration\", meta = (ClampMin = 0.0f, Units = \"HP\"))\n\tfloat HealPerWaveCleared = 1.0f;\n\n\t/** When all waves are cleared, broadcast this so NPCs can congratulate and worship the gods. */\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnGodsDefendedRealm);\n\tUPROPERTY(BlueprintAssignable, Category = \"CPPd1|Restoration\")\n\tFOnGodsDefendedRealm OnGodsDefendedRealm;\n\n\t/** Called when a wave is cleared - heal all player gods (restoration). */\n\tUFUNCTION()\n\tvoid OnWaveCompleted(int32 WaveIndex);\n\n\t/** Called when all waves are cleared - full restoration, then fire OnGodsDefendedRealm for NPCs. */\n\tUFUNCTION()\n\tvoid OnAllWavesCompleted();\n\nprotected:\n\n\t/** Initialize engagement manager */\n\tvoid InitializeEngagementManager();\n\n\t/** Initialize split-screen */\n\tvoid InitializeSplitScreen();\n};\n","Variant_Combat/CombatInputHelper.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Variant_Combat/CombatInputHelper.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUEnhancedInputLocalPlayerSubsystem* UCombatInputHelper::GetInputSubsystem(UObject* WorldContextObject, int32 PlayerIndex)\n{\n\tif (UWorld* World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::ReturnNull))\n\t{\n\t\tif (APlayerController* PC = UGameplayStatics::GetPlayerController(World, PlayerIndex))\n\t\t{\n\t\t\tif (ULocalPlayer* LocalPlayer = PC->GetLocalPlayer())\n\t\t\t{\n\t\t\t\treturn LocalPlayer->GetSubsystem<UEnhancedInputLocalPlayerSubsystem>();\n\t\t\t}\n\t\t}\n\t}\n\treturn nullptr;\n}\n\nvoid UCombatInputHelper::SetupXboxControllerInput(UObject* WorldContextObject, int32 PlayerIndex)\n{\n\t// This is a helper - the actual Input Mapping Contexts need to be created in Blueprint\n\t// This function can be extended to programmatically add mappings\n\t// For now, it's a placeholder that can be called from Blueprint\n\t\n\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = GetInputSubsystem(WorldContextObject, PlayerIndex))\n\t{\n\t\t// Clear existing contexts\n\t\tSubsystem->ClearAllMappings();\n\t\t\n\t\t// Note: Input Mapping Contexts should be set up in Blueprint\n\t\t// This helper can be extended to programmatically create them\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Xbox controller input setup called for player %d. Configure Input Mapping Contexts in Blueprint.\"), PlayerIndex);\n\t}\n}\n\nvoid UCombatInputHelper::SetupKeyboardMouseInput(UObject* WorldContextObject, int32 PlayerIndex)\n{\n\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = GetInputSubsystem(WorldContextObject, PlayerIndex))\n\t{\n\t\t// Clear existing contexts\n\t\tSubsystem->ClearAllMappings();\n\t\t\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Keyboard/Mouse input setup called for player %d. Configure Input Mapping Contexts in Blueprint.\"), PlayerIndex);\n\t}\n}\n\nvoid UCombatInputHelper::AutoSetupInput(UObject* WorldContextObject, int32 PlayerIndex)\n{\n\t// Auto-detect: For now, default to Xbox controller\n\t// Can be extended to detect connected controllers\n\tSetupXboxControllerInput(WorldContextObject, PlayerIndex);\n}\n","Variant_Combat/CombatInputHelper.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"CPPd1.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"CombatInputHelper.generated.h\"\n\nclass UInputMappingContext;\nclass UInputAction;\nclass UEnhancedInputLocalPlayerSubsystem;\n\n/**\n * Helper class to quickly set up Xbox controller input for combat\n * Use this in Blueprint or C++ to auto-configure Enhanced Input\n */\nUCLASS(BlueprintType, Blueprintable)\nclass CPPd1_API UCombatInputHelper : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\t/** Setup Xbox controller input for a player controller */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Input\", meta = (WorldContext = \"WorldContextObject\"))\n\tstatic void SetupXboxControllerInput(UObject* WorldContextObject, int32 PlayerIndex = 0);\n\n\t/** Setup keyboard/mouse input for a player controller */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Input\", meta = (WorldContext = \"WorldContextObject\"))\n\tstatic void SetupKeyboardMouseInput(UObject* WorldContextObject, int32 PlayerIndex = 0);\n\n\t/** Auto-detect input device and setup accordingly */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Input\", meta = (WorldContext = \"WorldContextObject\"))\n\tstatic void AutoSetupInput(UObject* WorldContextObject, int32 PlayerIndex = 0);\n\nprotected:\n\t/** Get the input subsystem for a player */\n\tstatic UEnhancedInputLocalPlayerSubsystem* GetInputSubsystem(UObject* WorldContextObject, int32 PlayerIndex);\n};\n","Variant_Combat/CombatPlayerController.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"Variant_Combat/CombatPlayerController.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"InputMappingContext.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerStart.h\"\n#include \"CombatCharacter.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"Engine/World.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"CPPd1.h\"\n#include \"Widgets/Input/SVirtualJoystick.h\"\n\nvoid ACombatPlayerController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// only spawn touch controls on local player controllers\n\tif (SVirtualJoystick::ShouldDisplayTouchInterface() && IsLocalPlayerController())\n\t{\n\t\t// spawn the mobile controls widget\n\t\tMobileControlsWidget = CreateWidget<UUserWidget>(this, MobileControlsWidgetClass);\n\n\t\tif (MobileControlsWidget)\n\t\t{\n\t\t\t// add the controls to the player screen\n\t\t\tMobileControlsWidget->AddToPlayerScreen(0);\n\n\t\t} else {\n\n\t\t\tUE_LOG(LogCPPd1, Error, TEXT(\"Could not spawn mobile controls widget.\"));\n\n\t\t}\n\n\t}\n\n\t// Spawn HUD widget for local players\n\tif (IsLocalPlayerController() && HUDWidgetClass)\n\t{\n\t\tHUDWidget = CreateWidget<UUserWidget>(this, HUDWidgetClass);\n\t\tif (HUDWidget)\n\t\t{\n\t\t\tHUDWidget->AddToPlayerScreen();\n\t\t}\n\t}\n}\n\nvoid ACombatPlayerController::SetupInputComponent()\n{\n\t// only add IMCs for local player controllers\n\tif (IsLocalPlayerController())\n\t{\n\t\t// add the input mapping context\n\t\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer()))\n\t\t{\n\t\t\tfor (UInputMappingContext* CurrentContext : DefaultMappingContexts)\n\t\t\t{\n\t\t\t\tSubsystem->AddMappingContext(CurrentContext, 0);\n\t\t\t}\n\n\t\t\t// only add these IMCs if we're not using mobile touch input\n\t\t\tif (!SVirtualJoystick::ShouldDisplayTouchInterface())\n\t\t\t{\n\t\t\t\tfor (UInputMappingContext* CurrentContext : MobileExcludedMappingContexts)\n\t\t\t\t{\n\t\t\t\t\tSubsystem->AddMappingContext(CurrentContext, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ACombatPlayerController::OnPossess(APawn* InPawn)\n{\n\tSuper::OnPossess(InPawn);\n\n\t// subscribe to the pawn's OnDestroyed delegate\n\tInPawn->OnDestroyed.AddDynamic(this, &ACombatPlayerController::OnPawnDestroyed);\n}\n\nvoid ACombatPlayerController::SetRespawnTransform(const FTransform& NewRespawn)\n{\n\t// save the new respawn transform\n\tRespawnTransform = NewRespawn;\n}\n\nvoid ACombatPlayerController::OnPawnDestroyed(AActor* DestroyedActor)\n{\n\t// spawn a new character at the respawn transform\n\tif (ACombatCharacter* RespawnedCharacter = GetWorld()->SpawnActor<ACombatCharacter>(CharacterClass, RespawnTransform))\n\t{\n\t\t// possess the character\n\t\tPossess(RespawnedCharacter);\n\t}\n}","Variant_Combat/CombatPlayerController.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"CombatPlayerController.generated.h\"\n\nclass UInputMappingContext;\nclass ACombatCharacter;\n\n/**\n *  Simple Player Controller for a third person combat game\n *  Manages input mappings\n *  Respawns the player character at the checkpoint when it's destroyed\n */\nUCLASS(abstract)\nclass ACombatPlayerController : public APlayerController\n{\n\tGENERATED_BODY()\n\t\nprotected:\n\n\t/** Input mapping context for this player */\n\tUPROPERTY(EditAnywhere, Category=\"Input|Input Mappings\")\n\tTArray<UInputMappingContext*> DefaultMappingContexts;\n\n\t/** Input Mapping Contexts */\n\tUPROPERTY(EditAnywhere, Category=\"Input|Input Mappings\")\n\tTArray<UInputMappingContext*> MobileExcludedMappingContexts;\n\n\t/** Mobile controls widget to spawn */\n\tUPROPERTY(EditAnywhere, Category=\"Input|Touch Controls\")\n\tTSubclassOf<UUserWidget> MobileControlsWidgetClass;\n\n\t/** Pointer to the mobile controls widget */\n\tTObjectPtr<UUserWidget> MobileControlsWidget;\n\n\t/** HUD widget class to spawn */\n\tUPROPERTY(EditAnywhere, Category=\"UI|HUD\")\n\tTSubclassOf<class UUserWidget> HUDWidgetClass;\n\n\t/** Pointer to the HUD widget */\n\tTObjectPtr<UUserWidget> HUDWidget;\n\n\t/** Character class to respawn when the possessed pawn is destroyed */\n\tUPROPERTY(EditAnywhere, Category=\"Respawn\")\n\tTSubclassOf<ACombatCharacter> CharacterClass;\n\n\t/** Transform to respawn the character at. Can be set to create checkpoints */\n\tFTransform RespawnTransform;\n\nprotected:\n\n\t/** Gameplay initialization */\n\tvirtual void BeginPlay() override;\n\n\t/** Initialize input bindings */\n\tvirtual void SetupInputComponent() override;\n\n\t/** Pawn initialization */\n\tvirtual void OnPossess(APawn* InPawn) override;\n\npublic:\n\n\t/** Updates the character respawn transform */\n\tvoid SetRespawnTransform(const FTransform& NewRespawn);\n\nprotected:\n\n\t/** Called if the possessed pawn is destroyed */\n\tUFUNCTION()\n\tvoid OnPawnDestroyed(AActor* DestroyedActor);\n\n};\n","Variant_Combat/CombatSkillSystem.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CombatSkillSystem.h\"\n\nUCombatSkillSystem::UCombatSkillSystem()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\t// Initialize all skill types\n\tfor (int32 i = 0; i < static_cast<int32>(ECombatSkillType::Flow) + 1; ++i)\n\t{\n\t\tECombatSkillType SkillType = static_cast<ECombatSkillType>(i);\n\t\tSkills.Add(SkillType, FCombatSkillData());\n\t}\n}\n\nfloat UCombatSkillSystem::GetSkillLevel(ECombatSkillType SkillType) const\n{\n\tif (const FCombatSkillData* SkillData = Skills.Find(SkillType))\n\t{\n\t\treturn SkillData->SkillLevel;\n\t}\n\treturn 0.0f;\n}\n\nvoid UCombatSkillSystem::AddExperience(ECombatSkillType SkillType, float Amount)\n{\n\tif (FCombatSkillData* SkillData = Skills.Find(SkillType))\n\t{\n\t\tSkillData->Experience += Amount;\n\t\tCheckSkillLevelUp(SkillType);\n\t}\n}\n\nfloat UCombatSkillSystem::GetStrikingDamageMultiplier() const\n{\n\tfloat SkillLevel = GetSkillLevel(ECombatSkillType::Striking);\n\tfloat Normalized = SkillLevel / 100.0f;\n\treturn FMath::Lerp(BaseDamageMultiplier, MaxDamageMultiplier, Normalized);\n}\n\nfloat UCombatSkillSystem::GetDefenseEffectiveness() const\n{\n\tfloat SkillLevel = GetSkillLevel(ECombatSkillType::Defense);\n\tfloat Normalized = SkillLevel / 100.0f;\n\treturn FMath::Lerp(BaseDefenseEffectiveness, MaxDefenseEffectiveness, Normalized);\n}\n\nfloat UCombatSkillSystem::GetStaminaEfficiency() const\n{\n\tfloat SkillLevel = GetSkillLevel(ECombatSkillType::Stamina);\n\t// Higher stamina skill = less stamina drain\n\treturn 1.0f - (SkillLevel / 200.0f); // 0.5x drain at max level\n}\n\nfloat UCombatSkillSystem::GetTechniqueAccuracy() const\n{\n\tfloat SkillLevel = GetSkillLevel(ECombatSkillType::Technique);\n\t// Higher technique = better combo execution window\n\treturn SkillLevel / 100.0f; // 0.0 to 1.0\n}\n\nfloat UCombatSkillSystem::GetFlowMultiplier() const\n{\n\tfloat SkillLevel = GetSkillLevel(ECombatSkillType::Flow);\n\t// Higher flow = better trick chaining\n\treturn 1.0f + (SkillLevel / 50.0f); // 1.0x to 3.0x at max\n}\n\nvoid UCombatSkillSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UCombatSkillSystem::CheckSkillLevelUp(ECombatSkillType SkillType)\n{\n\tif (FCombatSkillData* SkillData = Skills.Find(SkillType))\n\t{\n\t\twhile (SkillData->Experience >= SkillData->ExperienceToNextLevel && SkillData->SkillLevel < 100.0f)\n\t\t{\n\t\t\tSkillData->Experience -= SkillData->ExperienceToNextLevel;\n\t\t\tSkillData->SkillLevel = FMath::Min(100.0f, SkillData->SkillLevel + 1.0f);\n\t\t\t\n\t\t\t// Increase XP needed for next level (exponential)\n\t\t\tSkillData->ExperienceToNextLevel *= 1.1f;\n\t\t}\n\t}\n}\n","Variant_Combat/CombatSkillSystem.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CombatSkillSystem.generated.h\"\n\n/** Combat skill types (inspired by UFC 5) */\nUENUM(BlueprintType)\nenum class ECombatSkillType : uint8\n{\n\tStriking,\t\t// Punching, kicking accuracy and power\n\tGrappling,\t\t// Takedowns, submissions\n\tDefense,\t\t// Blocking, parrying, dodging\n\tStamina,\t\t// Endurance and recovery\n\tTechnique,\t\t// Combo execution, timing\n\tFlow\t\t\t// Style points, trick chaining (Skate-inspired)\n};\n\n/** Skill level data */\nUSTRUCT(BlueprintType)\nstruct FCombatSkillData\n{\n\tGENERATED_BODY()\n\n\t/** Current skill level (0-100) */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n\tfloat SkillLevel = 0.0f;\n\n\t/** Experience points toward next level */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n\tfloat Experience = 0.0f;\n\n\t/** Experience needed for next level */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tfloat ExperienceToNextLevel = 100.0f;\n\n\tFCombatSkillData()\n\t\t: SkillLevel(0.0f)\n\t\t, Experience(0.0f)\n\t\t, ExperienceToNextLevel(100.0f)\n\t{}\n};\n\n/**\n * Skill-based combat system inspired by UFC 5\n * Tracks player skill progression and affects combat effectiveness\n */\nUCLASS(ClassGroup=(CPPd1), meta=(BlueprintSpawnableComponent))\nclass UCombatSkillSystem : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\n\tUCombatSkillSystem();\n\n\t/** Get skill level for a specific skill type */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Skill\")\n\tfloat GetSkillLevel(ECombatSkillType SkillType) const;\n\n\t/** Add experience to a skill */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Skill\")\n\tvoid AddExperience(ECombatSkillType SkillType, float Amount);\n\n\t/** Get damage multiplier based on striking skill */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Skill\")\n\tfloat GetStrikingDamageMultiplier() const;\n\n\t/** Get defense effectiveness based on defense skill */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Skill\")\n\tfloat GetDefenseEffectiveness() const;\n\n\t/** Get stamina efficiency based on stamina skill */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Skill\")\n\tfloat GetStaminaEfficiency() const;\n\n\t/** Get technique accuracy (affects combo execution) */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Skill\")\n\tfloat GetTechniqueAccuracy() const;\n\n\t/** Get flow multiplier (affects trick chaining) */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Skill\")\n\tfloat GetFlowMultiplier() const;\n\n\t/** Get all skill data */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Skill\")\n\tTMap<ECombatSkillType, FCombatSkillData> GetAllSkills() const { return Skills; }\n\nprotected:\n\n\t/** Skill data map */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Combat|Skill\")\n\tTMap<ECombatSkillType, FCombatSkillData> Skills;\n\n\t/** Base damage multiplier at skill level 0 */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Skill\")\n\tfloat BaseDamageMultiplier = 0.5f;\n\n\t/** Max damage multiplier at skill level 100 */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Skill\")\n\tfloat MaxDamageMultiplier = 2.0f;\n\n\t/** Base defense effectiveness at skill level 0 */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Skill\")\n\tfloat BaseDefenseEffectiveness = 0.3f;\n\n\t/** Max defense effectiveness at skill level 100 */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Skill\")\n\tfloat MaxDefenseEffectiveness = 0.9f;\n\n\tvirtual void BeginPlay() override;\n\n\t/** Check and level up skills */\n\tvoid CheckSkillLevelUp(ECombatSkillType SkillType);\n};\n","Variant_Combat/CombatStaminaSystem.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CombatStaminaSystem.h\"\n#include \"CombatSkillSystem.h\"\n\nUCombatStaminaSystem::UCombatStaminaSystem()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCurrentStamina = MaxStamina;\n}\n\nvoid UCombatStaminaSystem::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tTimeSinceLastDrain += DeltaTime;\n\n\t// Recover stamina if enough time has passed\n\tif (TimeSinceLastDrain >= RecoveryDelay && CurrentStamina < MaxStamina)\n\t{\n\t\tfloat RecoveryRate = IsExhausted() ? ExhaustedRecoveryRate : BaseRecoveryRate;\n\t\tRecoveryRate *= GetRecoveryRate(); // Apply efficiency multiplier\n\t\t\n\t\tCurrentStamina = FMath::Min(MaxStamina, CurrentStamina + (RecoveryRate * DeltaTime));\n\t}\n}\n\nvoid UCombatStaminaSystem::DrainStamina(float Amount)\n{\n\t// Apply stamina efficiency (higher skill = less drain)\n\tfloat ActualDrain = Amount * (1.0f / StaminaEfficiency);\n\t\n\tCurrentStamina = FMath::Max(0.0f, CurrentStamina - ActualDrain);\n\tTimeSinceLastDrain = 0.0f;\n}\n\nbool UCombatStaminaSystem::HasStamina(float RequiredAmount) const\n{\n\treturn CurrentStamina >= RequiredAmount;\n}\n\nfloat UCombatStaminaSystem::GetRecoveryRate() const\n{\n\treturn StaminaEfficiency;\n}\n\nvoid UCombatStaminaSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Get stamina efficiency from skill system if available\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tif (UCombatSkillSystem* SkillSystem = Owner->FindComponentByClass<UCombatSkillSystem>())\n\t\t{\n\t\t\tStaminaEfficiency = SkillSystem->GetStaminaEfficiency();\n\t\t}\n\t}\n}\n","Variant_Combat/CombatStaminaSystem.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CombatStaminaSystem.generated.h\"\n\n/**\n * Stamina system inspired by UFC 5\n * Manages stamina drain, recovery, and exhaustion states\n */\nUCLASS(ClassGroup=(CPPd1), meta=(BlueprintSpawnableComponent))\nclass UCombatStaminaSystem : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\n\tUCombatStaminaSystem();\n\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\t/** Get current stamina (0.0 to 1.0) */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Stamina\")\n\tfloat GetStamina() const { return CurrentStamina; }\n\n\t/** Get stamina percentage (0-100) */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Stamina\")\n\tfloat GetStaminaPercentage() const { return CurrentStamina * 100.0f; }\n\n\t/** Drain stamina */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Stamina\")\n\tvoid DrainStamina(float Amount);\n\n\t/** Check if has enough stamina for an action */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Stamina\")\n\tbool HasStamina(float RequiredAmount) const;\n\n\t/** Check if exhausted (stamina too low) */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Stamina\")\n\tbool IsExhausted() const { return CurrentStamina <= ExhaustionThreshold; }\n\n\t/** Get stamina recovery rate multiplier */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Stamina\")\n\tfloat GetRecoveryRate() const;\n\nprotected:\n\n\t/** Maximum stamina */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Stamina\", meta = (ClampMin = 0.0f, ClampMax = 1.0f))\n\tfloat MaxStamina = 1.0f;\n\n\t/** Current stamina */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Combat|Stamina\", meta = (ClampMin = 0.0f, ClampMax = 1.0f))\n\tfloat CurrentStamina = 1.0f;\n\n\t/** Base recovery rate per second */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Stamina\")\n\tfloat BaseRecoveryRate = 0.2f;\n\n\t/** Recovery rate when exhausted (slower) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Stamina\")\n\tfloat ExhaustedRecoveryRate = 0.05f;\n\n\t/** Stamina threshold for exhaustion */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Stamina\", meta = (ClampMin = 0.0f, ClampMax = 1.0f))\n\tfloat ExhaustionThreshold = 0.2f;\n\n\t/** Time before stamina starts recovering after drain */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Stamina\")\n\tfloat RecoveryDelay = 1.0f;\n\n\t/** Time since last stamina drain */\n\tfloat TimeSinceLastDrain = 0.0f;\n\n\t/** Stamina efficiency multiplier (from skill system) */\n\tfloat StaminaEfficiency = 1.0f;\n\n\tvirtual void BeginPlay() override;\n};\n","Variant_Combat/CombatTrickSystem.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CombatTrickSystem.h\"\n#include \"Animation/AnimMontage.h\"\n\nUCombatTrickSystem::UCombatTrickSystem()\n{\n\tMaxInputGap = 0.5f;\n}\n\nvoid UCombatTrickSystem::RegisterTrick(const FCombatTrick& Trick)\n{\n\tRegisteredTricks.Add(Trick);\n}\n\nbool UCombatTrickSystem::CheckTrickInput(const FCombatTrickInput& Input, float DeltaTime)\n{\n\tTimeSinceLastInput += DeltaTime;\n\n\t// If too much time has passed, reset sequence\n\tif (TimeSinceLastInput > MaxInputGap)\n\t{\n\t\tClearInputSequence();\n\t}\n\n\t// Add new input\n\tCurrentInputSequence.Add(Input);\n\tTimeSinceLastInput = 0.0f;\n\n\t// Limit sequence length\n\tif (CurrentInputSequence.Num() > 10)\n\t{\n\t\tCurrentInputSequence.RemoveAt(0);\n\t}\n\n\treturn true;\n}\n\nFCombatTrick UCombatTrickSystem::GetBestMatchingTrick(int32 CurrentSkillLevel) const\n{\n\tFCombatTrick BestTrick;\n\tfloat BestMatchScore = 0.0f;\n\n\tfor (const FCombatTrick& Trick : RegisteredTricks)\n\t{\n\t\t// Check skill requirement\n\t\tif (Trick.RequiredSkillLevel > CurrentSkillLevel)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check if input sequence matches\n\t\tif (Trick.InputSequence.Num() > CurrentInputSequence.Num())\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Calculate match score\n\t\tfloat MatchScore = 0.0f;\n\t\tbool bMatches = true;\n\n\t\tfor (int32 i = 0; i < Trick.InputSequence.Num(); ++i)\n\t\t{\n\t\t\tint32 SequenceIndex = CurrentInputSequence.Num() - Trick.InputSequence.Num() + i;\n\t\t\tif (SequenceIndex < 0 || SequenceIndex >= CurrentInputSequence.Num())\n\t\t\t{\n\t\t\t\tbMatches = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst FCombatTrickInput& TrickInput = Trick.InputSequence[i];\n\t\t\tconst FCombatTrickInput& CurrentInput = CurrentInputSequence[SequenceIndex];\n\n\t\t\tif (TrickInput.Direction == CurrentInput.Direction && TrickInput.Button == CurrentInput.Button)\n\t\t\t{\n\t\t\t\tMatchScore += 1.0f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbMatches = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (bMatches && MatchScore > BestMatchScore)\n\t\t{\n\t\t\tBestMatchScore = MatchScore;\n\t\t\tBestTrick = Trick;\n\t\t}\n\t}\n\n\treturn BestTrick;\n}\n\nvoid UCombatTrickSystem::ClearInputSequence()\n{\n\tCurrentInputSequence.Empty();\n\tTimeSinceLastInput = 0.0f;\n\tTrickChainCount = 0;\n}\n\nfloat UCombatTrickSystem::GetFlowMultiplier() const\n{\n\t// Flow multiplier increases with trick chain\n\treturn 1.0f + (TrickChainCount * 0.1f);\n}\n","Variant_Combat/CombatTrickSystem.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"CombatTrickSystem.generated.h\"\n\nclass UAnimMontage;\n\n/** Directional input for tricks (like Skate) */\nUENUM(BlueprintType)\nenum class ECombatTrickDirection : uint8\n{\n\tUp,\n\tDown,\n\tLeft,\n\tRight,\n\tUpLeft,\n\tUpRight,\n\tDownLeft,\n\tDownRight,\n\tNeutral\n};\n\n/** Trick input sequence (like Skate's trick system) */\nUSTRUCT(BlueprintType)\nstruct FCombatTrickInput\n{\n\tGENERATED_BODY()\n\n\t/** Directional input */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tECombatTrickDirection Direction = ECombatTrickDirection::Neutral;\n\n\t/** Button input (0 = no button, 1 = light attack, 2 = heavy attack, 3 = special) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tint32 Button = 0;\n\n\t/** Time window for this input (in seconds) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tfloat TimeWindow = 0.3f;\n\n\tFCombatTrickInput()\n\t\t: Direction(ECombatTrickDirection::Neutral)\n\t\t, Button(0)\n\t\t, TimeWindow(0.3f)\n\t{}\n};\n\n/** A combat trick/combo (like Skate's trick system) */\nUSTRUCT(BlueprintType)\nstruct FCombatTrick\n{\n\tGENERATED_BODY()\n\n\t/** Name of the trick */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tFName TrickName;\n\n\t/** Input sequence to perform this trick */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tTArray<FCombatTrickInput> InputSequence;\n\n\t/** Animation montage to play */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tUAnimMontage* TrickMontage;\n\n\t/** Damage multiplier for this trick */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tfloat DamageMultiplier = 1.0f;\n\n\t/** Flow/style points awarded */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tfloat FlowPoints = 10.0f;\n\n\t/** Required skill level to perform */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tint32 RequiredSkillLevel = 0;\n\n\tFCombatTrick()\n\t\t: TrickName(NAME_None)\n\t\t, DamageMultiplier(1.0f)\n\t\t, FlowPoints(10.0f)\n\t\t, RequiredSkillLevel(0)\n\t{}\n};\n\n/**\n * Trick system for combat - inspired by Skate 4's trick system\n * Allows chaining directional inputs + buttons to create combos\n */\nUCLASS(BlueprintType, Blueprintable)\nclass UCombatTrickSystem : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\n\tUCombatTrickSystem();\n\n\t/** Register a trick */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Trick\")\n\tvoid RegisterTrick(const FCombatTrick& Trick);\n\n\t/** Check if current input sequence matches a trick */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Trick\")\n\tbool CheckTrickInput(const FCombatTrickInput& Input, float DeltaTime);\n\n\t/** Get the best matching trick from current input sequence */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Trick\")\n\tFCombatTrick GetBestMatchingTrick(int32 CurrentSkillLevel) const;\n\n\t/** Clear the current input sequence */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|Trick\")\n\tvoid ClearInputSequence();\n\n\t/** Get current input sequence (for debugging) */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Trick\")\n\tTArray<FCombatTrickInput> GetCurrentInputSequence() const { return CurrentInputSequence; }\n\n\t/** Get flow multiplier based on trick chain */\n\tUFUNCTION(BlueprintPure, Category = \"Combat|Trick\")\n\tfloat GetFlowMultiplier() const;\n\nprotected:\n\n\t/** Registered tricks */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Trick\")\n\tTArray<FCombatTrick> RegisteredTricks;\n\n\t/** Current input sequence being built */\n\tTArray<FCombatTrickInput> CurrentInputSequence;\n\n\t/** Time since last input */\n\tfloat TimeSinceLastInput = 0.0f;\n\n\t/** Maximum time between inputs to maintain combo */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|Trick\")\n\tfloat MaxInputGap = 0.5f;\n\n\t/** Current trick chain count (for flow multiplier) */\n\tint32 TrickChainCount = 0;\n};\n","Variant_Combat/CubeNinjaCharacter.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CubeNinjaCharacter.h\"\n#include \"CubeNinjaBodyComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n\nACubeNinjaCharacter::ACubeNinjaCharacter()\n{\n\tCubeBody = CreateDefaultSubobject<UCubeNinjaBodyComponent>(TEXT(\"CubeBody\"));\n\tCubeBody->SetupAttachment(RootComponent);\n\t// Align cube body feet with capsule bottom (pelvis bottom at component origin; offset down by half height)\n\tCubeBody->SetRelativeLocation(FVector(0.f, 0.f, -GetCapsuleComponent()->GetScaledCapsuleHalfHeight()));\n\tCubeBody->BodyScale = 0.9f;\n}\n\nvoid ACubeNinjaCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Use cube body as visual; hide skeletal mesh so we see only the cubes\n\tif (GetMesh())\n\t{\n\t\tGetMesh()->SetVisibility(false);\n\t\tGetMesh()->SetHiddenInGame(true);\n\t\tGetMesh()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t}\n}\n","Variant_Combat/CubeNinjaCharacter.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"NinjaCharacter.h\"\n#include \"CubeNinjaCharacter.generated.h\"\n\nclass UCubeNinjaBodyComponent;\n\n/**\n * Ninja character that uses a cube-ninja body (interlocking procedural cubes) as its visual.\n * Same movement and combat as NinjaCharacter; the skeletal mesh is hidden and the cube body is shown.\n */\nUCLASS(BlueprintType, Blueprintable)\nclass CPPd1_API ACubeNinjaCharacter : public ANinjaCharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tACubeNinjaCharacter();\n\n\t/** The cube-ninja body (ninja made of cubes). Edit Body Scale and limb swing here. */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Cube Ninja\")\n\tTObjectPtr<UCubeNinjaBodyComponent> CubeBody;\n\nprotected:\n\tvirtual void BeginPlay() override;\n};\n","Variant_Combat/Gameplay/CombatActivationVolume.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatActivationVolume.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/Character.h\"\n#include \"CombatActivatable.h\"\n\nACombatActivationVolume::ACombatActivationVolume()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// create the box volume\n\tRootComponent = Box = CreateDefaultSubobject<UBoxComponent>(TEXT(\"Box\"));\n\tcheck(Box);\n\n\t// set the box's extent\n\tBox->SetBoxExtent(FVector(500.0f, 500.0f, 500.0f));\n\n\t// set the default collision profile to overlap all dynamic\n\tBox->SetCollisionProfileName(FName(\"OverlapAllDynamic\"));\n\n\t// bind the begin overlap \n\tBox->OnComponentBeginOverlap.AddDynamic(this, &ACombatActivationVolume::OnOverlap);\n}\n\nvoid ACombatActivationVolume::OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\t// has a Character entered the volume?\n\tACharacter* PlayerCharacter = Cast<ACharacter>(OtherActor);\n\n\tif (PlayerCharacter)\n\t{\n\t\t// is the Character controlled by a player\n\t\tif (PlayerCharacter->IsPlayerControlled())\n\t\t{\n\t\t\t// process the actors to activate list\n\t\t\tfor (AActor* CurrentActor : ActorsToActivate)\n\t\t\t{\n\t\t\t\t// is the referenced actor activatable?\n\t\t\t\tif(ICombatActivatable* Activatable = Cast<ICombatActivatable>(CurrentActor))\n\t\t\t\t{\n\t\t\t\t\tActivatable->ActivateInteraction(PlayerCharacter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}","Variant_Combat/Gameplay/CombatActivationVolume.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CombatActivationVolume.generated.h\"\n\nclass UBoxComponent;\n\n/**\n *  A simple volume that activates a list of actors when the player pawn enters.\n */\nUCLASS()\nclass ACombatActivationVolume : public AActor\n{\n\tGENERATED_BODY()\n\n\t/** Collision box volume */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUBoxComponent* Box;\n\t\nprotected:\n\n\t/** List of actors to activate when this volume is entered */\n\tUPROPERTY(EditAnywhere, Category=\"Activation Volume\")\n\tTArray<AActor*> ActorsToActivate;\n\npublic:\t\n\t\n\t/** Constructor */\n\tACombatActivationVolume();\n\nprotected:\n\n\t/** Handles overlaps with the box volume */\n\tUFUNCTION()\n\tvoid OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n};\n","Variant_Combat/Gameplay/CombatCheckpointVolume.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatCheckpointVolume.h\"\n#include \"CombatCharacter.h\"\n#include \"CombatPlayerController.h\"\n\nACombatCheckpointVolume::ACombatCheckpointVolume()\n{\n\t// create the box volume\n\tRootComponent = Box = CreateDefaultSubobject<UBoxComponent>(TEXT(\"Box\"));\n\tcheck(Box);\n\n\t// set the box's extent\n\tBox->SetBoxExtent(FVector(500.0f, 500.0f, 500.0f));\n\n\t// set the default collision profile to overlap all dynamic\n\tBox->SetCollisionProfileName(FName(\"OverlapAllDynamic\"));\n\n\t// bind the begin overlap \n\tBox->OnComponentBeginOverlap.AddDynamic(this, &ACombatCheckpointVolume::OnOverlap);\n}\n\nvoid ACombatCheckpointVolume::OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\t// ensure we use this only once\n\tif (bCheckpointUsed)\n\t{\n\t\treturn;\n\t}\n\t\t\n\t// has the player entered this volume?\n\tACombatCharacter* PlayerCharacter = Cast<ACombatCharacter>(OtherActor);\n\n\tif (PlayerCharacter)\n\t{\n\t\tif (ACombatPlayerController* PC = Cast<ACombatPlayerController>(PlayerCharacter->GetController()))\n\t\t{\n\t\t\t// raise the checkpoint used flag\n\t\t\tbCheckpointUsed = true;\n\n\t\t\t// update the player's respawn checkpoint\n\t\t\tPC->SetRespawnTransform(PlayerCharacter->GetActorTransform());\n\t\t}\n\n\t}\n}\n","Variant_Combat/Gameplay/CombatCheckpointVolume.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"CombatCheckpointVolume.generated.h\"\n\nUCLASS(abstract)\nclass ACombatCheckpointVolume : public AActor\n{\n\tGENERATED_BODY()\n\t\n\t/** Collision box volume */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Components, meta = (AllowPrivateAccess = \"true\"))\n\tUBoxComponent* Box;\n\npublic:\t\n\t\n\t/** Constructor */\n\tACombatCheckpointVolume();\n\nprotected:\n\n\t/** Set to true after use to avoid accidentally resetting the checkpoint */\n\tbool bCheckpointUsed = false;\n\n\t/** Handles overlaps with the box volume */\n\tUFUNCTION()\n\tvoid OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n","Variant_Combat/Gameplay/CombatDamageableBox.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatDamageableBox.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"TimerManager.h\"\n#include \"Engine/World.h\"\n\nACombatDamageableBox::ACombatDamageableBox()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// create the mesh\n\tRootComponent = Mesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Mesh\"));\n\n\t// set the collision properties\n\tMesh->SetCollisionProfileName(FName(\"BlockAllDynamic\"));\n\n\t// enable physics\n\tMesh->SetSimulatePhysics(true);\n\n\t// disable navigation relevance so boxes don't affect NavMesh generation\n\tMesh->bNavigationRelevant = false;\n}\n\nvoid ACombatDamageableBox::RemoveFromLevel()\n{\n\t// destroy this actor\n\tDestroy();\n}\n\nvoid ACombatDamageableBox::EndPlay(EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\t// clear the death timer\n\tGetWorld()->GetTimerManager().ClearTimer(DeathTimer);\n}\n\nvoid ACombatDamageableBox::ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse)\n{\n\t// only process damage if we still have HP\n\tif (CurrentHP > 0.0f)\n\t{\n\t\t// apply the damage\n\t\tCurrentHP -= Damage;\n\n\t\t// are we dead?\n\t\tif (CurrentHP <= 0.0f)\n\t\t{\n\t\t\tHandleDeath();\n\t\t}\n\n\t\t// apply a physics impulse to the box, ignoring its mass\n\t\tMesh->AddImpulseAtLocation(DamageImpulse * Mesh->GetMass(), DamageLocation);\n\n\t\t// call the BP handler to play effects, etc.\n\t\tOnBoxDamaged(DamageLocation, DamageImpulse);\n\t}\n}\n\nvoid ACombatDamageableBox::HandleDeath()\n{\n\t// change the collision object type to Visibility so we ignore most interactions but still retain physics collisions\n\tMesh->SetCollisionObjectType(ECC_Visibility);\n\n\t// call the BP handler to play effects, etc.\n\tOnBoxDestroyed();\n\n\t// set up the death cleanup timer\n\tGetWorld()->GetTimerManager().SetTimer(DeathTimer, this, &ACombatDamageableBox::RemoveFromLevel, DeathDelayTime);\n}\n\nvoid ACombatDamageableBox::ApplyHealing(float Healing, AActor* Healer)\n{\n\t// stub\n}\n\n","Variant_Combat/Gameplay/CombatDamageableBox.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CombatDamageable.h\"\n#include \"CombatDamageableBox.generated.h\"\n\n/**\n *  A simple physics box that reacts to damage through the ICombatDamageable interface\n */\nUCLASS(abstract)\nclass ACombatDamageableBox : public AActor, public ICombatDamageable\n{\n\tGENERATED_BODY()\n\t\n\t/** Damageable box mesh */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUStaticMeshComponent* Mesh;\n\npublic:\t\n\n\t/** Constructor */\n\tACombatDamageableBox();\n\nprotected:\n\n\t/** Amount of HP this box starts with. */\n\tUPROPERTY(EditAnywhere, Category=\"Damage\")\n\tfloat CurrentHP = 3.0f;\n\n\t/** Time to wait before we remove this box from the level. */\n\tUPROPERTY(EditAnywhere, Category=\"Damage\", meta = (ClampMin = 0, ClampMax = 10, Units = \"s\"))\n\tfloat DeathDelayTime = 6.0f;\n\n\t/** Timer to defer destruction of this box after its HP are depleted */\n\tFTimerHandle DeathTimer;\n\n\t/** Blueprint damage handler for effect playback */\n\tUFUNCTION(BlueprintImplementableEvent, Category=\"Damage\")\n\tvoid OnBoxDamaged(const FVector& DamageLocation, const FVector& DamageImpulse);\n\n\t/** Blueprint destruction handler for effect playback */\n\tUFUNCTION(BlueprintImplementableEvent, Category=\"Damage\")\n\tvoid OnBoxDestroyed();\n\n\t/** Timer callback to remove the box from the level after it dies */\n\tvoid RemoveFromLevel();\n\npublic:\n\n\t/** EndPlay cleanup */\n\tvoid EndPlay(EEndPlayReason::Type EndPlayReason) override;\n\n\t// ~Begin CombatDamageable interface\n\n\t/** Handles damage and knockback events */\n\tvirtual void ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse) override;\n\n\t/** Handles death events */\n\tvirtual void HandleDeath() override;\n\n\t/** Handles healing events */\n\tvirtual void ApplyHealing(float Healing, AActor* Healer) override;\n\n\t// ~End CombatDamageable interface\n};\n","Variant_Combat/Gameplay/CombatDummy.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatDummy.h\"\n#include \"Components/SceneComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"PhysicsEngine/PhysicsConstraintComponent.h\"\n\nACombatDummy::ACombatDummy()\n{\n \tPrimaryActorTick.bCanEverTick = true;\n\n\t// create the root\n\tRoot = CreateDefaultSubobject<USceneComponent>(TEXT(\"Root\"));\n\tSetRootComponent(Root);\n\n\t// create the base plate\n\tBasePlate = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Base Plate\"));\n\tBasePlate->SetupAttachment(RootComponent);\n\n\t// create the dummy\n\tDummy = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Dummy\"));\n\tDummy->SetupAttachment(RootComponent);\n\n\tDummy->SetSimulatePhysics(true);\n\n\t// create the physics constraint\n\tPhysicsConstraint = CreateDefaultSubobject<UPhysicsConstraintComponent>(TEXT(\"Physics Constraint\"));\n\tPhysicsConstraint->SetupAttachment(RootComponent);\n\n\tPhysicsConstraint->SetConstrainedComponents(BasePlate, NAME_None, Dummy, NAME_None);\n}\n\nvoid ACombatDummy::ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse)\n{\n\t// apply impulse to the dummy\n\tDummy->AddImpulseAtLocation(DamageImpulse, DamageLocation);\n\n\t// call the BP handler\n\tBP_OnDummyDamaged(DamageLocation, DamageImpulse.GetSafeNormal());\n}\n\nvoid ACombatDummy::HandleDeath()\n{\n\t// unused\n}\n\nvoid ACombatDummy::ApplyHealing(float Healing, AActor* Healer)\n{\n\t// unused\n}","Variant_Combat/Gameplay/CombatDummy.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CombatDamageable.h\"\n#include \"CombatDummy.generated.h\"\n\nclass UStaticMeshComponent;\nclass UPhysicsConstraintComponent;\n\n/**\n *  A simple invincible combat training dummy\n */\nUCLASS(abstract)\nclass ACombatDummy : public AActor, public ICombatDamageable\n{\n\tGENERATED_BODY()\n\t\n\t/** Root component */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUSceneComponent* Root;\n\n\t/** Static base plate */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUStaticMeshComponent* BasePlate;\n\n\t/** Physics enabled dummy mesh */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUStaticMeshComponent* Dummy;\n\n\t/** Physics constraint holding the dummy and base plate together */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUPhysicsConstraintComponent* PhysicsConstraint;\n\npublic:\t\n\t\n\t/** Constructor */\n\tACombatDummy();\n\n\t// ~Begin CombatDamageable interface\n\n\t\t/** Handles damage and knockback events */\n\tvirtual void ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse) override;\n\n\t/** Handles death events */\n\tvirtual void HandleDeath() override;\n\n\t/** Handles healing events */\n\tvirtual void ApplyHealing(float Healing, AActor* Healer) override;\n\n\t// ~End CombatDamageable interface\n\nprotected:\n\n\t/** Blueprint handle to apply damage effects */\n\tUFUNCTION(BlueprintImplementableEvent, Category=\"Combat\", meta = (DisplayName = \"On Dummy Damaged\"))\n\tvoid BP_OnDummyDamaged(const FVector& Location, const FVector& Direction);\n};\n","Variant_Combat/Gameplay/CombatLavaFloor.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatLavaFloor.h\"\n#include \"CombatDamageable.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nACombatLavaFloor::ACombatLavaFloor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// create the mesh\n\tRootComponent = Mesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Mesh\"));\n\n\t// bind the hit handler\n\tMesh->OnComponentHit.AddDynamic(this, &ACombatLavaFloor::OnFloorHit);\n}\n\nvoid ACombatLavaFloor::OnFloorHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\t// check if the hit actor is damageable by casting to the interface\n\tif (ICombatDamageable* Damageable = Cast<ICombatDamageable>(OtherActor))\n\t{\n\t\t// damage the actor\n\t\tDamageable->ApplyDamage(Damage, this, Hit.ImpactPoint, FVector::ZeroVector);\n\t}\n}\n","Variant_Combat/Gameplay/CombatLavaFloor.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CombatLavaFloor.generated.h\"\n\nclass UStaticMeshComponent;\nclass UPrimitiveComponent;\n\n/**\n *  A basic actor that applies damage on contact through the ICombatDamageable interface. \n */\nUCLASS(abstract)\nclass ACombatLavaFloor : public AActor\n{\n\tGENERATED_BODY()\n\t\n\t/** Floor mesh */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUStaticMeshComponent* Mesh;\n\nprotected:\n\n\t/** Amount of damage to deal on contact */\n\tUPROPERTY(EditAnywhere, Category=\"Damage\")\n\tfloat Damage = 10000.0f;\n\npublic:\t\n\n\t/** Constructor */\n\tACombatLavaFloor();\n\nprotected:\n\n\t/** Blocking hit handler */\n\tUFUNCTION()\n\tvoid OnFloorHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n};\n","Variant_Combat/Interfaces/CombatActivatable.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatActivatable.h\"","Variant_Combat/Interfaces/CombatActivatable.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/Interface.h\"\n#include \"CombatActivatable.generated.h\"\n\n/**\n *  Interactable Interface\n *  Provides a context-agnostic way of activating, deactivating or toggling actors\n */\nUINTERFACE(MinimalAPI, NotBlueprintable)\nclass UCombatActivatable : public UInterface\n{\n\tGENERATED_BODY()\n};\n\nclass ICombatActivatable\n{\n\tGENERATED_BODY()\n\npublic:\n\n\t/** Toggles the Interactable Actor */\n\tUFUNCTION(BlueprintCallable, Category=\"Activatable\")\n\tvirtual void ToggleInteraction(AActor* ActivationInstigator) = 0;\n\n\t/** Activates the Interactable Actor */\n\tUFUNCTION(BlueprintCallable, Category=\"Activatable\")\n\tvirtual void ActivateInteraction(AActor* ActivationInstigator) = 0;\n\n\t/** Deactivates the Interactable Actor */\n\tUFUNCTION(BlueprintCallable, Category=\"Activatable\")\n\tvirtual void DeactivateInteraction(AActor* ActivationInstigator) = 0;\n};\n","Variant_Combat/Interfaces/CombatAttacker.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatAttacker.h\"\n","Variant_Combat/Interfaces/CombatAttacker.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/Interface.h\"\n#include \"CombatAttacker.generated.h\"\n\n/**\n *  CombatAttacker Interface\n *  Provides common functionality to trigger attack animation events.\n */\nUINTERFACE(MinimalAPI, NotBlueprintable)\nclass UCombatAttacker : public UInterface\n{\n\tGENERATED_BODY()\n};\n\nclass ICombatAttacker\n{\n\tGENERATED_BODY()\n\npublic:\n\n\t/** Performs an attack's collision check. Usually called from a montage's AnimNotify */\n\tUFUNCTION(BlueprintCallable, Category=\"Attacker\")\n\tvirtual void DoAttackTrace(FName DamageSourceBone) = 0;\n\n\t/** Performs a combo attack's check to continue the string. Usually called from a montage's AnimNotify */\n\tUFUNCTION(BlueprintCallable, Category=\"Attacker\")\n\tvirtual void CheckCombo() = 0;\n\n\t/** Performs a charged attack's check to loop the charge animation. Usually called from a montage's AnimNotify */\n\tUFUNCTION(BlueprintCallable, Category=\"Attacker\")\n\tvirtual void CheckChargedAttack() = 0;\n};\n","Variant_Combat/Interfaces/CombatDamageable.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatDamageable.h\"\n\n// Add default functionality here for any ICombatDamageable functions that are not pure virtual.\n","Variant_Combat/Interfaces/CombatDamageable.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/Interface.h\"\n#include \"CombatDamageable.generated.h\"\n\n/**\n *  CombatDamageable interface\n *  Provides functionality to handle damage, healing, knockback and death\n */\nUINTERFACE(MinimalAPI, NotBlueprintable)\nclass UCombatDamageable : public UInterface\n{\n\tGENERATED_BODY()\n};\n\nclass ICombatDamageable\n{\n\tGENERATED_BODY()\n\npublic:\n\n\t/** Handles damage and knockback events */\n\tUFUNCTION(BlueprintCallable, Category=\"Damageable\")\n\tvirtual void ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse) = 0;\n\n\t/** Handles death events */\n\tUFUNCTION(BlueprintCallable, Category=\"Damageable\")\n\tvirtual void HandleDeath() = 0;\n\n\t/** Handles healing events */\n\tUFUNCTION(BlueprintCallable, Category=\"Damageable\")\n\tvirtual void ApplyHealing(float Healing, AActor* Healer) = 0;\n};\n","Variant_Combat/NinjaCharacter.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"NinjaCharacter.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"Variant_Combat/CombatCharacter.h\"\n#include \"CPPd1LockOnTargetComponent.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"Animation/AnimInstance.h\"\n\nANinjaCharacter::ANinjaCharacter()\n{\n\tMovementSpeed = 400.0f;\n\tRotationRate = 540.0f;\n\tLockOnRotationSpeed = 450.0f;\n\tLockOnRadius = 1800.0f;\n\tDefaultCameraDistance = 300.0f;\n}\n\nvoid ANinjaCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetCharacterMovement()->JumpMaxCount = FMath::Max(1, JumpCountMax);\n}\n\nvoid ANinjaCharacter::DoRoll()\n{\n\tif (bIsRolling || bIsAttacking) return;\n\n\tif (LockOnTarget)\n\t{\n\t\tUCPPd1LockOnTargetComponent* Comp = LockOnTarget->FindComponentByClass<UCPPd1LockOnTargetComponent>();\n\t\tif (Comp)\n\t\t{\n\t\t\tFVector ToTarget = (Comp->GetLockOnWorldLocation() - GetActorLocation()).GetSafeNormal2D();\n\t\t\tif (!ToTarget.IsNearlyZero())\n\t\t\t{\n\t\t\t\tRollDirection = (-ToTarget).GetSafeNormal2D();\n\t\t\t\tRollDirection.Z = 0.f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRollDirection = -GetActorForwardVector();\n\t\t\t\tRollDirection.Z = 0.f;\n\t\t\t\tRollDirection.Normalize();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tRollDirection = -GetActorForwardVector();\n\t\t\tRollDirection.Z = 0.f;\n\t\t\tRollDirection.Normalize();\n\t\t}\n\t}\n\telse\n\t{\n\t\tFVector LastInput = GetCharacterMovement()->GetLastInputVector();\n\t\tif (LastInput.IsNearlyZero())\n\t\t\tRollDirection = -GetActorForwardVector();\n\t\telse\n\t\t\tRollDirection = LastInput.GetSafeNormal2D();\n\t\tRollDirection.Z = 0.f;\n\t\tif (!RollDirection.Normalize())\n\t\t\tRollDirection = -GetActorForwardVector();\n\t\tRollDirection.Z = 0.f;\n\t}\n\n\tRollTimeRemaining = RollDuration;\n\tbIsRolling = true;\n\n\tif (GhostCharacter)\n\t{\n\t\tANinjaCharacter* NinjaGhost = Cast<ANinjaCharacter>(GhostCharacter);\n\t\tif (NinjaGhost)\n\t\t{\n\t\t\tNinjaGhost->RollDirection = RollDirection;\n\t\t\tNinjaGhost->RollTimeRemaining = RollDuration;\n\t\t\tNinjaGhost->bIsRolling = true;\n\t\t}\n\t}\n}\n\nvoid ANinjaCharacter::DoBackflip()\n{\n\tif (bIsFlipping || bIsRolling) return;\n\tStartFlip(ENinjaFlipType::Backflip, -GetActorForwardVector());\n}\n\nvoid ANinjaCharacter::DoFrontflip()\n{\n\tif (bIsFlipping || bIsRolling) return;\n\tStartFlip(ENinjaFlipType::Frontflip, GetActorForwardVector());\n}\n\nvoid ANinjaCharacter::DoSideflipLeft()\n{\n\tif (bIsFlipping || bIsRolling) return;\n\tStartFlip(ENinjaFlipType::SideflipLeft, -GetActorRightVector());\n}\n\nvoid ANinjaCharacter::DoSideflipRight()\n{\n\tif (bIsFlipping || bIsRolling) return;\n\tStartFlip(ENinjaFlipType::SideflipRight, GetActorRightVector());\n}\n\nvoid ANinjaCharacter::DoFlip360()\n{\n\tif (bIsFlipping || bIsRolling) return;\n\tStartFlip(ENinjaFlipType::Flip360, FVector::ZeroVector());\n}\n\nvoid ANinjaCharacter::StartFlip(ENinjaFlipType FlipType, const FVector& HorizontalDir)\n{\n\tbIsFlipping = true;\n\tCurrentFlipType = FlipType;\n\tFlipElapsed = 0.0f;\n\tMeshFlipBaseRotation = GetMesh()->GetRelativeRotation();\n\n\tswitch (FlipType)\n\t{\n\tcase ENinjaFlipType::Backflip:\n\tcase ENinjaFlipType::Frontflip:\n\tcase ENinjaFlipType::Flip360:\n\t\tFlipTotalDegrees = (FlipType == ENinjaFlipType::Flip360) ? 360.0f : 180.0f;\n\t\tbreak;\n\tcase ENinjaFlipType::SideflipLeft:\n\tcase ENinjaFlipType::SideflipRight:\n\t\tFlipTotalDegrees = 180.0f;\n\t\tbreak;\n\tdefault:\n\t\tFlipTotalDegrees = 180.0f;\n\t\tbreak;\n\t}\n\n\tFVector Impulse = FVector::UpVector * FlipUpImpulse;\n\tif (!HorizontalDir.IsNearlyZero())\n\t\tImpulse += HorizontalDir.GetSafeNormal() * FlipHorizontalImpulse;\n\tLaunchCharacter(Impulse, true, true);\n\n\tif (GhostCharacter)\n\t{\n\t\tANinjaCharacter* G = Cast<ANinjaCharacter>(GhostCharacter);\n\t\tif (G && !G->bIsFlipping)\n\t\t{\n\t\t\tG->bIsFlipping = true;\n\t\t\tG->CurrentFlipType = FlipType;\n\t\t\tG->FlipElapsed = 0.0f;\n\t\t\tG->MeshFlipBaseRotation = G->GetMesh()->GetRelativeRotation();\n\t\t\tG->FlipTotalDegrees = FlipTotalDegrees;\n\t\t\tG->LaunchCharacter(Impulse, true, true);\n\t\t}\n\t}\n}\n\nvoid ANinjaCharacter::UpdateFlipMeshRotation(float DeltaTime)\n{\n\tFlipElapsed += DeltaTime;\n\tconst float T = FMath::Clamp(FlipElapsed / FlipDuration, 0.0f, 1.0f);\n\tconst float AngleDeg = FlipTotalDegrees * T;\n\n\tfloat PitchDelta = 0.0f, RollDelta = 0.0f;\n\tswitch (CurrentFlipType)\n\t{\n\tcase ENinjaFlipType::Backflip:\n\t\tPitchDelta = AngleDeg;\n\t\tbreak;\n\tcase ENinjaFlipType::Frontflip:\n\t\tPitchDelta = -AngleDeg;\n\t\tbreak;\n\tcase ENinjaFlipType::SideflipLeft:\n\t\tRollDelta = AngleDeg;\n\t\tbreak;\n\tcase ENinjaFlipType::SideflipRight:\n\t\tRollDelta = -AngleDeg;\n\t\tbreak;\n\tcase ENinjaFlipType::Flip360:\n\t\tPitchDelta = AngleDeg;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tFRotator DeltaRot(PitchDelta, 0.0f, RollDelta);\n\tGetMesh()->SetRelativeRotation(MeshFlipBaseRotation + DeltaRot);\n}\n\nvoid ANinjaCharacter::EndFlip()\n{\n\tbIsFlipping = false;\n\tCurrentFlipType = ENinjaFlipType::None;\n\tGetMesh()->SetRelativeRotation(MeshFlipBaseRotation);\n\tif (GhostCharacter)\n\t{\n\t\tANinjaCharacter* G = Cast<ANinjaCharacter>(GhostCharacter);\n\t\tif (G) G->EndFlip();\n\t}\n}\n\nvoid ANinjaCharacter::DoKick()\n{\n\tif (bIsAttacking || !KickMontage) return;\n\tUAnimInstance* Anim = GetMesh()->GetAnimInstance();\n\tif (Anim)\n\t\tAnim->Montage_Play(KickMontage, 1.0f);\n\tif (GhostCharacter)\n\t{\n\t\tANinjaCharacter* G = Cast<ANinjaCharacter>(GhostCharacter);\n\t\tif (G && G->KickMontage) G->DoKick();\n\t}\n}\n\nbool ANinjaCharacter::ConsumeLastHitWasDuringFlip()\n{\n\tconst bool b = bLastDealtDamageWhileFlipping;\n\tbLastDealtDamageWhileFlipping = false;\n\treturn b;\n}\n\nvoid ANinjaCharacter::DoAttackTrace(FName DamageSourceBone)\n{\n\tbLastDealtDamageWhileFlipping = bIsFlipping;\n\tSuper::DoAttackTrace(DamageSourceBone);\n}\n\nvoid ANinjaCharacter::Tick(float DeltaTime)\n{\n\tif (bIsRolling)\n\t{\n\t\tRollTimeRemaining -= DeltaTime;\n\t\tFVector Vel = RollDirection * RollSpeed;\n\t\tVel.Z = GetCharacterMovement()->Velocity.Z;\n\t\tGetCharacterMovement()->Velocity = Vel;\n\t\tif (RollTimeRemaining <= 0.0f)\n\t\t{\n\t\t\tbIsRolling = false;\n\t\t\tif (GhostCharacter)\n\t\t\t{\n\t\t\t\tANinjaCharacter* G = Cast<ANinjaCharacter>(GhostCharacter);\n\t\t\t\tif (G) G->bIsRolling = false;\n\t\t\t}\n\t\t}\n\t}\n\telse if (bIsFlipping)\n\t{\n\t\tUpdateFlipMeshRotation(DeltaTime);\n\t\tif (FlipElapsed >= FlipDuration)\n\t\t\tEndFlip();\n\t}\n\telse\n\t{\n\t\tSuper::Tick(DeltaTime);\n\t}\n}\n\nvoid ANinjaCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tUEnhancedInputComponent* EIC = Cast<UEnhancedInputComponent>(PlayerInputComponent);\n\tif (!EIC) return;\n\n\tif (RollAction)\n\t\tEIC->BindAction(RollAction, ETriggerEvent::Started, this, &ANinjaCharacter::DoRoll);\n\tif (BackflipAction)\n\t\tEIC->BindAction(BackflipAction, ETriggerEvent::Started, this, &ANinjaCharacter::DoBackflip);\n\tif (FrontflipAction)\n\t\tEIC->BindAction(FrontflipAction, ETriggerEvent::Started, this, &ANinjaCharacter::DoFrontflip);\n\tif (SideflipLeftAction)\n\t\tEIC->BindAction(SideflipLeftAction, ETriggerEvent::Started, this, &ANinjaCharacter::DoSideflipLeft);\n\tif (SideflipRightAction)\n\t\tEIC->BindAction(SideflipRightAction, ETriggerEvent::Started, this, &ANinjaCharacter::DoSideflipRight);\n\tif (Flip360Action)\n\t\tEIC->BindAction(Flip360Action, ETriggerEvent::Started, this, &ANinjaCharacter::DoFlip360);\n\tif (KickAction)\n\t\tEIC->BindAction(KickAction, ETriggerEvent::Started, this, &ANinjaCharacter::DoKick);\n}\n","Variant_Combat/NinjaCharacter.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Variant_Combat/CombatCharacter.h\"\n#include \"NinjaCharacter.generated.h\"\n\nclass UInputAction;\nclass UAnimMontage;\n\n/** Type of acrobatic flip (drives mesh rotation axis and total angle) */\nUENUM(BlueprintType)\nenum class ENinjaFlipType : uint8\n{\n\tNone,\n\tBackflip   UMETA(DisplayName = \"Backflip\"),\n\tFrontflip  UMETA(DisplayName = \"Frontflip\"),\n\tSideflipLeft  UMETA(DisplayName = \"Sideflip Left\"),\n\tSideflipRight UMETA(DisplayName = \"Sideflip Right\"),\n\tFlip360    UMETA(DisplayName = \"360 Flip\")\n};\n\n/**\n * OoT-style ninja + acrobatics: double jump, backflip, frontflip, sideflip, 360 flip.\n * Punch/kick (combo + charged + optional kick) work during flips — combine motion freely.\n */\nUCLASS(BlueprintType, Blueprintable)\nclass CPPd1_API ANinjaCharacter : public ACombatCharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tANinjaCharacter();\n\n\t// ---- Roll (unchanged) ----\n\tUPROPERTY(EditAnywhere, Category = \"Input\")\n\tTObjectPtr<UInputAction> RollAction;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Ninja|Roll\", meta = (ClampMin = 0.1f, ClampMax = 1.0f, Units = \"s\"))\n\tfloat RollDuration = 0.4f;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Ninja|Roll\", meta = (ClampMin = 0, Units = \"cm/s\"))\n\tfloat RollSpeed = 800.0f;\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Ninja|Roll\")\n\tbool bIsRolling = false;\n\tUFUNCTION(BlueprintCallable, Category = \"Ninja\")\n\tvoid DoRoll();\n\n\t// ---- Double jump ----\n\t/** Number of jumps allowed (1 = single, 2 = double jump). */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Ninja|Acrobatics\", meta = (ClampMin = 1, ClampMax = 3))\n\tint32 JumpCountMax = 2;\n\n\t// ---- Flips ----\n\tUPROPERTY(EditAnywhere, Category = \"Input|Flips\")\n\tTObjectPtr<UInputAction> BackflipAction;\n\tUPROPERTY(EditAnywhere, Category = \"Input|Flips\")\n\tTObjectPtr<UInputAction> FrontflipAction;\n\tUPROPERTY(EditAnywhere, Category = \"Input|Flips\")\n\tTObjectPtr<UInputAction> SideflipLeftAction;\n\tUPROPERTY(EditAnywhere, Category = \"Input|Flips\")\n\tTObjectPtr<UInputAction> SideflipRightAction;\n\tUPROPERTY(EditAnywhere, Category = \"Input|Flips\")\n\tTObjectPtr<UInputAction> Flip360Action;\n\n\t/** Flip duration in seconds (mesh rotation + arc). */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Ninja|Acrobatics\", meta = (ClampMin = 0.2f, ClampMax = 1.5f, Units = \"s\"))\n\tfloat FlipDuration = 0.5f;\n\t/** Upward impulse when starting a flip (adds to any existing velocity). */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Ninja|Acrobatics\", meta = (ClampMin = 0, Units = \"cm/s\"))\n\tfloat FlipUpImpulse = 350.0f;\n\t/** Horizontal impulse scale (forward/back/side) when starting a flip. */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Ninja|Acrobatics\", meta = (ClampMin = 0, Units = \"cm/s\"))\n\tfloat FlipHorizontalImpulse = 200.0f;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Ninja|Acrobatics\")\n\tbool bIsFlipping = false;\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Ninja|Acrobatics\")\n\tENinjaFlipType CurrentFlipType = ENinjaFlipType::None;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Ninja\")\n\tvoid DoBackflip();\n\tUFUNCTION(BlueprintCallable, Category = \"Ninja\")\n\tvoid DoFrontflip();\n\tUFUNCTION(BlueprintCallable, Category = \"Ninja\")\n\tvoid DoSideflipLeft();\n\tUFUNCTION(BlueprintCallable, Category = \"Ninja\")\n\tvoid DoSideflipRight();\n\tUFUNCTION(BlueprintCallable, Category = \"Ninja\")\n\tvoid DoFlip360();\n\n\t// ---- Kick (optional; combine with flips) ----\n\tUPROPERTY(EditAnywhere, Category = \"Input\")\n\tTObjectPtr<UInputAction> KickAction;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Ninja|Combat\")\n\tTObjectPtr<UAnimMontage> KickMontage;\n\tUFUNCTION(BlueprintCallable, Category = \"Ninja\")\n\tvoid DoKick();\n\n\t/** Returns true if the last damage we dealt was during a flip (for style scoring); clears the flag. */\n\tUFUNCTION(BlueprintCallable, Category = \"Ninja\")\n\tbool ConsumeLastHitWasDuringFlip();\n\n\tvirtual void DoAttackTrace(FName DamageSourceBone) override;\n\nprotected:\n\t/** Set when we deal damage while flipping; read by ConsumeLastHitWasDuringFlip for scoring. */\n\tbool bLastDealtDamageWhileFlipping = false;\n\tFVector RollDirection;\n\tfloat RollTimeRemaining = 0.0f;\n\n\t/** Mesh rotation at flip start (so we can add flip delta and reset after). */\n\tFRotator MeshFlipBaseRotation;\n\tfloat FlipElapsed = 0.0f;\n\t/** Total degrees to rotate for current flip (180 or 360). */\n\tfloat FlipTotalDegrees = 0.0f;\n\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t/** Start a flip (impulse + state). Can be called from ground or air. */\n\tvoid StartFlip(ENinjaFlipType FlipType, const FVector& HorizontalDir);\n\t/** Update mesh rotation for current flip; call when bIsFlipping. */\n\tvoid UpdateFlipMeshRotation(float DeltaTime);\n\t/** End flip and reset mesh. */\n\tvoid EndFlip();\n};\n","Variant_Combat/NinjaGameMode.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"NinjaGameMode.h\"\n#include \"NinjaCharacter.h\"\n#include \"NinjaPlayerController.h\"\n\nANinjaGameMode::ANinjaGameMode()\n{\n\tDefaultPawnClass = ANinjaCharacter::StaticClass();\n\tPlayerControllerClass = ANinjaPlayerController::StaticClass();\n}\n","Variant_Combat/NinjaGameMode.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Variant_Combat/CombatGameMode.h\"\n#include \"NinjaGameMode.generated.h\"\n\n/**\n * Combat game mode with ninja as default character. P1 and P2 (and ghost when solo) use NinjaCharacter.\n * Place CombatWaveSpawner in the level and set Enemy Class to NinjaEnemy (or a Blueprint) for waves.\n */\nUCLASS(BlueprintType, Blueprintable)\nclass CPPd1_API ANinjaGameMode : public ACombatGameMode\n{\n\tGENERATED_BODY()\n\npublic:\n\tANinjaGameMode();\n};\n","Variant_Combat/NinjaPlayerController.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"NinjaPlayerController.h\"\n#include \"NinjaCharacter.h\"\n\nANinjaPlayerController::ANinjaPlayerController()\n{\n\tCharacterClass = ANinjaCharacter::StaticClass();\n}\n","Variant_Combat/NinjaPlayerController.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Variant_Combat/CombatPlayerController.h\"\n#include \"NinjaPlayerController.generated.h\"\n\n/**\n * Player controller for the ninja game. Uses NinjaCharacter for spawn and respawn (P1, P2, ghost).\n */\nUCLASS()\nclass CPPd1_API ANinjaPlayerController : public ACombatPlayerController\n{\n\tGENERATED_BODY()\n\npublic:\n\tANinjaPlayerController();\n};\n","Variant_Combat/UI/CombatHUD.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Variant_Combat/UI/CombatHUD.h\"\n#include \"Variant_Combat/CombatCharacter.h\"\n#include \"Variant_Combat/CombatStaminaSystem.h\"\n#include \"Variant_Combat/CombatFlowSystem.h\"\n#include \"Components/ProgressBar.h\"\n#include \"Components/TextBlock.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Variant_Combat/AI/CombatWaveSpawner.h\"\n#include \"Variant_Combat/AI/CombatEnemy.h\"\n#include \"Variant_Combat/CombatGameMode.h\"\n\nUCombatHUD::UCombatHUD(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\tbAutoUpdate = true;\n\tUpdateRate = 0.1f;\n}\n\nvoid UCombatHUD::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\n\t// Try to find character automatically if not set\n\tif (!TargetCharacter)\n\t{\n\t\tif (APlayerController* PC = GetOwningPlayer())\n\t\t{\n\t\t\tif (APawn* Pawn = PC->GetPawn())\n\t\t\t{\n\t\t\t\tSetCharacter(Cast<ACombatCharacter>(Pawn));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid UCombatHUD::NativeTick(const FGeometry& MyGeometry, float InDeltaTime)\n{\n\tSuper::NativeTick(MyGeometry, InDeltaTime);\n\n\tif (bAutoUpdate)\n\t{\n\t\tLastUpdateTime += InDeltaTime;\n\t\tif (LastUpdateTime >= UpdateRate)\n\t\t{\n\t\t\tUpdateFromCharacter();\n\t\t\tLastUpdateTime = 0.0f;\n\t\t}\n\t}\n}\n\nvoid UCombatHUD::SetCharacter(ACombatCharacter* Character)\n{\n\tTargetCharacter = Character;\n\tUpdateFromCharacter();\n}\n\nvoid UCombatHUD::UpdateHealth(float HealthPercent)\n{\n\tif (HealthBar)\n\t{\n\t\tHealthBar->SetPercent(FMath::Clamp(HealthPercent, 0.0f, 1.0f));\n\t}\n}\n\nvoid UCombatHUD::UpdateStamina(float StaminaPercent)\n{\n\tif (StaminaBar)\n\t{\n\t\tStaminaBar->SetPercent(FMath::Clamp(StaminaPercent, 0.0f, 1.0f));\n\t}\n}\n\nvoid UCombatHUD::UpdateFlow(float FlowPercent)\n{\n\tif (FlowBar)\n\t{\n\t\tFlowBar->SetPercent(FMath::Clamp(FlowPercent, 0.0f, 1.0f));\n\t}\n}\n\nvoid UCombatHUD::UpdateWaveInfo(int32 CurrentWave, int32 EnemiesRemaining)\n{\n\tif (WaveNumberText)\n\t{\n\t\tWaveNumberText->SetText(FText::FromString(FString::Printf(TEXT(\"Wave %d\"), CurrentWave)));\n\t}\n\n\tif (EnemiesRemainingText)\n\t{\n\t\tEnemiesRemainingText->SetText(FText::FromString(FString::Printf(TEXT(\"Enemies: %d\"), EnemiesRemaining)));\n\t}\n}\n\nvoid UCombatHUD::SetWaveInfoVisible(bool bVisible)\n{\n\tif (WaveInfoPanel)\n\t{\n\t\tWaveInfoPanel->SetVisibility(bVisible ? ESlateVisibility::Visible : ESlateVisibility::Collapsed);\n\t}\n}\n\nvoid UCombatHUD::UpdateFromCharacter()\n{\n\tif (!TargetCharacter)\n\t{\n\t\treturn;\n\t}\n\n\t// Update health\n\tfloat CurrentHP = TargetCharacter->GetCurrentHP();\n\tfloat MaxHP = TargetCharacter->GetMaxHP();\n\tif (MaxHP > 0.0f)\n\t{\n\t\tUpdateHealth(CurrentHP / MaxHP);\n\t}\n\n\t// Update stamina\n\tif (UCombatStaminaSystem* StaminaSystem = TargetCharacter->FindComponentByClass<UCombatStaminaSystem>())\n\t{\n\t\tUpdateStamina(StaminaSystem->GetStamina());\n\t}\n\n\t// Update flow\n\tif (UCombatFlowSystem* FlowSystem = TargetCharacter->FindComponentByClass<UCombatFlowSystem>())\n\t{\n\t\tUpdateFlow(FlowSystem->GetFlowMeter());\n\t}\n\n\t// Update wave info\n\tif (UWorld* World = GetWorld())\n\t{\n\t\tif (ACombatGameMode* GameMode = Cast<ACombatGameMode>(UGameplayStatics::GetGameMode(World)))\n\t\t{\n\t\t\tif (GameMode && GameMode->WaveSpawner)\n\t\t\t{\n\t\t\t\tACombatWaveSpawner* WaveSpawner = GameMode->WaveSpawner;\n\t\t\t\t// Get current wave and enemy count\n\t\t\t\tTArray<ACombatEnemy*> CurrentEnemies = WaveSpawner->GetCurrentWaveEnemies();\n\t\t\t\tint32 WaveNumber = WaveSpawner->GetCurrentWaveIndex() + 1; // 1-indexed for display\n\t\t\t\tUpdateWaveInfo(WaveNumber, CurrentEnemies.Num());\n\t\t\t\tSetWaveInfoVisible(true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSetWaveInfoVisible(false);\n\t\t\t}\n\t\t}\n\t}\n}\n","Variant_Combat/UI/CombatHUD.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"CPPd1.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"CombatHUD.generated.h\"\n\nclass ACombatCharacter;\nclass UCombatStaminaSystem;\nclass UCombatFlowSystem;\nclass UProgressBar;\nclass UTextBlock;\n\n/**\n * Main HUD widget for combat - displays health, stamina, flow, wave info\n * Create a Blueprint from this to design the visual layout\n */\nUCLASS(BlueprintType, Blueprintable)\nclass CPPd1_API UCombatHUD : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUCombatHUD(const FObjectInitializer& ObjectInitializer);\n\n\tvirtual void NativeConstruct() override;\n\tvirtual void NativeTick(const FGeometry& MyGeometry, float InDeltaTime) override;\n\n\t/** Set the character to display stats for */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|HUD\")\n\tvoid SetCharacter(ACombatCharacter* Character);\n\n\t/** Update health bar (0.0 to 1.0) */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|HUD\")\n\tvoid UpdateHealth(float HealthPercent);\n\n\t/** Update stamina bar (0.0 to 1.0) */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|HUD\")\n\tvoid UpdateStamina(float StaminaPercent);\n\n\t/** Update flow meter (0.0 to 1.0) */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|HUD\")\n\tvoid UpdateFlow(float FlowPercent);\n\n\t/** Update wave info */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|HUD\")\n\tvoid UpdateWaveInfo(int32 CurrentWave, int32 EnemiesRemaining);\n\n\t/** Show/hide wave info */\n\tUFUNCTION(BlueprintCallable, Category = \"Combat|HUD\")\n\tvoid SetWaveInfoVisible(bool bVisible);\n\nprotected:\n\t/** The character we're displaying stats for */\n\tUPROPERTY(BlueprintReadOnly, Category = \"Combat|HUD\")\n\tTObjectPtr<ACombatCharacter> TargetCharacter;\n\n\t/** Health bar widget (set in Blueprint) */\n\tUPROPERTY(BlueprintReadOnly, meta = (BindWidget), Category = \"Combat|HUD\")\n\tTObjectPtr<UProgressBar> HealthBar;\n\n\t/** Stamina bar widget (set in Blueprint) */\n\tUPROPERTY(BlueprintReadOnly, meta = (BindWidget), Category = \"Combat|HUD\")\n\tTObjectPtr<UProgressBar> StaminaBar;\n\n\t/** Flow meter bar widget (set in Blueprint) */\n\tUPROPERTY(BlueprintReadOnly, meta = (BindWidget), Category = \"Combat|HUD\")\n\tTObjectPtr<UProgressBar> FlowBar;\n\n\t/** Wave number text (set in Blueprint) */\n\tUPROPERTY(BlueprintReadOnly, meta = (BindWidget), Category = \"Combat|HUD\")\n\tTObjectPtr<UTextBlock> WaveNumberText;\n\n\t/** Enemies remaining text (set in Blueprint) */\n\tUPROPERTY(BlueprintReadOnly, meta = (BindWidget), Category = \"Combat|HUD\")\n\tTObjectPtr<UTextBlock> EnemiesRemainingText;\n\n\t/** Wave info panel (set in Blueprint) */\n\tUPROPERTY(BlueprintReadOnly, meta = (BindWidget), Category = \"Combat|HUD\")\n\tTObjectPtr<UWidget> WaveInfoPanel;\n\n\t/** Auto-update from character components */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|HUD\")\n\tbool bAutoUpdate = true;\n\n\t/** Update rate (how often to refresh from character) */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Combat|HUD\", meta = (ClampMin = 0.0f))\n\tfloat UpdateRate = 0.1f; // Update 10 times per second\n\n\tfloat LastUpdateTime = 0.0f;\n\n\tvoid UpdateFromCharacter();\n};\n","Variant_Combat/UI/CombatLifeBar.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatLifeBar.h\"\n\n","Variant_Combat/UI/CombatLifeBar.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"CombatLifeBar.generated.h\"\n\n/**\n *  A basic life bar user widget.\n */\nUCLASS(abstract)\nclass UCombatLifeBar : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\n\t/** Sets the life bar to the provided 0-1 percentage value*/\n\tUFUNCTION(BlueprintImplementableEvent, Category=\"Life Bar\")\n\tvoid SetLifePercentage(float Percent);\n\n\t// Sets the life bar fill color\n\tUFUNCTION(BlueprintImplementableEvent, Category=\"Life Bar\")\n\tvoid SetBarColor(FLinearColor Color);\n};\n","Variant_Platforming/Animation/AnimNotify_EndDash.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"AnimNotify_EndDash.h\"\n#include \"PlatformingCharacter.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n\nvoid UAnimNotify_EndDash::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference)\n{\n\t// cast the owner to the attacker interface\n\tif (APlatformingCharacter* PlatformingCharacter = Cast<APlatformingCharacter>(MeshComp->GetOwner()))\n\t{\n\t\t// tell the actor to end the dash\n\t\tPlatformingCharacter->EndDash();\n\t}\n}\n\nFString UAnimNotify_EndDash::GetNotifyName_Implementation() const\n{\n\treturn FString(\"End Dash\");\n}\n","Variant_Platforming/Animation/AnimNotify_EndDash.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Animation/AnimNotifies/AnimNotify.h\"\n#include \"AnimNotify_EndDash.generated.h\"\n\n/**\n *  AnimNotify to finish the dash animation and restore player control\n */\nUCLASS()\nclass UAnimNotify_EndDash : public UAnimNotify\n{\n\tGENERATED_BODY()\n\t\npublic:\n\n\t/** Perform the Anim Notify */\n\tvirtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference) override;\n\n\t/** Get the notify name */\n\tvirtual FString GetNotifyName_Implementation() const override;\n};\n","Variant_Platforming/PlatformingCharacter.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"PlatformingCharacter.h\"\n\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"TimerManager.h\"\n#include \"Engine/LocalPlayer.h\"\n\nAPlatformingCharacter::APlatformingCharacter()\n{\n \tPrimaryActorTick.bCanEverTick = true;\n\n\t// initialize the flags\n\tbHasWallJumped = false;\n\tbHasDoubleJumped = false;\n\tbHasDashed = false;\n\tbIsDashing = false;\n\n\t// bind the attack montage ended delegate\n\tOnDashMontageEnded.BindUObject(this, &APlatformingCharacter::DashMontageEnded);\n\n\t// enable press and hold jump\n\tJumpMaxHoldTime = 0.4f;\n\n\t// set the jump max count to 3 so we can double jump and check for coyote time jumps\n\tJumpMaxCount = 3;\n\n\t// Set size for collision capsule\n\tGetCapsuleComponent()->InitCapsuleSize(35.0f, 90.0f);\n\n\t// don't rotate the mesh when the controller rotates\n\tbUseControllerRotationYaw = false;\n\t\n\t// Configure character movement\n\tGetCharacterMovement()->GravityScale = 2.5f;\n\tGetCharacterMovement()->MaxAcceleration = 1500.0f;\n\tGetCharacterMovement()->BrakingFrictionFactor = 1.0f;\n\tGetCharacterMovement()->bUseSeparateBrakingFriction = true;\n\n\tGetCharacterMovement()->GroundFriction = 4.0f;\n\tGetCharacterMovement()->MaxWalkSpeed = 750.0f;\n\tGetCharacterMovement()->MinAnalogWalkSpeed = 20.0f;\n\tGetCharacterMovement()->BrakingDecelerationWalking = 2500.0f;\n\tGetCharacterMovement()->PerchRadiusThreshold = 15.0f;\n\n\tGetCharacterMovement()->JumpZVelocity = 350.0f;\n\tGetCharacterMovement()->BrakingDecelerationFalling = 750.0f;\n\tGetCharacterMovement()->AirControl = 1.0f;\n\n\tGetCharacterMovement()->RotationRate = FRotator(0.0f, 500.0f, 0.0f);\n\tGetCharacterMovement()->bOrientRotationToMovement = true;\n\n\tGetCharacterMovement()->NavAgentProps.AgentRadius = 42.0;\n\tGetCharacterMovement()->NavAgentProps.AgentHeight = 192.0;\n\n\t// create the camera boom\n\tCameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraBoom\"));\n\tCameraBoom->SetupAttachment(RootComponent);\n\n\tCameraBoom->TargetArmLength = 400.0f;\n\tCameraBoom->bUsePawnControlRotation = true;\n\tCameraBoom->bEnableCameraLag = true;\n\tCameraBoom->CameraLagSpeed = 8.0f;\n\tCameraBoom->bEnableCameraRotationLag = true;\t\n\tCameraBoom->CameraRotationLagSpeed = 8.0f;\n\n\t// create the orbiting camera\n\tFollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FollowCamera\"));\n\tFollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName);\n\tFollowCamera->bUsePawnControlRotation = false;\n}\n\nvoid APlatformingCharacter::Move(const FInputActionValue& Value)\n{\n\tFVector2D MovementVector = Value.Get<FVector2D>();\n\n\t// route the input\n\tDoMove(MovementVector.X, MovementVector.Y);\n}\n\nvoid APlatformingCharacter::Look(const FInputActionValue& Value)\n{\n\tFVector2D LookAxisVector = Value.Get<FVector2D>();\n\n\t// route the input\n\tDoLook(LookAxisVector.X, LookAxisVector.Y);\n}\n\n\nvoid APlatformingCharacter::Dash()\n{\n\t// route the input\n\tDoDash();\n}\n\nvoid APlatformingCharacter::MultiJump()\n{\n\t// ignore jumps while dashing\n\tif(bIsDashing)\n\t\treturn;\n\n\t// are we already in the air?\n\tif (GetCharacterMovement()->IsFalling())\n\t{\n\n\t\t// have we already wall jumped?\n\t\tif (!bHasWallJumped)\n\t\t{\n\t\t\t// run a sphere sweep to check if we're in front of a wall\n\t\t\tFHitResult OutHit;\n\n\t\t\tconst FVector TraceStart = GetActorLocation();\n\t\t\tconst FVector TraceEnd = TraceStart + (GetActorForwardVector() * WallJumpTraceDistance);\n\t\t\tconst FCollisionShape TraceShape = FCollisionShape::MakeSphere(WallJumpTraceRadius);\n\n\t\t\tFCollisionQueryParams QueryParams;\n\t\t\tQueryParams.AddIgnoredActor(this);\n\n\t\t\tif (GetWorld()->SweepSingleByChannel(OutHit, TraceStart, TraceEnd, FQuat(), ECollisionChannel::ECC_Visibility, TraceShape, QueryParams))\n\t\t\t{\n\t\t\t\t// rotate the character to face away from the wall, so we're correctly oriented for the next wall jump\n\t\t\t\tFRotator WallOrientation = OutHit.ImpactNormal.ToOrientationRotator();\n\t\t\t\tWallOrientation.Pitch = 0.0f;\n\t\t\t\tWallOrientation.Roll = 0.0f;\n\n\t\t\t\tSetActorRotation(WallOrientation);\n\n\t\t\t\t// apply a launch impulse to the character to perform the actual wall jump\n\t\t\t\tconst FVector WallJumpImpulse = (OutHit.ImpactNormal * WallJumpBounceImpulse) + (FVector::UpVector * WallJumpVerticalImpulse);\n\n\t\t\t\tLaunchCharacter(WallJumpImpulse, true, true);\n\n\t\t\t\t// enable the jump trail\n\t\t\t\tSetJumpTrailState(true);\n\n\t\t\t\t// raise the wall jump flag to prevent an immediate second wall jump\n\t\t\t\tbHasWallJumped = true;\n\n\t\t\t\tGetWorld()->GetTimerManager().SetTimer(WallJumpTimer, this, &APlatformingCharacter::ResetWallJump, DelayBetweenWallJumps, false);\n\t\t\t}\n\t\t\t// no wall jump, try a double jump next\n\t\t\telse\n\t\t\t{\n\t\t\t\t// are we still within coyote time frames?\n\t\t\t\tif (GetWorld()->GetTimeSeconds() - LastFallTime < MaxCoyoteTime)\n\t\t\t\t{\n\t\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Coyote Jump\"));\n\n\t\t\t\t\t// use the built-in CMC functionality to do the jump\n\t\t\t\t\tJump();\n\n\t\t\t\t\t// enable the jump trail\n\t\t\t\t\tSetJumpTrailState(true);\n\n\t\t\t\t// no coyote time jump\n\t\t\t\t} else {\n\n\t\t\t\t\t// only double jump once while we're in the air\n\t\t\t\t\tif (!bHasDoubleJumped)\n\t\t\t\t\t{\n\t\t\t\t\t\tbHasDoubleJumped = true;\n\n\t\t\t\t\t\t// use the built-in CMC functionality to do the double jump\n\t\t\t\t\t\tJump();\n\n\t\t\t\t\t\t// enable the jump trail\n\t\t\t\t\t\tSetJumpTrailState(true);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t}\n\telse\n\t{\n\t\t// we're grounded so just do a regular jump\n\t\tJump();\n\n\t\t// activate the jump trail\n\t\tSetJumpTrailState(true);\n\t}\n}\n\nvoid APlatformingCharacter::ResetWallJump()\n{\n\t// reset the wall jump input lock\n\tbHasWallJumped = false;\n}\n\nvoid APlatformingCharacter::DoMove(float Right, float Forward)\n{\n\tif (GetController() != nullptr)\n\t{\n\t\t// momentarily disable movement inputs if we've just wall jumped\n\t\tif (!bHasWallJumped)\n\t\t{\n\t\t\t// find out which way is forward\n\t\t\tconst FRotator Rotation = GetController()->GetControlRotation();\n\t\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\n\n\t\t\t// get forward vector\n\t\t\tconst FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n\n\t\t\t// get right vector \n\t\t\tconst FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n\n\t\t\t// add movement \n\t\t\tAddMovementInput(ForwardDirection, Forward);\n\t\t\tAddMovementInput(RightDirection, Right);\n\t\t}\n\t}\n}\n\nvoid APlatformingCharacter::DoLook(float Yaw, float Pitch)\n{\n\tif (GetController() != nullptr)\n\t{\n\t\t// add yaw and pitch input to controller\n\t\tAddControllerYawInput(Yaw);\n\t\tAddControllerPitchInput(Pitch);\n\t}\n}\n\nvoid APlatformingCharacter::DoDash()\n{\n\t// ignore the input if we've already dashed and have yet to reset\n\tif (bHasDashed)\n\t\treturn;\n\n\t// raise the dash flags\n\tbIsDashing = true;\n\tbHasDashed = true;\n\n\t// disable gravity while dashing\n\tGetCharacterMovement()->GravityScale = 0.0f;\n\n\t// reset the character velocity so we don't carry momentum into the dash\n\tGetCharacterMovement()->Velocity = FVector::ZeroVector;\n\n\t// enable the jump trails\n\tSetJumpTrailState(true);\n\n\t// play the dash montage\n\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t{\n\t\tconst float MontageLength = AnimInstance->Montage_Play(DashMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);\n\n\t\t// has the montage played successfully?\n\t\tif (MontageLength > 0.0f)\n\t\t{\n\t\t\tAnimInstance->Montage_SetEndDelegate(OnDashMontageEnded, DashMontage);\n\t\t}\n\t}\n}\n\nvoid APlatformingCharacter::DoJumpStart()\n{\n\t// handle special jump cases\n\tMultiJump();\n}\n\nvoid APlatformingCharacter::DoJumpEnd()\n{\n\t// stop jumping\n\tStopJumping();\n}\n\nvoid APlatformingCharacter::DashMontageEnded(UAnimMontage* Montage, bool bInterrupted)\n{\n\t// if the montage was interrupted, end the dash\n\tif (bInterrupted)\n\t{\n\t\tEndDash();\n\t}\n}\n\nvoid APlatformingCharacter::EndDash()\n{\n\t// restore gravity\n\tGetCharacterMovement()->GravityScale = 2.5f;\n\n\t// reset the dashing flag\n\tbIsDashing = false;\n\n\t// are we grounded after the dash?\n\tif (GetCharacterMovement()->IsMovingOnGround())\n\t{\n\t\t// reset the dash usage flag, since we won't receive a landed event\n\t\tbHasDashed = false;\n\n\t\t// deactivate the jump trails\n\t\tSetJumpTrailState(false);\n\t}\n}\n\nbool APlatformingCharacter::HasDoubleJumped() const\n{\n\treturn bHasDoubleJumped;\n}\n\nbool APlatformingCharacter::HasWallJumped() const\n{\n\treturn bHasWallJumped;\n}\n\nvoid APlatformingCharacter::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\t// clear the wall jump reset timer\n\tGetWorld()->GetTimerManager().ClearTimer(WallJumpTimer);\n}\n\nvoid APlatformingCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\t// Set up action bindings\n\tif (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))\n\t{\n\n\t\t// Jumping\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Started, this, &APlatformingCharacter::DoJumpStart);\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Completed, this, &APlatformingCharacter::DoJumpEnd);\n\n\t\t// Moving\n\t\tEnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &APlatformingCharacter::Move);\n\t\tEnhancedInputComponent->BindAction(MouseLookAction, ETriggerEvent::Triggered, this, &APlatformingCharacter::Look);\n\n\t\t// Looking\n\t\tEnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &APlatformingCharacter::Look);\n\n\t\t// Dashing\n\t\tEnhancedInputComponent->BindAction(DashAction, ETriggerEvent::Triggered, this, &APlatformingCharacter::Dash);\n\t}\n}\n\nvoid APlatformingCharacter::Landed(const FHitResult& Hit)\n{\n\tSuper::Landed(Hit);\n\n\t// reset the double jump and dash flags\n\tbHasDoubleJumped = false;\n\tbHasDashed = false;\n\n\t// deactivate the jump trail\n\tSetJumpTrailState(false);\n}\n\nvoid APlatformingCharacter::OnMovementModeChanged(EMovementMode PrevMovementMode, uint8 PreviousCustomMode /*= 0*/)\n{\n\tSuper::OnMovementModeChanged(PrevMovementMode, PreviousCustomMode);\n\n\t// are we falling?\n\tif (GetCharacterMovement()->MovementMode == EMovementMode::MOVE_Falling)\n\t{\n\t\t// save the game time when we started falling, so we can check it later for coyote time jumps\n\t\tLastFallTime = GetWorld()->GetTimeSeconds();\n\t}\n}\n\n","Variant_Platforming/PlatformingCharacter.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"PlatformingCharacter.generated.h\"\n\n\nclass USpringArmComponent;\nclass UCameraComponent;\nclass UInputAction;\nstruct FInputActionValue;\nclass UAnimMontage;\n\n/**\n *  An enhanced Third Person Character with the following functionality:\n *  - Platforming game character movement physics\n *  - Press and Hold Jump\n *  - Double Jump\n *  - Wall Jump\n *  - Dash\n */\nUCLASS(abstract)\nclass APlatformingCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\n\t/** Camera boom positioning the camera behind the character */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUSpringArmComponent* CameraBoom;\n\n\t/** Follow camera */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUCameraComponent* FollowCamera;\n\t\nprotected:\n\n\t/** Jump Input Action */\n\tUPROPERTY(EditAnywhere, Category=\"Input\")\n\tUInputAction* JumpAction;\n\n\t/** Move Input Action */\n\tUPROPERTY(EditAnywhere, Category=\"Input\")\n\tUInputAction* MoveAction;\n\n\t/** Look Input Action */\n\tUPROPERTY(EditAnywhere, Category=\"Input\")\n\tUInputAction* LookAction;\n\n\t/** Mouse Look Input Action */\n\tUPROPERTY(EditAnywhere, Category=\"Input\")\n\tUInputAction* MouseLookAction;\n\n\t/** Dash Input Action */\n\tUPROPERTY(EditAnywhere, Category=\"Input\")\n\tUInputAction* DashAction;\n\npublic:\n\n\t/** Constructor */\n\tAPlatformingCharacter();\n\nprotected:\n\n\t/** Called for movement input */\n\tvoid Move(const FInputActionValue& Value);\n\n\t/** Called for looking input */\n\tvoid Look(const FInputActionValue& Value);\n\n\t/** Called for dash input */\n\tvoid Dash();\n\n\t/** Called for jump pressed to check for advanced multi-jump conditions */\n\tvoid MultiJump();\n\n\t/** Resets the wall jump input lock */\n\tvoid ResetWallJump();\n\npublic:\n\n\t/** Handles move inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoMove(float Right, float Forward);\n\n\t/** Handles look inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoLook(float Yaw, float Pitch);\n\n\t/** Handles dash inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoDash();\n\n\t/** Handles jump pressed inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoJumpStart();\n\n\t/** Handles jump pressed inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoJumpEnd();\n\nprotected:\n\n\t/** Called from a delegate when the dash montage ends */\n\tvoid DashMontageEnded(UAnimMontage* Montage, bool bInterrupted);\n\n\t/** Passes control to Blueprint to enable or disable jump trails */\n\tUFUNCTION(BlueprintImplementableEvent, Category=\"Platforming\")\n\tvoid SetJumpTrailState(bool bEnabled);\n\npublic:\n\n\t/** Ends the dash state */\n\tvoid EndDash();\n\npublic:\n\n\t/** Returns true if the character has just double jumped */\n\tUFUNCTION(BlueprintPure, Category=\"Platforming\")\n\tbool HasDoubleJumped() const;\n\n\t/** Returns true if the character has just wall jumped */\n\tUFUNCTION(BlueprintPure, Category=\"Platforming\")\n\tbool HasWallJumped() const;\n\npublic:\t\n\t\n\t/** EndPlay cleanup */\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n\n\t/** Sets up input action bindings */\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t/** Handle landings to reset dash and advanced jump state */\n\tvirtual void Landed(const FHitResult& Hit) override;\n\n\t/** Handle movement mode changes to keep track of coyote time jumps */\n\tvirtual void OnMovementModeChanged(EMovementMode PrevMovementMode, uint8 PreviousCustomMode = 0) override;\n\nprotected:\n\n\t/** movement state flag bits, packed into a uint8 for memory efficiency */\n\tuint8 bHasWallJumped : 1;\n\tuint8 bHasDoubleJumped : 1;\n\tuint8 bHasDashed : 1;\n\tuint8 bIsDashing : 1;\n\n\t/** timer for wall jump input reset */\n\tFTimerHandle WallJumpTimer;\n\n\t/** Dash montage ended delegate */\n\tFOnMontageEnded OnDashMontageEnded;\n\n\t/** Distance to trace ahead of the character to look for walls to jump from */\n\tUPROPERTY(EditAnywhere, Category=\"Wall Jump\", meta = (ClampMin = 0, ClampMax = 1000, Units = \"cm\"))\n\tfloat WallJumpTraceDistance = 50.0f;\n\n\t/** Radius of the wall jump sphere trace check */\n\tUPROPERTY(EditAnywhere, Category=\"Wall Jump\", meta = (ClampMin = 0, ClampMax = 100, Units = \"cm\"))\n\tfloat WallJumpTraceRadius = 25.0f;\n\n\t/** Impulse to apply away from the wall when wall jumping */\n\tUPROPERTY(EditAnywhere, Category=\"Wall Jump\", meta = (ClampMin = 0, ClampMax = 10000, Units = \"cm/s\"))\n\tfloat WallJumpBounceImpulse = 800.0f;\n\n\t/** Vertical impulse to apply when wall jumping */\n\tUPROPERTY(EditAnywhere, Category=\"Wall Jump\", meta = (ClampMin = 0, ClampMax = 10000, Units = \"cm/s\"))\n\tfloat WallJumpVerticalImpulse = 900.0f;\n\n\t/** Time to ignore jump inputs after a wall jump */\n\tUPROPERTY(EditAnywhere, Category=\"Wall Jump\", meta = (ClampMin = 0, ClampMax = 5, Units = \"s\"))\n\tfloat DelayBetweenWallJumps = 0.1f;\n\n\t/** AnimMontage to use for the Dash action */\n\tUPROPERTY(EditAnywhere, Category=\"Dash\")\n\tUAnimMontage* DashMontage;\n\n\t/** Last recorded time when this character started falling */\n\tfloat LastFallTime = 0.0f;\n\n\t/** Max amount of time that can pass since we started falling when we allow a regular jump */\n\tUPROPERTY(EditAnywhere, Category=\"Coyote Time\", meta = (ClampMin = 0, ClampMax = 5, Units = \"s\"))\n\tfloat MaxCoyoteTime = 0.16f;\n\npublic:\n\t/** Returns CameraBoom subobject **/\n\tFORCEINLINE class USpringArmComponent* GetCameraBoom() const { return CameraBoom; }\n\n\t/** Returns FollowCamera subobject **/\n\tFORCEINLINE class UCameraComponent* GetFollowCamera() const { return FollowCamera; }\n\n};\n","Variant_Platforming/PlatformingGameMode.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"Variant_Platforming/PlatformingGameMode.h\"\n\nAPlatformingGameMode::APlatformingGameMode()\n{\n\t// stub\n}","Variant_Platforming/PlatformingGameMode.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"PlatformingGameMode.generated.h\"\n\n/**\n *  Simple GameMode for a third person platforming game\n */\nUCLASS()\nclass APlatformingGameMode : public AGameModeBase\n{\n\tGENERATED_BODY()\n\t\npublic:\n\n\t/** Constructor */\n\tAPlatformingGameMode();\n};\n","Variant_Platforming/PlatformingPlayerController.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"Variant_Platforming/PlatformingPlayerController.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"InputMappingContext.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerStart.h\"\n#include \"PlatformingCharacter.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"Engine/World.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"CPPd1.h\"\n#include \"Widgets/Input/SVirtualJoystick.h\"\n\nvoid APlatformingPlayerController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// only spawn touch controls on local player controllers\n\tif (SVirtualJoystick::ShouldDisplayTouchInterface() && IsLocalPlayerController())\n\t{\n\t\t// spawn the mobile controls widget\n\t\tMobileControlsWidget = CreateWidget<UUserWidget>(this, MobileControlsWidgetClass);\n\n\t\tif (MobileControlsWidget)\n\t\t{\n\t\t\t// add the controls to the player screen\n\t\t\tMobileControlsWidget->AddToPlayerScreen(0);\n\n\t\t} else {\n\n\t\t\tUE_LOG(LogCPPd1, Error, TEXT(\"Could not spawn mobile controls widget.\"));\n\n\t\t}\n\n\t}\n}\n\nvoid APlatformingPlayerController::SetupInputComponent()\n{\n\t// only add IMCs for local player controllers\n\tif (IsLocalPlayerController())\n\t{\n\t\t// add the input mapping context\n\t\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer()))\n\t\t{\n\t\t\tfor (UInputMappingContext* CurrentContext : DefaultMappingContexts)\n\t\t\t{\n\t\t\t\tSubsystem->AddMappingContext(CurrentContext, 0);\n\t\t\t}\n\n\t\t\t// only add these IMCs if we're not using mobile touch input\n\t\t\tif (!SVirtualJoystick::ShouldDisplayTouchInterface())\n\t\t\t{\n\t\t\t\tfor (UInputMappingContext* CurrentContext : MobileExcludedMappingContexts)\n\t\t\t\t{\n\t\t\t\t\tSubsystem->AddMappingContext(CurrentContext, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid APlatformingPlayerController::OnPossess(APawn* InPawn)\n{\n\tSuper::OnPossess(InPawn);\n\n\t// subscribe to the pawn's OnDestroyed delegate\n\tInPawn->OnDestroyed.AddDynamic(this, &APlatformingPlayerController::OnPawnDestroyed);\n}\n\nvoid APlatformingPlayerController::OnPawnDestroyed(AActor* DestroyedActor)\n{\n\t// find the player start\n\tTArray<AActor*> ActorList;\n\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), APlayerStart::StaticClass(), ActorList);\n\n\tif (ActorList.Num() > 0)\n\t{\n\t\t// spawn a character at the player start\n\t\tconst FTransform SpawnTransform = ActorList[0]->GetActorTransform();\n\n\t\tif (APlatformingCharacter* RespawnedCharacter = GetWorld()->SpawnActor<APlatformingCharacter>(CharacterClass, SpawnTransform))\n\t\t{\n\t\t\t// possess the character\n\t\t\tPossess(RespawnedCharacter);\n\t\t}\n\t}\n}","Variant_Platforming/PlatformingPlayerController.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"PlatformingPlayerController.generated.h\"\n\nclass UInputMappingContext;\nclass APlatformingCharacter;\n\n/**\n *  Simple Player Controller for a third person platforming game\n *  Manages input mappings\n *  Respawns the player character at the Player Start when it's destroyed\n */\nUCLASS(abstract)\nclass APlatformingPlayerController : public APlayerController\n{\n\tGENERATED_BODY()\n\t\nprotected:\n\n\t/** Input mapping context for this player */\n\tUPROPERTY(EditAnywhere, Category=\"Input|Input Mappings\")\n\tTArray<UInputMappingContext*> DefaultMappingContexts;\n\n\t/** Input Mapping Contexts */\n\tUPROPERTY(EditAnywhere, Category=\"Input|Input Mappings\")\n\tTArray<UInputMappingContext*> MobileExcludedMappingContexts;\n\n\t/** Mobile controls widget to spawn */\n\tUPROPERTY(EditAnywhere, Category=\"Input|Touch Controls\")\n\tTSubclassOf<UUserWidget> MobileControlsWidgetClass;\n\n\t/** Pointer to the mobile controls widget */\n\tTObjectPtr<UUserWidget> MobileControlsWidget;\n\n\t/** Character class to respawn when the possessed pawn is destroyed */\n\tUPROPERTY(EditAnywhere, Category=\"Respawn\")\n\tTSubclassOf<APlatformingCharacter> CharacterClass;\n\nprotected:\n\n\t/** Gameplay initialization */\n\tvirtual void BeginPlay() override;\n\n\t/** Initialize input bindings */\n\tvirtual void SetupInputComponent() override;\n\n\t/** Pawn initialization */\n\tvirtual void OnPossess(APawn* InPawn) override;\n\n\t/** Called if the possessed pawn is destroyed */\n\tUFUNCTION()\n\tvoid OnPawnDestroyed(AActor* DestroyedActor);\n};\n","Variant_SideScrolling/AI/SideScrollingAIController.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"SideScrollingAIController.h\"\n#include \"GameplayStateTreeModule/Public/Components/StateTreeAIComponent.h\"\n\nASideScrollingAIController::ASideScrollingAIController()\n{\n\t// create the StateTree AI Component\n\tStateTreeAI = CreateDefaultSubobject<UStateTreeAIComponent>(TEXT(\"StateTreeAI\"));\n\tcheck(StateTreeAI);\n\n\t// ensure we start the StateTree when we possess the pawn\n\tbStartAILogicOnPossess = true;\n\n\t// ensure we're attached to the possessed character.\n\t// this is necessary for EnvQueries to work correctly\n\tbAttachToPawn = true;\n}\n","Variant_SideScrolling/AI/SideScrollingAIController.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"SideScrollingAIController.generated.h\"\n\nclass UStateTreeAIComponent;\n\n/**\n *  A basic AI Controller capable of running StateTree\n */\nUCLASS(abstract)\nclass ASideScrollingAIController : public AAIController\n{\n\tGENERATED_BODY()\n\t\n\t/** StateTree Component */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"AI\", meta = (AllowPrivateAccess = \"true\"))\n\tUStateTreeAIComponent* StateTreeAI;\n\npublic:\n\n\t/** Constructor */\n\tASideScrollingAIController();\n};\n","Variant_SideScrolling/AI/SideScrollingNPC.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"SideScrollingNPC.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"TimerManager.h\"\n\nASideScrollingNPC::ASideScrollingNPC()\n{\n \tPrimaryActorTick.bCanEverTick = true;\n\n\tGetCharacterMovement()->MaxWalkSpeed = 150.0f;\n}\n\nvoid ASideScrollingNPC::EndPlay(EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\t// clear the deactivation timer\n\tGetWorld()->GetTimerManager().ClearTimer(DeactivationTimer);\n}\n\nvoid ASideScrollingNPC::Interaction(AActor* Interactor)\n{\n\t// ignore if this NPC has already been deactivated\n\tif (bDeactivated)\n\t{\n\t\treturn;\n\t}\n\n\t// reset the deactivation flag\n\tbDeactivated = true;\n\n\t// stop character movement immediately\n\tGetCharacterMovement()->StopMovementImmediately();\n\n\t// launch the NPC away from the interactor\n\tFVector LaunchVector = Interactor->GetActorForwardVector() * LaunchImpulse;\n\tLaunchVector.Y = 0.0f;\n\tLaunchVector.Z = LaunchVerticalImpulse;\n\n\tLaunchCharacter(LaunchVector, true, true);\n\n\t// set up a timer to schedule reactivation\n\tGetWorld()->GetTimerManager().SetTimer(DeactivationTimer, this, &ASideScrollingNPC::ResetDeactivation, DeactivationTime, false);\n}\n\nvoid ASideScrollingNPC::ResetDeactivation()\n{\n\t// reset the deactivation flag\n\tbDeactivated = false;\n}\n","Variant_SideScrolling/AI/SideScrollingNPC.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"SideScrollingInteractable.h\"\n#include \"SideScrollingNPC.generated.h\"\n\n/**\n *  Simple platforming NPC\n *  Its behaviors will be dictated by a possessing AI Controller\n *  It can be temporarily deactivated through Actor interactions\n */\nUCLASS(abstract)\nclass ASideScrollingNPC : public ACharacter, public ISideScrollingInteractable\n{\n\tGENERATED_BODY()\n\nprotected:\n\n\t/** Horizontal impulse to apply to the NPC when it's interacted with */\n\tUPROPERTY(EditAnywhere, Category=\"NPC\", meta = (ClampMin = 0, ClampMax = 10000, Units=\"cm/s\"))\n\tfloat LaunchImpulse = 500.0f;\n\n\t/** Vertical impulse to apply to the NPC when it's interacted with */\n\tUPROPERTY(EditAnywhere, Category=\"NPC\", meta = (ClampMin = 0, ClampMax = 10000, Units=\"cm/s\"))\n\tfloat LaunchVerticalImpulse = 500.0f;\n\n\t/** Time that the NPC remains deactivated after being interacted with */\n\tUPROPERTY(EditAnywhere, Category=\"NPC\", meta = (ClampMin = 0, ClampMax = 10, Units=\"s\"))\n\tfloat DeactivationTime = 3.0f;\n\npublic:\n\n\t/** If true, this NPC is deactivated and will not be interacted with */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"NPC\")\n\tbool bDeactivated = false;\n\n\t/** Timer to reactivate the NPC */\n\tFTimerHandle DeactivationTimer;\n\npublic:\n\n\t/** Constructor */\n\tASideScrollingNPC();\n\npublic:\n\n\t/** Cleanup */\n\tvirtual void EndPlay(EEndPlayReason::Type EndPlayReason) override;\n\npublic:\n\n//\t~begin IInteractable interface \n\n\t/** Performs an interaction triggered by another actor */\n\tvirtual void Interaction(AActor* Interactor) override;\n\n//\t~end IInteractable interface\n\n\t/** Reactivates the NPC */\n\tvoid ResetDeactivation();\n};\n","Variant_SideScrolling/AI/SideScrollingStateTreeUtility.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"SideScrollingStateTreeUtility.h\"\n#include \"StateTreeExecutionContext.h\"\n#include \"StateTreeExecutionTypes.h\"\n#include \"AIController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nEStateTreeRunStatus FStateTreeGetPlayerTask::Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const\n{\n\t// get the instance data\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t// set the player pawn as the target\n\tInstanceData.TargetPlayer = UGameplayStatics::GetPlayerPawn(InstanceData.Controller.Get(), 0);\n\n\t// are the NPC and target valid?\n\tif (IsValid(InstanceData.TargetPlayer) && IsValid(InstanceData.NPC))\n\t{\n\t\tInstanceData.bValidTarget = FVector::Distance(InstanceData.NPC->GetActorLocation(), InstanceData.TargetPlayer->GetActorLocation()) < InstanceData.RangeMax;\n\t}\n\n\treturn EStateTreeRunStatus::Running;\n}\n\n#if WITH_EDITOR\nFText FStateTreeGetPlayerTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const\n{\n\treturn FText::FromString(\"<b>Get Player</b>\");\n}\n#endif // WITH_EDITOR","Variant_SideScrolling/AI/SideScrollingStateTreeUtility.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"StateTreeTaskBase.h\"\n\n#include \"SideScrollingStateTreeUtility.generated.h\"\n\nclass AAIController;\n\n/**\n *  Instance data for the FStateTreeGetPlayerTask task\n */\nUSTRUCT()\nstruct FStateTreeGetPlayerInstanceData\n{\n\tGENERATED_BODY()\n\n\t/** NPC owning this task */\n\tUPROPERTY(VisibleAnywhere, Category=\"Context\")\n\tTObjectPtr<APawn> NPC;\n\n\t/** Holds the found player pawn */\n\tUPROPERTY(VisibleAnywhere, Category=\"Context\")\n\tTObjectPtr<AAIController> Controller;\n\n\t/** Holds the found player pawn */\n\tUPROPERTY(VisibleAnywhere, Category=\"Output\")\n\tTObjectPtr<APawn> TargetPlayer;\n\n\t/** Is the pawn close enough to be considered a valid target? */\n\tUPROPERTY(VisibleAnywhere, Category=\"Output\")\n\tbool bValidTarget = false;\n\n\t/** Max distance to be considered a valid target */\n\tUPROPERTY(EditAnywhere, Category=\"Parameter\", meta = (ClampMin = 0, ClampMax = 10000, Units = \"cm\"))\n\tfloat RangeMax = 1000.0f;\n};\n\n/**\n *  StateTree task to get the player-controlled character\n */\nUSTRUCT(meta=(DisplayName=\"Get Player\", Category=\"Side Scrolling\"))\nstruct FStateTreeGetPlayerTask : public FStateTreeTaskCommonBase\n{\n\tGENERATED_BODY()\n\n\t/* Ensure we're using the correct instance data struct */\n\tusing FInstanceDataType = FStateTreeGetPlayerInstanceData;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\n\t/** Runs while the owning state is active */\n\tvirtual EStateTreeRunStatus Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;\n\n#if WITH_EDITOR\n\tvirtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;\n#endif // WITH_EDITOR\n};","Variant_SideScrolling/Gameplay/SideScrollingJumpPad.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"SideScrollingJumpPad.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/Character.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Components/SceneComponent.h\"\n\nASideScrollingJumpPad::ASideScrollingJumpPad()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// create the root comp\n\tRootComponent = CreateDefaultSubobject<USceneComponent>(TEXT(\"Root\"));\n\n\t// create the bounding box\n\tBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"Box\"));\n\tBox->SetupAttachment(RootComponent);\n\n\t// configure the bounding box\n\tBox->SetBoxExtent(FVector(115.0f, 90.0f, 20.0f), false);\n\tBox->SetRelativeLocation(FVector(0.0f, 0.0f, 16.0f));\n\n\tBox->SetCollisionObjectType(ECC_WorldDynamic);\n\tBox->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tBox->SetCollisionResponseToAllChannels(ECR_Ignore);\n\tBox->SetCollisionResponseToChannel(ECC_Pawn, ECR_Overlap);\n\n\t// add the overlap handler\n\tOnActorBeginOverlap.AddDynamic(this, &ASideScrollingJumpPad::BeginOverlap);\n}\n\nvoid ASideScrollingJumpPad::BeginOverlap(AActor* OverlappedActor, AActor* OtherActor)\n{\n\t// were we overlapped by a character?\n\tif (ACharacter* OverlappingCharacter = Cast<ACharacter>(OtherActor))\n\t{\n\t\t// force the character to jump\n\t\tOverlappingCharacter->Jump();\n\n\t\t// launch the character to override its vertical velocity\n\t\tFVector LaunchVelocity = FVector::UpVector * ZStrength;\n\t\tOverlappingCharacter->LaunchCharacter(LaunchVelocity, false, true);\n\t}\n}\n","Variant_SideScrolling/Gameplay/SideScrollingJumpPad.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SideScrollingJumpPad.generated.h\"\n\nclass UBoxComponent;\n\n/**\n *  A simple jump pad that launches characters into the air\n */\nUCLASS(abstract)\nclass ASideScrollingJumpPad : public AActor\n{\n\tGENERATED_BODY()\n\t\n\t/** Jump pad bounding box */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUBoxComponent* Box;\n\nprotected:\n\n\t/** Vertical velocity to set the character to when they use the jump pad */\n\tUPROPERTY(EditAnywhere, Category=\"Jump Pad\", meta = (ClampMin=0, ClampMax=10000, Units=\"cm/s\"))\n\tfloat ZStrength = 1000.0f;\n\npublic:\t\n\n\t/** Constructor */\n\tASideScrollingJumpPad();\n\nprotected:\n\n\tUFUNCTION()\n\tvoid BeginOverlap(AActor* OverlappedActor, AActor* OtherActor);\n\n};\n","Variant_SideScrolling/Gameplay/SideScrollingMovingPlatform.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"SideScrollingMovingPlatform.h\"\n#include \"Components/SceneComponent.h\"\n\nASideScrollingMovingPlatform::ASideScrollingMovingPlatform()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// create the root comp\n\tRootComponent = CreateDefaultSubobject<USceneComponent>(TEXT(\"Root\"));\n}\n\nvoid ASideScrollingMovingPlatform::Interaction(AActor* Interactor)\n{\n\t// ignore interactions if we're already moving\n\tif (bMoving)\n\t{\n\t\treturn;\n\t}\n\n\t// raise the movement flag\n\tbMoving = true;\n\n\t// pass control to BP for the actual movement\n\tBP_MoveToTarget();\n}\n\nvoid ASideScrollingMovingPlatform::ResetInteraction()\n{\n\t// ignore if this is a one-shot platform\n\tif (bOneShot)\n\t{\n\t\treturn;\n\t}\n\n\t// reset the movement flag\n\tbMoving = false;\n}\n","Variant_SideScrolling/Gameplay/SideScrollingMovingPlatform.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SideScrollingInteractable.h\"\n#include \"SideScrollingMovingPlatform.generated.h\"\n\n/**\n *  Simple moving platform that can be triggered through interactions by other actors.\n *  The actual movement is performed by Blueprint code through latent execution nodes.\n */\nUCLASS(abstract)\nclass ASideScrollingMovingPlatform : public AActor, public ISideScrollingInteractable\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t\n\t/** Constructor */\n\tASideScrollingMovingPlatform();\n\nprotected:\n\n\t/** If this is true, the platform is mid-movement and will ignore further interactions */\n\tbool bMoving = false;\n\n\t/** Destination of the platform in world space */\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Moving Platform\")\n\tFVector PlatformTarget;\n\n\t/** Time for the platform to move to the destination */\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Moving Platform\", meta = (ClampMin = 0, ClampMax = 10, Units=\"s\"))\n\tfloat MoveDuration = 5.0f;\n\n\t/** If this is true, the platform will only move once. */\n\tUPROPERTY(EditAnywhere, Category=\"Moving Platform\")\n\tbool bOneShot = false;\n\npublic:\n\n// ~begin IInteractable interface \n\n\t/** Performs an interaction triggered by another actor */\n\tvirtual void Interaction(AActor* Interactor) override;\n\n// ~end IInteractable interface\n\n\t/** Resets the interaction state. Must be called from BP code to reset the platform */\n\tUFUNCTION(BlueprintCallable, Category=\"Moving Platform\")\n\tvirtual void ResetInteraction();\n\nprotected:\n\n\t/** Allows Blueprint code to do the actual platform movement */\n\tUFUNCTION(BlueprintImplementableEvent, BlueprintCallable, Category=\"Moving Platform\", meta = (DisplayName=\"Move to Target\"))\n\tvoid BP_MoveToTarget();\n\n};\n","Variant_SideScrolling/Gameplay/SideScrollingPickup.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"SideScrollingPickup.h\"\n#include \"GameFramework/Character.h\"\n#include \"SideScrollingGameMode.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Components/SceneComponent.h\"\n#include \"Engine/World.h\"\n\nASideScrollingPickup::ASideScrollingPickup()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// create the root comp\n\tRootComponent = CreateDefaultSubobject<USceneComponent>(TEXT(\"Root\"));\n\n\t// create the bounding sphere\n\tSphere = CreateDefaultSubobject<USphereComponent>(TEXT(\"Collision\"));\n\tSphere->SetupAttachment(RootComponent);\n\n\tSphere->SetSphereRadius(100.0f);\n\n\tSphere->SetCollisionObjectType(ECC_WorldDynamic);\n\tSphere->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tSphere->SetCollisionResponseToAllChannels(ECR_Ignore);\n\tSphere->SetCollisionResponseToChannel(ECC_Pawn, ECR_Overlap);\n\n\t// add the overlap handler\n\tOnActorBeginOverlap.AddDynamic(this, &ASideScrollingPickup::BeginOverlap);\n}\n\nvoid ASideScrollingPickup::BeginOverlap(AActor* OverlappedActor, AActor* OtherActor)\n{\n\t// have we collided against a character?\n\tif (ACharacter* OverlappedCharacter = Cast<ACharacter>(OtherActor))\n\t{\n\t\t// is this the player character?\n\t\tif (OverlappedCharacter->IsPlayerControlled())\n\t\t{\n\t\t\t// get the game mode\n\t\t\tif (ASideScrollingGameMode* GM = Cast<ASideScrollingGameMode>(GetWorld()->GetAuthGameMode()))\n\t\t\t{\n\t\t\t\t// tell the game mode to process a pickup\n\t\t\t\tGM->ProcessPickup();\n\n\t\t\t\t// disable collision so we don't get picked up again\n\t\t\t\tSetActorEnableCollision(false);\n\n\t\t\t\t// Call the BP handler. It will be responsible for destroying the pickup\n\t\t\t\tBP_OnPickedUp();\n\t\t\t}\n\t\t}\n\t}\n}","Variant_SideScrolling/Gameplay/SideScrollingPickup.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SideScrollingPickup.generated.h\"\n\nclass USphereComponent;\n\n/**\n *  A simple side scrolling game pickup\n *  Increments a counter on the GameMode\n */\nUCLASS(abstract)\nclass ASideScrollingPickup : public AActor\n{\n\tGENERATED_BODY()\n\t\n\t/** Pickup bounding sphere */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUSphereComponent* Sphere;\n\npublic:\n\n\t/** Constructor */\n\tASideScrollingPickup();\n\nprotected:\n\n\t/** Handles pickup collision */\n\tUFUNCTION()\n\tvoid BeginOverlap(AActor* OverlappedActor, AActor* OtherActor);\n\n\t/** Passes control to BP to play effects on pickup */\n\tUFUNCTION(BlueprintImplementableEvent, Category=\"Pickup\", meta = (DisplayName = \"On Picked Up\"))\n\tvoid BP_OnPickedUp();\n};\n","Variant_SideScrolling/Gameplay/SideScrollingSoftPlatform.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"SideScrollingSoftPlatform.h\"\n#include \"Components/SceneComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"SideScrollingCharacter.h\"\n\nASideScrollingSoftPlatform::ASideScrollingSoftPlatform()\n{\n \tPrimaryActorTick.bCanEverTick = true;\n\n\t// create the root component\n\tRootComponent = Root = CreateDefaultSubobject<USceneComponent>(TEXT(\"Root\"));\n\n\t// create the mesh\n\tMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Mesh\"));\n\tMesh->SetupAttachment(Root);\n\n\tMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n\tMesh->SetCollisionObjectType(ECC_WorldStatic);\n\tMesh->SetCollisionResponseToAllChannels(ECR_Block);\n\n\t// create the collision check box\n\tCollisionCheckBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"Collision Check Box\"));\n\tCollisionCheckBox->SetupAttachment(Mesh);\n\n\tCollisionCheckBox->SetRelativeLocation(FVector(0.0f, 0.0f, -40.0f));\n\tCollisionCheckBox->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tCollisionCheckBox->SetCollisionObjectType(ECC_WorldDynamic);\n\tCollisionCheckBox->SetCollisionResponseToAllChannels(ECR_Ignore);\n\tCollisionCheckBox->SetCollisionResponseToChannel(ECC_Pawn, ECR_Overlap);\n\n\t// subscribe to the overlap events\n\tCollisionCheckBox->OnComponentBeginOverlap.AddDynamic(this, &ASideScrollingSoftPlatform::OnSoftCollisionOverlap);\n}\n\nvoid ASideScrollingSoftPlatform::OnSoftCollisionOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\t// have we overlapped a character?\n\tif (ASideScrollingCharacter* Char = Cast<ASideScrollingCharacter>(OtherActor))\n\t{\n\t\t// disable the soft collision channel\n\t\tChar->SetSoftCollision(true);\n\t}\n}\n\nvoid ASideScrollingSoftPlatform::NotifyActorEndOverlap(AActor* OtherActor)\n{\n\tSuper::NotifyActorEndOverlap(OtherActor);\n\n\t// have we overlapped a character?\n\tif (ASideScrollingCharacter* Char = Cast<ASideScrollingCharacter>(OtherActor))\n\t{\n\t\t// enable the soft collision channel\n\t\tChar->SetSoftCollision(false);\n\t}\n}\n","Variant_SideScrolling/Gameplay/SideScrollingSoftPlatform.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SideScrollingSoftPlatform.generated.h\"\n\nclass USceneComponent;\nclass UStaticMeshComponent;\nclass UBoxComponent;\n\n/**\n *  A side scrolling game platform that the character can jump or drop through.\n */\nUCLASS(abstract)\nclass ASideScrollingSoftPlatform : public AActor\n{\n\tGENERATED_BODY()\n\t\n\t/** Root component */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUSceneComponent* Root;\n\n\t/** Platform mesh. The part we collide against and see */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUStaticMeshComponent* Mesh;\n\n\t/** Collision volume that toggles soft collision on the character when they're below the platform. */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =\"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUBoxComponent* CollisionCheckBox;\n\npublic:\t\n\t\n\t/** Constructor */\n\tASideScrollingSoftPlatform();\n\nprotected:\n\n\t/** Handles soft collision check box overlaps */\n\tUFUNCTION()\n\tvoid OnSoftCollisionOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\t/** Restores soft collision state when overlap ends */\n\tvirtual void NotifyActorEndOverlap(AActor* OtherActor) override;\n};\n","Variant_SideScrolling/Interfaces/SideScrollingInteractable.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"SideScrollingInteractable.h\"\n\n// Add default functionality here for any IInteractable functions that are not pure virtual.\n","Variant_SideScrolling/Interfaces/SideScrollingInteractable.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/Interface.h\"\n#include \"SideScrollingInteractable.generated.h\"\n\n/**\n *  \n */\nUINTERFACE(MinimalAPI, NotBlueprintable)\nclass USideScrollingInteractable : public UInterface\n{\n\tGENERATED_BODY()\n};\n\n/**\n *  Simple interface to allow Actors to interact without having knowledge of their internal implementation.\n */\nclass ISideScrollingInteractable\n{\n\tGENERATED_BODY()\n\npublic:\n\n\t/** Triggers an interaction by the provided Actor */\n\tUFUNCTION(BlueprintCallable, Category=\"Interactable\")\n\tvirtual void Interaction(AActor* Interactor) = 0;\n\n};\n","Variant_SideScrolling/SideScrollingCameraManager.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"SideScrollingCameraManager.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"Engine/HitResult.h\"\n#include \"CollisionQueryParams.h\"\n#include \"Engine/World.h\"\n\nvoid ASideScrollingCameraManager::UpdateViewTarget(FTViewTarget& OutVT, float DeltaTime)\n{\n\t// ensure the view target is a pawn\n\tAPawn* TargetPawn = Cast<APawn>(OutVT.Target);\n\n\t// is our target valid?\n\tif (IsValid(TargetPawn))\n\t{\n\t\t// set the view target FOV and rotation\n\t\tOutVT.POV.Rotation = FRotator(0.0f, -90.0f, 0.0f);\n\t\tOutVT.POV.FOV = 65.0f;\n\n\t\t// cache the current location\n\t\tFVector CurrentActorLocation = OutVT.Target->GetActorLocation();\n\n\t\t// copy the current camera location\n\t\tFVector CurrentCameraLocation = GetCameraLocation();\n\n\t\t// calculate the \"zoom distance\" - in reality the distance we want to keep to the target\n\t\tfloat CurrentY = CurrentZoom + CurrentActorLocation.Y;\n\n\t\t// do first-time setup\n\t\tif (bSetup)\n\t\t{\n\t\t\t// lower the setup flag\n\t\t\tbSetup = false;\n\n\t\t\t// initialize the camera viewpoint and return\n\t\t\tOutVT.POV.Location.X = CurrentActorLocation.X;\n\t\t\tOutVT.POV.Location.Y = CurrentY;\n\t\t\tOutVT.POV.Location.Z = CurrentActorLocation.Z + CameraZOffset;\n\n\t\t\t// save the current camera height\n\t\t\tCurrentZ = OutVT.POV.Location.Z;\n\n\t\t\t// skip the rest of the calculations\n\t\t\treturn;\n\t\t}\n\n\t\t// check if the camera needs to update its height\n\t\tbool bZUpdate = false;\n\n\t\t// is the character moving vertically?\n\t\tif (FMath::IsNearlyZero(TargetPawn->GetVelocity().Z))\n\t\t{\n\t\t\t// determine if we need to do a height update\n\t\t\tbZUpdate = FMath::IsNearlyEqual(CurrentZ, CurrentCameraLocation.Z, 25.0f);\n\n\t\t} else {\n\n\t\t\t// run a trace below the character to determine if we need to do a height update\n\t\t\tFHitResult OutHit;\n\n\t\t\tconst FVector End = CurrentActorLocation + FVector(0.0f, 0.0f, -1000.0f);\n\n\t\t\tFCollisionQueryParams QueryParams;\n\t\t\tQueryParams.AddIgnoredActor(TargetPawn);\n\n\t\t\t// only update height if we're not about to hit ground\n\t\t\tbZUpdate = !GetWorld()->LineTraceSingleByChannel(OutHit, CurrentActorLocation, End, ECC_Visibility, QueryParams);\n\n\t\t}\n\n\t\t// do we need to do a height update?\n\t\tif (bZUpdate)\n\t\t{\n\n\t\t\t// set the height goal from the actor location\n\t\t\tCurrentZ = CurrentActorLocation.Z;\n\n\t\t} else {\n\n\t\t\t// are we close enough to the target height?\n\t\t\tif (FMath::IsNearlyEqual(CurrentZ, CurrentActorLocation.Z, 100.0f))\n\t\t\t{\n\t\t\t\t// set the height goal from the actor location\n\t\t\t\tCurrentZ = CurrentActorLocation.Z;\n\n\t\t\t} else {\n\n\t\t\t\t// blend the height towards the actor location\n\t\t\t\tCurrentZ = FMath::FInterpTo(CurrentZ, CurrentActorLocation.Z, DeltaTime, 2.0f);\n\t\t\t\t\n\t\t\t}\n\n\t\t}\n\n\t\t// clamp the X axis to the min and max camera bounds\n\t\tfloat CurrentX = FMath::Clamp(CurrentActorLocation.X, CameraXMinBounds, CameraXMaxBounds);\n\n\t\t// blend towards the new camera location and update the output\n\t\tFVector TargetCameraLocation(CurrentX, CurrentY, CurrentZ);\n\n\t\tOutVT.POV.Location = FMath::VInterpTo(CurrentCameraLocation, TargetCameraLocation, DeltaTime, 2.0f);\n\t}\n}","Variant_SideScrolling/SideScrollingCameraManager.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Camera/PlayerCameraManager.h\"\n#include \"SideScrollingCameraManager.generated.h\"\n\n/**\n *  Simple side scrolling camera with smooth scrolling and horizontal bounds\n */\nUCLASS()\nclass ASideScrollingCameraManager : public APlayerCameraManager\n{\n\tGENERATED_BODY()\n\t\npublic:\n\n\t/** Overrides the default camera view target calculation */\n\tvirtual void UpdateViewTarget(FTViewTarget& OutVT, float DeltaTime) override;\n\npublic:\n\n\t/** How close we want to stay to the view target */\n\tUPROPERTY(EditAnywhere, Category=\"Side Scrolling Camera\", meta=(ClampMin=0, ClampMax=10000, Units=\"cm\"))\n\tfloat CurrentZoom = 1000.0f;\n\n\t/** How far above the target do we want the camera to focus */\n\tUPROPERTY(EditAnywhere, Category=\"Side Scrolling Camera\", meta=(ClampMin=0, ClampMax=10000, Units=\"cm\"))\n\tfloat CameraZOffset = 100.0f;\n\n\t/** Minimum camera scrolling bounds in world space */\n\tUPROPERTY(EditAnywhere, Category=\"Side Scrolling Camera\", meta=(ClampMin=-100000, ClampMax=100000, Units=\"cm\"))\n\tfloat CameraXMinBounds = -400.0f;\n\n\t/** Maximum camera scrolling bounds in world space */\n\tUPROPERTY(EditAnywhere, Category=\"Side Scrolling Camera\", meta=(ClampMin=-100000, ClampMax=100000, Units=\"cm\"))\n\tfloat CameraXMaxBounds = 10000.0f;\n\nprotected:\n\n\t/** Last cached camera vertical location. The camera only adjusts its height if necessary. */\n\tfloat CurrentZ = 0.0f;\n\n\t/** First-time update camera setup flag */\n\tbool bSetup = true;\n};\n","Variant_SideScrolling/SideScrollingCharacter.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"SideScrollingCharacter.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/InputComponent.h\"\n#include \"InputActionValue.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"InputAction.h\"\n#include \"Engine/World.h\"\n#include \"SideScrollingInteractable.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n#include \"TimerManager.h\"\n\nASideScrollingCharacter::ASideScrollingCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// create the camera component\n\tCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"Camera\"));\n\tCamera->SetupAttachment(RootComponent);\n\n\tCamera->SetRelativeLocationAndRotation(FVector(0.0f, 300.0f, 0.0f), FRotator(0.0f, -90.0f, 0.0f));\n\n\t// configure the collision capsule\n\tGetCapsuleComponent()->SetCapsuleSize(35.0f, 90.0f);\n\n\t// configure the Pawn properties\n\tbUseControllerRotationYaw = false;\n\n\t// configure the character movement component\n\tGetCharacterMovement()->GravityScale = 1.75f;\n\tGetCharacterMovement()->MaxAcceleration = 1500.0f;\n\tGetCharacterMovement()->BrakingFrictionFactor = 1.0f;\n\tGetCharacterMovement()->bUseSeparateBrakingFriction = true;\n\tGetCharacterMovement()->Mass = 500.0f;\n\n\tGetCharacterMovement()->SetWalkableFloorAngle(75.0f);\n\tGetCharacterMovement()->MaxWalkSpeed = 500.0f;\n\tGetCharacterMovement()->MinAnalogWalkSpeed = 20.0f;\n\tGetCharacterMovement()->BrakingDecelerationWalking = 2000.0f;\n\tGetCharacterMovement()->bIgnoreBaseRotation = true;\n\n\tGetCharacterMovement()->PerchRadiusThreshold = 15.0f;\n\tGetCharacterMovement()->LedgeCheckThreshold = 6.0f;\n\n\tGetCharacterMovement()->JumpZVelocity = 750.0f;\n\tGetCharacterMovement()->AirControl = 1.0f;\n\n\tGetCharacterMovement()->RotationRate = FRotator(0.0f, 750.0f, 0.0f);\n\tGetCharacterMovement()->bOrientRotationToMovement = true;\n\n\tGetCharacterMovement()->SetPlaneConstraintNormal(FVector(0.0f, 1.0f, 0.0f));\n\tGetCharacterMovement()->bConstrainToPlane = true;\n\n\t// enable double jump and coyote time\n\tJumpMaxCount = 3;\n}\n\nvoid ASideScrollingCharacter::EndPlay(EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\t// clear the wall jump timer\n\tGetWorld()->GetTimerManager().ClearTimer(WallJumpTimer);\n}\n\nvoid ASideScrollingCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Set up action bindings\n\tif (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))\n\t{\n\t\t// Jumping\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Started, this, &ASideScrollingCharacter::DoJumpStart);\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Completed, this, &ASideScrollingCharacter::DoJumpEnd);\n\n\t\t// Interacting\n\t\tEnhancedInputComponent->BindAction(InteractAction, ETriggerEvent::Triggered, this, &ASideScrollingCharacter::DoInteract);\n\n\t\t// Moving\n\t\tEnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &ASideScrollingCharacter::Move);\n\n\t\t// Dropping from platform\n\t\tEnhancedInputComponent->BindAction(DropAction, ETriggerEvent::Triggered, this, &ASideScrollingCharacter::Drop);\n\t\tEnhancedInputComponent->BindAction(DropAction, ETriggerEvent::Completed, this, &ASideScrollingCharacter::DropReleased);\n\n\t}\n}\n\nvoid ASideScrollingCharacter::NotifyHit(class UPrimitiveComponent* MyComp, AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tSuper::NotifyHit(MyComp, Other, OtherComp, bSelfMoved, HitLocation, HitNormal, NormalImpulse, Hit);\n\n\t// only apply push impulse if we're falling\n\tif (!GetCharacterMovement()->IsFalling())\n\t{\n\t\treturn;\n\t}\n\n\t// ensure the colliding component is valid\n\tif (OtherComp)\n\t{\n\t\t// ensure the component is movable and simulating physics\n\t\tif (OtherComp->Mobility == EComponentMobility::Movable && OtherComp->IsSimulatingPhysics())\n\t\t{\n\t\t\tconst FVector PushDir = FVector(ActionValueY > 0.0f ? 1.0f : -1.0f, 0.0f, 0.0f);\n\n\t\t\t// push the component away\n\t\t\tOtherComp->AddImpulse(PushDir * JumpPushImpulse, NAME_None, true);\n\t\t}\n\t}\n}\n\nvoid ASideScrollingCharacter::Landed(const FHitResult& Hit)\n{\n\t// reset the double jump\n\tbHasDoubleJumped = false;\n}\n\nvoid ASideScrollingCharacter::OnMovementModeChanged(EMovementMode PrevMovementMode, uint8 PreviousCustomMode /*= 0*/)\n{\n\tSuper::OnMovementModeChanged(PrevMovementMode, PreviousCustomMode);\n\n\t// are we falling?\n\tif (GetCharacterMovement()->MovementMode == EMovementMode::MOVE_Falling)\n\t{\n\t\t// save the game time when we started falling, so we can check it later for coyote time jumps\n\t\tLastFallTime = GetWorld()->GetTimeSeconds();\n\t}\n}\n\nvoid ASideScrollingCharacter::Move(const FInputActionValue& Value)\n{\n\tFVector2D MoveVector = Value.Get<FVector2D>();\n\n\t// route the input\n\tDoMove(MoveVector.Y);\n}\n\nvoid ASideScrollingCharacter::Drop(const FInputActionValue& Value)\n{\n\t// route the input\n\tDoDrop(Value.Get<float>());\n}\n\nvoid ASideScrollingCharacter::DropReleased(const FInputActionValue& Value)\n{\n\t// reset the input\n\tDoDrop(0.0f);\n}\n\nvoid ASideScrollingCharacter::DoMove(float Forward)\n{\n\t// is movement temporarily disabled after wall jumping?\n\tif (!bHasWallJumped)\n\t{\n\t\t// save the movement values\n\t\tActionValueY = Forward;\n\n\t\t// figure out the movement direction\n\t\tconst FVector MoveDir = FVector(1.0f, Forward > 0.0f ? 0.1f : -0.1f, 0.0f);\n\n\t\t// apply the movement input\n\t\tAddMovementInput(MoveDir, Forward);\n\t}\n}\n\nvoid ASideScrollingCharacter::DoDrop(float Value)\n{\n\t// save the movement value\n\tDropValue = Value;\n}\n\nvoid ASideScrollingCharacter::DoJumpStart()\n{\n\t// handle advanced jump behaviors\n\tMultiJump();\n}\n\nvoid ASideScrollingCharacter::DoJumpEnd()\n{\n\tStopJumping();\n}\n\nvoid ASideScrollingCharacter::DoInteract()\n{\n\t// do a sphere trace to look for interactive objects\n\tFHitResult OutHit;\n\n\tconst FVector Start = GetActorLocation();\n\tconst FVector End = Start + FVector(100.0f, 0.0f, 0.0f);\n\n\tFCollisionShape ColSphere;\n\tColSphere.SetSphere(InteractionRadius);\n\n\tFCollisionObjectQueryParams ObjectParams;\n\tObjectParams.AddObjectTypesToQuery(ECC_Pawn);\n\tObjectParams.AddObjectTypesToQuery(ECC_WorldDynamic);\n\n\tFCollisionQueryParams QueryParams;\n\tQueryParams.AddIgnoredActor(this);\n\n\tif (GetWorld()->SweepSingleByObjectType(OutHit, Start, End, FQuat::Identity, ObjectParams, ColSphere, QueryParams))\n\t{\n\t\t// have we hit an interactable?\n\t\tif (ISideScrollingInteractable* Interactable = Cast<ISideScrollingInteractable>(OutHit.GetActor()))\n\t\t{\n\t\t\t// interact\n\t\t\tInteractable->Interaction(this);\n\t\t}\n\t}\n}\n\nvoid ASideScrollingCharacter::MultiJump()\n{\n\t// does the user want to drop to a lower platform?\n\tif (DropValue > 0.0f)\n\t{\n\t\tCheckForSoftCollision();\n\t\treturn;\n\t}\n\n\t// reset the drop value\n\tDropValue = 0.0f;\n\n\t// if we're grounded, disregard advanced jump logic\n\tif (!GetCharacterMovement()->IsFalling())\n\t{\n\t\tJump();\n\t\treturn;\n\t}\n\n\t// if we have a horizontal input, try for wall jump first\n\tif (!bHasWallJumped && !FMath::IsNearlyZero(ActionValueY))\n\t{\n\t\t// trace ahead of the character for walls\n\t\tFHitResult OutHit;\n\n\t\tconst FVector Start = GetActorLocation();\n\t\tconst FVector End = Start + (FVector(ActionValueY > 0.0f ? 1.0f : -1.0f, 0.0f, 0.0f) * WallJumpTraceDistance);\n\n\t\tFCollisionQueryParams QueryParams;\n\t\tQueryParams.AddIgnoredActor(this);\n\n\t\tGetWorld()->LineTraceSingleByChannel(OutHit, Start, End, ECC_Visibility, QueryParams);\n\n\t\tif (OutHit.bBlockingHit)\n\t\t{\n\t\t\t// rotate to the bounce direction\n\t\t\tconst FRotator BounceRot = UKismetMathLibrary::MakeRotFromX(OutHit.ImpactNormal);\n\t\t\tSetActorRotation(FRotator(0.0f, BounceRot.Yaw, 0.0f));\n\n\t\t\t// calculate the impulse vector\n\t\t\tFVector WallJumpImpulse = OutHit.ImpactNormal * WallJumpHorizontalImpulse;\n\t\t\tWallJumpImpulse.Z = GetCharacterMovement()->JumpZVelocity * WallJumpVerticalMultiplier;\n\n\t\t\t// launch the character away from the wall\n\t\t\tLaunchCharacter(WallJumpImpulse, true, true);\n\n\t\t\t// enable wall jump lockout for a bit\n\t\t\tbHasWallJumped = true;\n\n\t\t\t// schedule wall jump lockout reset\n\t\t\tGetWorld()->GetTimerManager().SetTimer(WallJumpTimer, this, &ASideScrollingCharacter::ResetWallJump, DelayBetweenWallJumps, false);\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\n\t// test for double jump only if we haven't already tested for wall jump\n\tif (!bHasWallJumped)\n\t{\n\t\t// are we still within coyote time frames?\n\t\tif (GetWorld()->GetTimeSeconds() - LastFallTime < MaxCoyoteTime)\n\t\t{\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Coyote Jump\"));\n\n\t\t\t// use the built-in CMC functionality to do the jump\n\t\t\tJump();\n\n\t\t// no coyote time jump\n\t\t} else {\n\t\t\n\t\t\t// The movement component handles double jump but we still need to manage the flag for animation\n\t\t\tif (!bHasDoubleJumped)\n\t\t\t{\n\t\t\t\t// raise the double jump flag\n\t\t\t\tbHasDoubleJumped = true;\n\n\t\t\t\t// let the CMC handle jump\n\t\t\t\tJump();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ASideScrollingCharacter::CheckForSoftCollision()\n{\n\t// reset the drop value\n\tDropValue = 0.0f;\n\n\t// trace down \n\tFHitResult OutHit;\n\n\tconst FVector Start = GetActorLocation();\n\tconst FVector End = Start + (FVector::DownVector * SoftCollisionTraceDistance);\n\n\tFCollisionObjectQueryParams ObjectParams;\n\tObjectParams.AddObjectTypesToQuery(SoftCollisionObjectType);\n\n\tFCollisionQueryParams QueryParams;\n\tQueryParams.AddIgnoredActor(this);\n\n\tGetWorld()->LineTraceSingleByObjectType(OutHit, Start, End, ObjectParams, QueryParams);\n\n\t// did we hit a soft floor?\n\tif (OutHit.GetActor())\n\t{\n\t\t// drop through the floor\n\t\tSetSoftCollision(true);\n\t}\n}\n\nvoid ASideScrollingCharacter::ResetWallJump()\n{\n\t// reset the wall jump flag\n\tbHasWallJumped = false;\n}\n\nvoid ASideScrollingCharacter::SetSoftCollision(bool bEnabled)\n{\n\t// enable or disable collision response to the soft collision channel\n\tGetCapsuleComponent()->SetCollisionResponseToChannel(SoftCollisionObjectType, bEnabled ? ECR_Ignore : ECR_Block);\n}\n\nbool ASideScrollingCharacter::HasDoubleJumped() const\n{\n\treturn bHasDoubleJumped;\n}\n\nbool ASideScrollingCharacter::HasWallJumped() const\n{\n\treturn bHasWallJumped;\n}\n","Variant_SideScrolling/SideScrollingCharacter.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"SideScrollingCharacter.generated.h\"\n\nclass UCameraComponent;\nclass UInputAction;\nstruct FInputActionValue;\n\n/**\n *  A player-controllable character side scrolling game\n */\nUCLASS(abstract)\nclass ASideScrollingCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\n\t/** Player camera */\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =\"Camera\", meta = (AllowPrivateAccess = \"true\"))\n\tUCameraComponent* Camera;\n\nprotected:\n\n\t/** Move Input Action */\n\tUPROPERTY(EditAnywhere, Category=\"Input\")\n\tUInputAction* MoveAction;\n\n\t/** Jump Input Action */\n\tUPROPERTY(EditAnywhere, Category=\"Input\")\n\tUInputAction* JumpAction;\n\n\t/** Drop from Platform Action */\n\tUPROPERTY(EditAnywhere, Category=\"Input\")\n\tUInputAction* DropAction;\n\n\t/** Interact Input Action */\n\tUPROPERTY(EditAnywhere, Category=\"Input\")\n\tUInputAction* InteractAction;\n\n\t/** Impulse to manually push physics objects while we're in midair */\n\tUPROPERTY(EditAnywhere, Category=\"Side Scrolling|Jump\")\n\tfloat JumpPushImpulse = 600.0f;\n\n\t/** Max distance that interactive objects can be triggered */\n\tUPROPERTY(EditAnywhere, Category=\"Side Scrolling|Interaction\")\n\tfloat InteractionRadius = 200.0f;\n\n\t/** Time to disable input after a wall jump to preserve momentum */\n\tUPROPERTY(EditAnywhere, Category=\"Side Scrolling|Wall Jump\")\n\tfloat DelayBetweenWallJumps = 0.3f;\n\n\t/** Distance to trace ahead of the character for wall jumps */\n\tUPROPERTY(EditAnywhere, Category=\"Side Scrolling|Wall Jump\")\n\tfloat WallJumpTraceDistance = 50.0f;\n\n\t/** Horizontal impulse to apply to the character during wall jumps */\n\tUPROPERTY(EditAnywhere, Category=\"Side Scrolling|Wall Jump\")\n\tfloat WallJumpHorizontalImpulse = 500.0f;\n\n\t/** Multiplies the jump Z velocity for wall jumps. */\n\tUPROPERTY(EditAnywhere, Category=\"Side Scrolling|Wall Jump\")\n\tfloat WallJumpVerticalMultiplier = 1.4f;\n\n\t/** Collision object type to use for soft collision traces (dropping down floors) */\n\tUPROPERTY(EditAnywhere, Category=\"Side Scrolling|Soft Platforms\")\n\tTEnumAsByte<ECollisionChannel> SoftCollisionObjectType;\n\n\t/** Distance to trace down during soft collision checks */\n\tUPROPERTY(EditAnywhere, Category=\"Side Scrolling|Soft Platforms\")\n\tfloat SoftCollisionTraceDistance = 1000.0f;\n\n\t/** Last recorded time when this character started falling */\n\tfloat LastFallTime = 0.0f;\n\n\t/** Max amount of time that can pass since we started falling when we allow a regular jump */\n\tUPROPERTY(EditAnywhere, Category=\"Side Scrolling|Coyote Time\", meta = (ClampMin = 0, ClampMax = 5, Units = \"s\"))\n\tfloat MaxCoyoteTime = 0.16f;\n\n\t/** Wall jump lockout timer */\n\tFTimerHandle WallJumpTimer;\n\n\t/** Last captured horizontal movement input value */\n\tfloat ActionValueY = 0.0f;\n\n\t/** Last captured platform drop axis value */\n\tfloat DropValue = 0.0f;\n\n\t/** If true, this character has already wall jumped */\n\tbool bHasWallJumped = false;\n\n\t/** If true, this character has already double jumped */\n\tbool bHasDoubleJumped = false;\n\n\t/** If true, this character is moving along the side scrolling axis */\n\tbool bMovingHorizontally = false;\n\npublic:\n\t\n\t/** Constructor */\n\tASideScrollingCharacter();\n\nprotected:\n\n\t/** Gameplay cleanup */\n\tvirtual void EndPlay(EEndPlayReason::Type EndPlayReason) override;\n\n\t/** Initialize input action bindings */\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t/** Collision handling */\n\tvirtual void NotifyHit(class UPrimitiveComponent* MyComp, AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit) override;\n\n\t/** Landing handling */\n\tvirtual void Landed(const FHitResult& Hit) override;\n\n\t/** Handle movement mode changes to keep track of coyote time jumps */\n\tvirtual void OnMovementModeChanged(EMovementMode PrevMovementMode, uint8 PreviousCustomMode = 0) override;\n\nprotected:\n\n\t/** Called for movement input */\n\tvoid Move(const FInputActionValue& Value);\n\n\t/** Called for drop from platform input */\n\tvoid Drop(const FInputActionValue& Value);\n\n\t/** Called for drop from platform input release */\n\tvoid DropReleased(const FInputActionValue& Value);\n\npublic:\n\n\t/** Handles move inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoMove(float Forward);\n\n\t/** Handles drop inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoDrop(float Value);\n\n\t/** Handles jump pressed inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoJumpStart();\n\n\t/** Handles jump pressed inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoJumpEnd();\n\n\t/** Handles interact inputs from either controls or UI interfaces */\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvirtual void DoInteract();\n\nprotected:\n\n\t/** Handles advanced jump logic */\n\tvoid MultiJump();\n\n\t/** Checks for soft collision with platforms */\n\tvoid CheckForSoftCollision();\n\n\t/** Resets wall jump lockout. Called from timer after a wall jump */\n\tvoid ResetWallJump();\n\npublic:\n\n\t/** Sets the soft collision response. True passes, False blocks */\n\tvoid SetSoftCollision(bool bEnabled);\n\npublic:\n\n\t/** Returns true if the character has just double jumped */\n\tUFUNCTION(BlueprintPure, Category=\"Side Scrolling\")\n\tbool HasDoubleJumped() const;\n\n\t/** Returns true if the character has just wall jumped */\n\tUFUNCTION(BlueprintPure, Category=\"Side Scrolling\")\n\tbool HasWallJumped() const;\n};\n","Variant_SideScrolling/SideScrollingGameMode.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"SideScrollingGameMode.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"SideScrollingUI.h\"\n#include \"SideScrollingPickup.h\"\n\nvoid ASideScrollingGameMode::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// create the game UI\n\tAPlayerController* OwningPlayer = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\t\n\tUserInterface = CreateWidget<USideScrollingUI>(OwningPlayer, UserInterfaceClass);\n\n\tcheck(UserInterface);\n}\n\nvoid ASideScrollingGameMode::ProcessPickup()\n{\n\t// increment the pickups counter\n\t++PickupsCollected;\n\n\t// if this is the first pickup we collect, show the UI\n\tif (PickupsCollected == 1)\n\t{\n\t\tUserInterface->AddToViewport(0);\n\t}\n\n\t// update the pickups counter on the UI\n\tUserInterface->UpdatePickups(PickupsCollected);\n}","Variant_SideScrolling/SideScrollingGameMode.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"SideScrollingGameMode.generated.h\"\n\nclass USideScrollingUI;\n\n/**\n *  Simple Side Scrolling Game Mode\n *  Spawns and manages the game UI\n *  Counts pickups collected by the player\n */\nUCLASS(abstract)\nclass ASideScrollingGameMode : public AGameModeBase\n{\n\tGENERATED_BODY()\n\t\nprotected:\n\n\t/** Class of UI widget to spawn when the game starts */\n\tUPROPERTY(EditAnywhere, Category=\"UI\")\n\tTSubclassOf<USideScrollingUI> UserInterfaceClass;\n\n\t/** User interface widget for the game */\n\tUPROPERTY(BlueprintReadOnly, Category=\"UI\")\n\tTObjectPtr<USideScrollingUI> UserInterface;\n\n\t/** Number of pickups collected by the player */\n\tUPROPERTY(BlueprintReadOnly, Category=\"Pickups\")\n\tint32 PickupsCollected = 0;\n\nprotected:\n\n\t/** Initialization */\n\tvirtual void BeginPlay() override;\n\npublic:\n\n\t/** Receives an interaction event from another actor */\n\tvirtual void ProcessPickup();\n};\n","Variant_SideScrolling/SideScrollingPlayerController.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"SideScrollingPlayerController.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"InputMappingContext.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerStart.h\"\n#include \"SideScrollingCharacter.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"Engine/World.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"CPPd1.h\"\n#include \"Widgets/Input/SVirtualJoystick.h\"\n\nvoid ASideScrollingPlayerController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// only spawn touch controls on local player controllers\n\tif (SVirtualJoystick::ShouldDisplayTouchInterface() && IsLocalPlayerController())\n\t{\n\t\t// spawn the mobile controls widget\n\t\tMobileControlsWidget = CreateWidget<UUserWidget>(this, MobileControlsWidgetClass);\n\n\t\tif (MobileControlsWidget)\n\t\t{\n\t\t\t// add the controls to the player screen\n\t\t\tMobileControlsWidget->AddToPlayerScreen(0);\n\n\t\t} else {\n\n\t\t\tUE_LOG(LogCPPd1, Error, TEXT(\"Could not spawn mobile controls widget.\"));\n\n\t\t}\n\n\t}\n}\n\nvoid ASideScrollingPlayerController::SetupInputComponent()\n{\n\t// only add IMCs for local player controllers\n\tif (IsLocalPlayerController())\n\t{\n\t\t// add the input mapping context\n\t\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer()))\n\t\t{\n\t\t\tfor (UInputMappingContext* CurrentContext : DefaultMappingContexts)\n\t\t\t{\n\t\t\t\tSubsystem->AddMappingContext(CurrentContext, 0);\n\t\t\t}\n\n\t\t\t// only add these IMCs if we're not using mobile touch input\n\t\t\tif (!SVirtualJoystick::ShouldDisplayTouchInterface())\n\t\t\t{\n\t\t\t\tfor (UInputMappingContext* CurrentContext : MobileExcludedMappingContexts)\n\t\t\t\t{\n\t\t\t\t\tSubsystem->AddMappingContext(CurrentContext, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ASideScrollingPlayerController::OnPossess(APawn* InPawn)\n{\n\tSuper::OnPossess(InPawn);\n\n\t// subscribe to the pawn's OnDestroyed delegate\n\tInPawn->OnDestroyed.AddDynamic(this, &ASideScrollingPlayerController::OnPawnDestroyed);\n}\n\nvoid ASideScrollingPlayerController::OnPawnDestroyed(AActor* DestroyedActor)\n{\n\t// find the player start\n\tTArray<AActor*> ActorList;\n\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), APlayerStart::StaticClass(), ActorList);\n\n\tif (ActorList.Num() > 0)\n\t{\n\t\t// spawn a character at the player start\n\t\tconst FTransform SpawnTransform = ActorList[0]->GetActorTransform();\n\n\t\tif (ASideScrollingCharacter* RespawnedCharacter = GetWorld()->SpawnActor<ASideScrollingCharacter>(CharacterClass, SpawnTransform))\n\t\t{\n\t\t\t// possess the character\n\t\t\tPossess(RespawnedCharacter);\n\t\t}\n\t}\n}\n","Variant_SideScrolling/SideScrollingPlayerController.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"EnhancedInput/Public/InputAction.h\"\n#include \"SideScrollingPlayerController.generated.h\"\n\nclass ASideScrollingCharacter;\nclass UInputMappingContext;\n\n/**\n *  A simple Side Scrolling Player Controller\n *  Manages input mappings\n *  Respawns the player pawn at the player start if it is destroyed\n */\nUCLASS(abstract)\nclass ASideScrollingPlayerController : public APlayerController\n{\n\tGENERATED_BODY()\n\t\nprotected:\n\n\t/** Input mapping context for this player */\n\tUPROPERTY(EditAnywhere, Category=\"Input|Input Mappings\")\n\tTArray<UInputMappingContext*> DefaultMappingContexts;\n\n\t/** Input Mapping Contexts */\n\tUPROPERTY(EditAnywhere, Category=\"Input|Input Mappings\")\n\tTArray<UInputMappingContext*> MobileExcludedMappingContexts;\n\n\t/** Mobile controls widget to spawn */\n\tUPROPERTY(EditAnywhere, Category=\"Input|Touch Controls\")\n\tTSubclassOf<UUserWidget> MobileControlsWidgetClass;\n\n\t/** Pointer to the mobile controls widget */\n\tTObjectPtr<UUserWidget> MobileControlsWidget;\n\n\t/** Character class to respawn when the possessed pawn is destroyed */\n\tUPROPERTY(EditAnywhere, Category=\"Respawn\")\n\tTSubclassOf<ASideScrollingCharacter> CharacterClass;\n\nprotected:\n\n\t/** Gameplay initialization */\n\tvirtual void BeginPlay() override;\n\n\t/** Initialize input bindings */\n\tvirtual void SetupInputComponent() override;\n\n\t/** Pawn initialization */\n\tvirtual void OnPossess(APawn* InPawn) override;\n\n\t/** Called if the possessed pawn is destroyed */\n\tUFUNCTION()\n\tvoid OnPawnDestroyed(AActor* DestroyedActor);\n\n};\n","Variant_SideScrolling/UI/SideScrollingUI.cpp":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"SideScrollingUI.h\"\n\n","Variant_SideScrolling/UI/SideScrollingUI.h":"// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"SideScrollingUI.generated.h\"\n\n/**\n *  Simple Side Scrolling game UI\n *  Displays and manages a pickup counter\n */\nUCLASS(abstract)\nclass USideScrollingUI : public UUserWidget\n{\n\tGENERATED_BODY()\n\t\npublic:\n\n\t/** Update the widget's pickup counter */\n\tUFUNCTION(BlueprintImplementableEvent, Category=\"UI\")\n\tvoid UpdatePickups(int32 Amount);\n};\n"};
const TREE  = {"name":"CPPd1","path":"","children":{"Procedural":{"name":"Procedural","path":"Procedural","children":{},"files":[{"name":"CPPd1ProceduralCube.cpp","path":"Procedural/CPPd1ProceduralCube.cpp"},{"name":"CPPd1ProceduralCube.h","path":"Procedural/CPPd1ProceduralCube.h"},{"name":"CubeNinjaBodyComponent.cpp","path":"Procedural/CubeNinjaBodyComponent.cpp"},{"name":"CubeNinjaBodyComponent.h","path":"Procedural/CubeNinjaBodyComponent.h"}]},"Variant_Combat":{"name":"Variant_Combat","path":"Variant_Combat","children":{"AI":{"name":"AI","path":"Variant_Combat/AI","children":{},"files":[{"name":"BruteMarauder.cpp","path":"Variant_Combat/AI/BruteMarauder.cpp"},{"name":"BruteMarauder.h","path":"Variant_Combat/AI/BruteMarauder.h"},{"name":"CombatAIController.cpp","path":"Variant_Combat/AI/CombatAIController.cpp"},{"name":"CombatAIController.h","path":"Variant_Combat/AI/CombatAIController.h"},{"name":"CombatEnemy.cpp","path":"Variant_Combat/AI/CombatEnemy.cpp"},{"name":"CombatEnemy.h","path":"Variant_Combat/AI/CombatEnemy.h"},{"name":"CombatEnemySpawner.cpp","path":"Variant_Combat/AI/CombatEnemySpawner.cpp"},{"name":"CombatEnemySpawner.h","path":"Variant_Combat/AI/CombatEnemySpawner.h"},{"name":"CombatEngagementManager.cpp","path":"Variant_Combat/AI/CombatEngagementManager.cpp"},{"name":"CombatEngagementManager.h","path":"Variant_Combat/AI/CombatEngagementManager.h"},{"name":"CombatStateTreeUtility.cpp","path":"Variant_Combat/AI/CombatStateTreeUtility.cpp"},{"name":"CombatStateTreeUtility.h","path":"Variant_Combat/AI/CombatStateTreeUtility.h"},{"name":"CombatWaveSpawner.cpp","path":"Variant_Combat/AI/CombatWaveSpawner.cpp"},{"name":"CombatWaveSpawner.h","path":"Variant_Combat/AI/CombatWaveSpawner.h"},{"name":"EnvQueryContext_Player.cpp","path":"Variant_Combat/AI/EnvQueryContext_Player.cpp"},{"name":"EnvQueryContext_Player.h","path":"Variant_Combat/AI/EnvQueryContext_Player.h"},{"name":"NinjaEnemy.cpp","path":"Variant_Combat/AI/NinjaEnemy.cpp"},{"name":"NinjaEnemy.h","path":"Variant_Combat/AI/NinjaEnemy.h"},{"name":"SpinningRadiusWaveSpawner.cpp","path":"Variant_Combat/AI/SpinningRadiusWaveSpawner.cpp"},{"name":"SpinningRadiusWaveSpawner.h","path":"Variant_Combat/AI/SpinningRadiusWaveSpawner.h"},{"name":"TricksterMarauder.cpp","path":"Variant_Combat/AI/TricksterMarauder.cpp"},{"name":"TricksterMarauder.h","path":"Variant_Combat/AI/TricksterMarauder.h"}]},"Animation":{"name":"Animation","path":"Variant_Combat/Animation","children":{},"files":[{"name":"AnimNotify_CheckChargedAttack.cpp","path":"Variant_Combat/Animation/AnimNotify_CheckChargedAttack.cpp"},{"name":"AnimNotify_CheckChargedAttack.h","path":"Variant_Combat/Animation/AnimNotify_CheckChargedAttack.h"},{"name":"AnimNotify_CheckCombo.cpp","path":"Variant_Combat/Animation/AnimNotify_CheckCombo.cpp"},{"name":"AnimNotify_CheckCombo.h","path":"Variant_Combat/Animation/AnimNotify_CheckCombo.h"},{"name":"AnimNotify_DoAttackTrace.cpp","path":"Variant_Combat/Animation/AnimNotify_DoAttackTrace.cpp"},{"name":"AnimNotify_DoAttackTrace.h","path":"Variant_Combat/Animation/AnimNotify_DoAttackTrace.h"}]},"Gameplay":{"name":"Gameplay","path":"Variant_Combat/Gameplay","children":{},"files":[{"name":"CombatActivationVolume.cpp","path":"Variant_Combat/Gameplay/CombatActivationVolume.cpp"},{"name":"CombatActivationVolume.h","path":"Variant_Combat/Gameplay/CombatActivationVolume.h"},{"name":"CombatCheckpointVolume.cpp","path":"Variant_Combat/Gameplay/CombatCheckpointVolume.cpp"},{"name":"CombatCheckpointVolume.h","path":"Variant_Combat/Gameplay/CombatCheckpointVolume.h"},{"name":"CombatDamageableBox.cpp","path":"Variant_Combat/Gameplay/CombatDamageableBox.cpp"},{"name":"CombatDamageableBox.h","path":"Variant_Combat/Gameplay/CombatDamageableBox.h"},{"name":"CombatDummy.cpp","path":"Variant_Combat/Gameplay/CombatDummy.cpp"},{"name":"CombatDummy.h","path":"Variant_Combat/Gameplay/CombatDummy.h"},{"name":"CombatLavaFloor.cpp","path":"Variant_Combat/Gameplay/CombatLavaFloor.cpp"},{"name":"CombatLavaFloor.h","path":"Variant_Combat/Gameplay/CombatLavaFloor.h"}]},"Interfaces":{"name":"Interfaces","path":"Variant_Combat/Interfaces","children":{},"files":[{"name":"CombatActivatable.cpp","path":"Variant_Combat/Interfaces/CombatActivatable.cpp"},{"name":"CombatActivatable.h","path":"Variant_Combat/Interfaces/CombatActivatable.h"},{"name":"CombatAttacker.cpp","path":"Variant_Combat/Interfaces/CombatAttacker.cpp"},{"name":"CombatAttacker.h","path":"Variant_Combat/Interfaces/CombatAttacker.h"},{"name":"CombatDamageable.cpp","path":"Variant_Combat/Interfaces/CombatDamageable.cpp"},{"name":"CombatDamageable.h","path":"Variant_Combat/Interfaces/CombatDamageable.h"}]},"UI":{"name":"UI","path":"Variant_Combat/UI","children":{},"files":[{"name":"CombatHUD.cpp","path":"Variant_Combat/UI/CombatHUD.cpp"},{"name":"CombatHUD.h","path":"Variant_Combat/UI/CombatHUD.h"},{"name":"CombatLifeBar.cpp","path":"Variant_Combat/UI/CombatLifeBar.cpp"},{"name":"CombatLifeBar.h","path":"Variant_Combat/UI/CombatLifeBar.h"}]}},"files":[{"name":"CombatAdvancedMechanics.cpp","path":"Variant_Combat/CombatAdvancedMechanics.cpp"},{"name":"CombatAdvancedMechanics.h","path":"Variant_Combat/CombatAdvancedMechanics.h"},{"name":"CombatCharacter.cpp","path":"Variant_Combat/CombatCharacter.cpp"},{"name":"CombatCharacter.h","path":"Variant_Combat/CombatCharacter.h"},{"name":"CombatFlowSystem.cpp","path":"Variant_Combat/CombatFlowSystem.cpp"},{"name":"CombatFlowSystem.h","path":"Variant_Combat/CombatFlowSystem.h"},{"name":"CombatGameMode.cpp","path":"Variant_Combat/CombatGameMode.cpp"},{"name":"CombatGameMode.h","path":"Variant_Combat/CombatGameMode.h"},{"name":"CombatInputHelper.cpp","path":"Variant_Combat/CombatInputHelper.cpp"},{"name":"CombatInputHelper.h","path":"Variant_Combat/CombatInputHelper.h"},{"name":"CombatPlayerController.cpp","path":"Variant_Combat/CombatPlayerController.cpp"},{"name":"CombatPlayerController.h","path":"Variant_Combat/CombatPlayerController.h"},{"name":"CombatSkillSystem.cpp","path":"Variant_Combat/CombatSkillSystem.cpp"},{"name":"CombatSkillSystem.h","path":"Variant_Combat/CombatSkillSystem.h"},{"name":"CombatStaminaSystem.cpp","path":"Variant_Combat/CombatStaminaSystem.cpp"},{"name":"CombatStaminaSystem.h","path":"Variant_Combat/CombatStaminaSystem.h"},{"name":"CombatTrickSystem.cpp","path":"Variant_Combat/CombatTrickSystem.cpp"},{"name":"CombatTrickSystem.h","path":"Variant_Combat/CombatTrickSystem.h"},{"name":"CubeNinjaCharacter.cpp","path":"Variant_Combat/CubeNinjaCharacter.cpp"},{"name":"CubeNinjaCharacter.h","path":"Variant_Combat/CubeNinjaCharacter.h"},{"name":"NinjaCharacter.cpp","path":"Variant_Combat/NinjaCharacter.cpp"},{"name":"NinjaCharacter.h","path":"Variant_Combat/NinjaCharacter.h"},{"name":"NinjaGameMode.cpp","path":"Variant_Combat/NinjaGameMode.cpp"},{"name":"NinjaGameMode.h","path":"Variant_Combat/NinjaGameMode.h"},{"name":"NinjaPlayerController.cpp","path":"Variant_Combat/NinjaPlayerController.cpp"},{"name":"NinjaPlayerController.h","path":"Variant_Combat/NinjaPlayerController.h"}]},"Variant_Platforming":{"name":"Variant_Platforming","path":"Variant_Platforming","children":{"Animation":{"name":"Animation","path":"Variant_Platforming/Animation","children":{},"files":[{"name":"AnimNotify_EndDash.cpp","path":"Variant_Platforming/Animation/AnimNotify_EndDash.cpp"},{"name":"AnimNotify_EndDash.h","path":"Variant_Platforming/Animation/AnimNotify_EndDash.h"}]}},"files":[{"name":"PlatformingCharacter.cpp","path":"Variant_Platforming/PlatformingCharacter.cpp"},{"name":"PlatformingCharacter.h","path":"Variant_Platforming/PlatformingCharacter.h"},{"name":"PlatformingGameMode.cpp","path":"Variant_Platforming/PlatformingGameMode.cpp"},{"name":"PlatformingGameMode.h","path":"Variant_Platforming/PlatformingGameMode.h"},{"name":"PlatformingPlayerController.cpp","path":"Variant_Platforming/PlatformingPlayerController.cpp"},{"name":"PlatformingPlayerController.h","path":"Variant_Platforming/PlatformingPlayerController.h"}]},"Variant_SideScrolling":{"name":"Variant_SideScrolling","path":"Variant_SideScrolling","children":{"AI":{"name":"AI","path":"Variant_SideScrolling/AI","children":{},"files":[{"name":"SideScrollingAIController.cpp","path":"Variant_SideScrolling/AI/SideScrollingAIController.cpp"},{"name":"SideScrollingAIController.h","path":"Variant_SideScrolling/AI/SideScrollingAIController.h"},{"name":"SideScrollingNPC.cpp","path":"Variant_SideScrolling/AI/SideScrollingNPC.cpp"},{"name":"SideScrollingNPC.h","path":"Variant_SideScrolling/AI/SideScrollingNPC.h"},{"name":"SideScrollingStateTreeUtility.cpp","path":"Variant_SideScrolling/AI/SideScrollingStateTreeUtility.cpp"},{"name":"SideScrollingStateTreeUtility.h","path":"Variant_SideScrolling/AI/SideScrollingStateTreeUtility.h"}]},"Gameplay":{"name":"Gameplay","path":"Variant_SideScrolling/Gameplay","children":{},"files":[{"name":"SideScrollingJumpPad.cpp","path":"Variant_SideScrolling/Gameplay/SideScrollingJumpPad.cpp"},{"name":"SideScrollingJumpPad.h","path":"Variant_SideScrolling/Gameplay/SideScrollingJumpPad.h"},{"name":"SideScrollingMovingPlatform.cpp","path":"Variant_SideScrolling/Gameplay/SideScrollingMovingPlatform.cpp"},{"name":"SideScrollingMovingPlatform.h","path":"Variant_SideScrolling/Gameplay/SideScrollingMovingPlatform.h"},{"name":"SideScrollingPickup.cpp","path":"Variant_SideScrolling/Gameplay/SideScrollingPickup.cpp"},{"name":"SideScrollingPickup.h","path":"Variant_SideScrolling/Gameplay/SideScrollingPickup.h"},{"name":"SideScrollingSoftPlatform.cpp","path":"Variant_SideScrolling/Gameplay/SideScrollingSoftPlatform.cpp"},{"name":"SideScrollingSoftPlatform.h","path":"Variant_SideScrolling/Gameplay/SideScrollingSoftPlatform.h"}]},"Interfaces":{"name":"Interfaces","path":"Variant_SideScrolling/Interfaces","children":{},"files":[{"name":"SideScrollingInteractable.cpp","path":"Variant_SideScrolling/Interfaces/SideScrollingInteractable.cpp"},{"name":"SideScrollingInteractable.h","path":"Variant_SideScrolling/Interfaces/SideScrollingInteractable.h"}]},"UI":{"name":"UI","path":"Variant_SideScrolling/UI","children":{},"files":[{"name":"SideScrollingUI.cpp","path":"Variant_SideScrolling/UI/SideScrollingUI.cpp"},{"name":"SideScrollingUI.h","path":"Variant_SideScrolling/UI/SideScrollingUI.h"}]}},"files":[{"name":"SideScrollingCameraManager.cpp","path":"Variant_SideScrolling/SideScrollingCameraManager.cpp"},{"name":"SideScrollingCameraManager.h","path":"Variant_SideScrolling/SideScrollingCameraManager.h"},{"name":"SideScrollingCharacter.cpp","path":"Variant_SideScrolling/SideScrollingCharacter.cpp"},{"name":"SideScrollingCharacter.h","path":"Variant_SideScrolling/SideScrollingCharacter.h"},{"name":"SideScrollingGameMode.cpp","path":"Variant_SideScrolling/SideScrollingGameMode.cpp"},{"name":"SideScrollingGameMode.h","path":"Variant_SideScrolling/SideScrollingGameMode.h"},{"name":"SideScrollingPlayerController.cpp","path":"Variant_SideScrolling/SideScrollingPlayerController.cpp"},{"name":"SideScrollingPlayerController.h","path":"Variant_SideScrolling/SideScrollingPlayerController.h"}]}},"files":[{"name":"CPPd1.cpp","path":"CPPd1.cpp"},{"name":"CPPd1.h","path":"CPPd1.h"},{"name":"CPPd1Character.cpp","path":"CPPd1Character.cpp"},{"name":"CPPd1Character.h","path":"CPPd1Character.h"},{"name":"CPPd1GameMode.cpp","path":"CPPd1GameMode.cpp"},{"name":"CPPd1GameMode.h","path":"CPPd1GameMode.h"},{"name":"CPPd1GameModeBase.cpp","path":"CPPd1GameModeBase.cpp"},{"name":"CPPd1GameModeBase.h","path":"CPPd1GameModeBase.h"},{"name":"CPPd1GameStateBase.cpp","path":"CPPd1GameStateBase.cpp"},{"name":"CPPd1GameStateBase.h","path":"CPPd1GameStateBase.h"},{"name":"CPPd1GoalZone.cpp","path":"CPPd1GoalZone.cpp"},{"name":"CPPd1GoalZone.h","path":"CPPd1GoalZone.h"},{"name":"CPPd1InputManager.cpp","path":"CPPd1InputManager.cpp"},{"name":"CPPd1InputManager.h","path":"CPPd1InputManager.h"},{"name":"CPPd1LockOnTargetComponent.cpp","path":"CPPd1LockOnTargetComponent.cpp"},{"name":"CPPd1LockOnTargetComponent.h","path":"CPPd1LockOnTargetComponent.h"},{"name":"CPPd1PlayerController.cpp","path":"CPPd1PlayerController.cpp"},{"name":"CPPd1PlayerController.h","path":"CPPd1PlayerController.h"},{"name":"CPPd1PlayerState.cpp","path":"CPPd1PlayerState.cpp"},{"name":"CPPd1PlayerState.h","path":"CPPd1PlayerState.h"},{"name":"CPPd1SplitScreenManager.cpp","path":"CPPd1SplitScreenManager.cpp"},{"name":"CPPd1SplitScreenManager.h","path":"CPPd1SplitScreenManager.h"}]};

let currentFile = null;

// ── escape helpers ────────────────────────────────────────────────────────
function esc(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}
function escRegex(s) {
  var out = '';
  var sp = '\\.[]{}()*+?^|';
  for (var i = 0; i < s.length; i++) { if (sp.indexOf(s[i]) !== -1) out += '\\'; out += s[i]; }
  return out;
}

// ── sidebar hamburger ─────────────────────────────────────────────────────
const sidebar  = document.getElementById('sidebar');
const overlay  = document.getElementById('overlay');
const hamburger = document.getElementById('hamburger');

function openSidebar()  { sidebar.classList.add('open');  overlay.classList.add('open'); }
function closeSidebar() { sidebar.classList.remove('open'); overlay.classList.remove('open'); }
hamburger.addEventListener('click', () => sidebar.classList.contains('open') ? closeSidebar() : openSidebar());
overlay.addEventListener('click', closeSidebar);

// ── build tree HTML ───────────────────────────────────────────────────────
function extTag(name) {
  if (name.endsWith('.cpp')) return '<span class="ext-cpp">CPP</span>';
  if (name.endsWith('.h'))   return '<span class="ext-h">H</span>';
  return '';
}

function renderNode(node, depth) {
  let html = '';
  for (const f of node.files) {
    const indent = (depth * 14) + 22;
    html += `<div class="tree-file" data-path="${esc(f.path)}" style="padding-left:${indent}px" title="${esc(f.path)}">${extTag(f.name)}<span>${esc(f.name)}</span></div>`;
  }
  for (const key of Object.keys(node.children).sort()) {
    const child = node.children[key];
    const id    = 'f_' + child.path.replace(/[^a-z0-9]/gi,'_');
    const indent = (depth * 14) + 8;
    html += `<div class="tree-folder">
      <div class="tree-folder-label open" data-folder="${id}" style="padding-left:${indent}px">
        <span class="icon">▶</span><span>${esc(child.name)}</span>
      </div>
      <div class="tree-children open" id="${id}">${renderNode(child, depth + 1)}</div>
    </div>`;
  }
  return html;
}

document.getElementById('tree-root').innerHTML = renderNode(TREE, 0);

// ── folder toggle ─────────────────────────────────────────────────────────
document.getElementById('tree-root').addEventListener('click', e => {
  const lbl = e.target.closest('[data-folder]');
  if (lbl) {
    const ch = document.getElementById(lbl.dataset.folder);
    const open = ch.classList.toggle('open');
    lbl.classList.toggle('open', open);
    return;
  }
  const fi = e.target.closest('[data-path]');
  if (fi) { openFile(fi.dataset.path); closeSidebar(); }
});

// ── open file ─────────────────────────────────────────────────────────────
function openFile(path) {
  const content = FILES[path];
  if (content === undefined) return;
  currentFile = path;

  document.querySelectorAll('.tree-file.active').forEach(el => el.classList.remove('active'));
  const el = document.querySelector(`.tree-file[data-path="${CSS.escape(path)}"]`);
  if (el) { el.classList.add('active'); el.scrollIntoView({ block: 'nearest' }); }

  const parts = path.split('/');
  const crumb = parts.slice(0,-1).map(p => `<span>${esc(p)}</span><span class="sep">/</span>`).join('') + `<span>${esc(parts.at(-1))}</span>`;
  document.getElementById('breadcrumb').innerHTML = crumb;
  document.getElementById('line-count').textContent = content.split('\n').length + ' lines';

  document.getElementById('welcome').style.display = 'none';
  document.getElementById('search-results').classList.remove('visible');
  const pre    = document.getElementById('code-pre');
  const codeEl = document.getElementById('code-display');
  pre.style.display = 'block';
  codeEl.textContent = content;
  hljs.highlightElement(codeEl);
  document.getElementById('code-wrap').scrollTop = 0;
}

// ── quick nav ─────────────────────────────────────────────────────────────
const SECTIONS = [
  { label: 'Core Framework',      prefix: '',                        hint: ['CPPd1Character.cpp','CPPd1Character.h','CPPd1InputManager.cpp','CPPd1InputManager.h','CPPd1SplitScreenManager.cpp','CPPd1SplitScreenManager.h','CPPd1LockOnTargetComponent.cpp','CPPd1LockOnTargetComponent.h','CPPd1PlayerController.cpp','CPPd1PlayerController.h','CPPd1GameMode.cpp','CPPd1GameMode.h','CPPd1.cpp','CPPd1.h'] },
  { label: 'Combat — Characters', prefix: 'Variant_Combat/',         hint: ['CombatCharacter.cpp','CombatCharacter.h','NinjaCharacter.cpp','NinjaCharacter.h','CubeNinjaCharacter.cpp','CubeNinjaCharacter.h'] },
  { label: 'Combat — AI',         prefix: 'Variant_Combat/AI/',      hint: ['CombatEnemy.cpp','CombatEnemy.h','NinjaEnemy.cpp','NinjaEnemy.h','BruteMarauder.cpp','BruteMarauder.h','TricksterMarauder.cpp','TricksterMarauder.h','CombatWaveSpawner.cpp','CombatWaveSpawner.h','SpinningRadiusWaveSpawner.cpp','SpinningRadiusWaveSpawner.h'] },
  { label: 'Combat — Systems',    prefix: 'Variant_Combat/',         hint: ['CombatSkillSystem.cpp','CombatSkillSystem.h','CombatStaminaSystem.cpp','CombatStaminaSystem.h','CombatFlowSystem.cpp','CombatFlowSystem.h','CombatTrickSystem.cpp','CombatTrickSystem.h','CombatAdvancedMechanics.cpp','CombatAdvancedMechanics.h'] },
  { label: 'Platforming',         prefix: 'Variant_Platforming/',    hint: ['PlatformingCharacter.cpp','PlatformingCharacter.h','PlatformingGameMode.cpp','PlatformingGameMode.h'] },
  { label: 'SideScrolling',       prefix: 'Variant_SideScrolling/',  hint: ['SideScrollingCharacter.cpp','SideScrollingCharacter.h','SideScrollingCameraManager.cpp','SideScrollingCameraManager.h'] },
  { label: 'Procedural',          prefix: 'Procedural/',             hint: ['CPPd1ProceduralCube.cpp','CPPd1ProceduralCube.h','CubeNinjaBodyComponent.cpp','CubeNinjaBodyComponent.h'] },
];

const qnav = document.getElementById('quick-nav');
for (const sec of SECTIONS) {
  const valid = sec.hint.filter(f => FILES[sec.prefix + f]);
  if (!valid.length) continue;
  const first = sec.prefix + valid[0];
  const row = document.createElement('div');
  row.className = 'section-row';
  row.innerHTML = `<span>${esc(sec.label)}</span><span class="count">${valid.length} files</span>`;
  row.addEventListener('click', () => openFile(first));
  qnav.appendChild(row);
}

// ── search ─────────────────────────────────────────────────────────────────
const searchEl  = document.getElementById('search');
const resultsEl = document.getElementById('search-results');
let searchTimer = null;

searchEl.addEventListener('input', () => { clearTimeout(searchTimer); searchTimer = setTimeout(doSearch, 150); });

function doSearch() {
  const q = searchEl.value.trim().toLowerCase();
  if (!q) {
    resultsEl.classList.remove('visible');
    resultsEl.innerHTML = '';
    if (currentFile) document.getElementById('code-pre').style.display = 'block';
    else document.getElementById('welcome').style.display = '';
    return;
  }
  document.getElementById('welcome').style.display = 'none';
  document.getElementById('code-pre').style.display = 'none';
  resultsEl.innerHTML = '';
  resultsEl.classList.add('visible');

  const matches = [];
  for (const [path, content] of Object.entries(FILES)) {
    const fname = path.split('/').pop().toLowerCase();
    if (fname.includes(q)) matches.push({ path, lineNum: 0, lineText: path, type: 'file' });
    const lines = content.split('\n');
    let count = 0;
    for (let i = 0; i < lines.length && count < 15; i++) {
      if (lines[i].toLowerCase().includes(q)) { matches.push({ path, lineNum: i+1, lineText: lines[i].trim(), type: 'content' }); count++; }
    }
  }

  if (!matches.length) {
    resultsEl.innerHTML = '<div style="padding:20px;color:var(--dim);font-size:13px">No results.</div>';
    return;
  }

  const re = new RegExp(escRegex(q), 'gi');
  for (const m of matches.slice(0, 200)) {
    const fname = m.path.split('/').pop();
    const highlighted = m.lineText.replace(re, match => `<span class="sr-match">${esc(match)}</span>`);
    const div = document.createElement('div');
    div.className = 'sr-item';
    if (m.type === 'file') {
      div.innerHTML = `<span class="sr-file">${esc(fname)}</span><span class="sr-line">file</span>`;
    } else {
      div.innerHTML = `<span class="sr-file">${esc(fname)}</span><span class="sr-line">:${m.lineNum}</span><span class="sr-text">${highlighted}</span>`;
    }
    div.addEventListener('click', () => { searchEl.value=''; doSearch(); openFile(m.path); });
    resultsEl.appendChild(div);
  }
  if (matches.length > 200) {
    const more = document.createElement('div');
    more.style.cssText = 'padding:10px 16px;color:var(--dim);font-size:12px';
    more.textContent = `… ${matches.length - 200} more. Refine search.`;
    resultsEl.appendChild(more);
  }
}

// ── keyboard shortcuts ────────────────────────────────────────────────────
document.addEventListener('keydown', e => {
  if ((e.metaKey || e.ctrlKey) && e.key === 'k') { e.preventDefault(); searchEl.focus(); searchEl.select(); }
  if (e.key === 'Escape') { searchEl.value = ''; doSearch(); searchEl.blur(); }
});
</script>
</body>
</html>